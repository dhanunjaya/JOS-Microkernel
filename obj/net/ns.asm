
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 df 08 00 00       	call   800910 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 c0 83 81 00 	movl   $0x0,0x8183c0(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(void)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 a5 18 00 00       	call   801909 <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 80 81 00 7f 	movl   $0x812c7f,0x818000
  80006d:	2c 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 82 1a 00 00       	call   801af7 <fork>
  800075:	a3 a4 83 81 00       	mov    %eax,0x8183a4
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 40 24 81 	movl   $0x812440,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  800095:	e8 e2 08 00 00       	call   80097c <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
		return;
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 3f 1a 00 00       	call   801af7 <fork>
  8000b8:	a3 a8 83 81 00       	mov    %eax,0x8183a8
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 40 24 81 	movl   $0x812440,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  8000d8:	e8 9f 08 00 00       	call   80097c <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 2b 07 00 00       	call   800814 <input>
		return;
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop
  8000ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8000f0:	e8 02 1a 00 00       	call   801af7 <fork>
  8000f5:	a3 ac 83 81 00       	mov    %eax,0x8183ac
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 40 24 81 	movl   $0x812440,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  800115:	e8 62 08 00 00       	call   80097c <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 a6 07 00 00       	call   8008cc <output>
		return;
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization. 
	thread_init();
  800128:	e8 23 dd 00 00       	call   80de50 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 14 07 80 	movl   $0x800714,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 59 24 81 	movl   $0x812459,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 e6 de 00 00       	call   80e037 <thread_create>
	thread_yield();
  800151:	e8 9a dd 00 00       	call   80def0 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 3c             	sub    $0x3c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80016a:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80016d:	eb 08                	jmp    800177 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016f:	e8 7c dd 00 00       	call   80def0 <thread_yield>
	
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800174:	83 c3 01             	add    $0x1,%ebx
  800177:	e8 25 dd 00 00       	call   80dea1 <thread_wakeups_pending>
  80017c:	85 c0                	test   %eax,%eax
  80017e:	74 05                	je     800185 <serve+0x29>
  800180:	83 fb 1f             	cmp    $0x1f,%ebx
  800183:	7e ea                	jle    80016f <serve+0x13>
			thread_yield();

		perm = 0;
  800185:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018c:	83 3d c0 83 81 00 00 	cmpl   $0x0,0x8183c0
  800193:	74 3b                	je     8001d0 <serve+0x74>
  800195:	b8 01 00 00 00       	mov    $0x1,%eax
  80019a:	ba c0 83 81 00       	mov    $0x8183c0,%edx
  80019f:	83 3c 82 00          	cmpl   $0x0,(%edx,%eax,4)
  8001a3:	74 0a                	je     8001af <serve+0x53>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8001a5:	83 c0 01             	add    $0x1,%eax
  8001a8:	83 f8 14             	cmp    $0x14,%eax
  8001ab:	75 f2                	jne    80019f <serve+0x43>
  8001ad:	eb 05                	jmp    8001b4 <serve+0x58>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001af:	83 f8 14             	cmp    $0x14,%eax
  8001b2:	75 21                	jne    8001d5 <serve+0x79>
		panic("NS: buffer overflow");
  8001b4:	c7 44 24 08 5e 24 81 	movl   $0x81245e,0x8(%esp)
  8001bb:	00 
  8001bc:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001c3:	00 
  8001c4:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  8001cb:	e8 ac 07 00 00       	call   80097c <_panic>
  8001d0:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001d5:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001db:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001de:	c7 04 85 c0 83 81 00 	movl   $0x1,0x8183c0(,%eax,4)
  8001e5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8001ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001f4:	89 04 24             	mov    %eax,(%esp)
  8001f7:	e8 96 1b 00 00       	call   801d92 <ipc_recv>
  8001fc:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001fe:	83 f8 0c             	cmp    $0xc,%eax
  800201:	75 67                	jne    80026a <serve+0x10e>
			process_timer(whom);
  800203:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800206:	3b 35 a4 83 81 00    	cmp    0x8183a4,%esi
  80020c:	74 12                	je     800220 <serve+0xc4>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80020e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800212:	c7 04 24 ec 24 81 00 	movl   $0x8124ec,(%esp)
  800219:	e8 23 08 00 00       	call   800a41 <cprintf>
  80021e:	eb 39                	jmp    800259 <serve+0xfd>
		return;
	}

	start = sys_time_msec();
  800220:	e8 b2 13 00 00       	call   8015d7 <sys_time_msec>
  800225:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800228:	e8 c3 dc 00 00       	call   80def0 <thread_yield>
	now = sys_time_msec();
  80022d:	e8 a5 13 00 00       	call   8015d7 <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800239:	00 
  80023a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800241:	00 
  800242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800245:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80024b:	29 c2                	sub    %eax,%edx
  80024d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800251:	89 34 24             	mov    %esi,(%esp)
  800254:	e8 d7 1a 00 00       	call   801d30 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800259:	89 d8                	mov    %ebx,%eax
  80025b:	e8 e0 fd ff ff       	call   800040 <put_buffer>
  800260:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  800265:	e9 0d ff ff ff       	jmp    800177 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80026a:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80026e:	66 90                	xchg   %ax,%ax
  800270:	75 1d                	jne    80028f <serve+0x133>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
  800279:	c7 04 24 28 25 81 00 	movl   $0x812528,(%esp)
  800280:	e8 bc 07 00 00       	call   800a41 <cprintf>
  800285:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  80028a:	e9 e8 fe ff ff       	jmp    800177 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80028f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800296:	e8 48 2a 00 00       	call   802ce3 <malloc>
		if (!args)
  80029b:	85 c0                	test   %eax,%eax
  80029d:	75 1c                	jne    8002bb <serve+0x15f>
			panic("could not allocate thread args structure");
  80029f:	c7 44 24 08 58 25 81 	movl   $0x812558,0x8(%esp)
  8002a6:	00 
  8002a7:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002ae:	00 
  8002af:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  8002b6:	e8 c1 06 00 00       	call   80097c <_panic>

		args->reqno = reqno;
  8002bb:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8002bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002c3:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002ca:	c7 44 24 08 f5 02 80 	movl   $0x8002f5,0x8(%esp)
  8002d1:	00 
  8002d2:	c7 44 24 04 72 24 81 	movl   $0x812472,0x4(%esp)
  8002d9:	00 
  8002da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002e1:	e8 51 dd 00 00       	call   80e037 <thread_create>
		thread_yield(); // let the thread created run
  8002e6:	e8 05 dc 00 00       	call   80def0 <thread_yield>
  8002eb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002f0:	e9 82 fe ff ff       	jmp    800177 <serve+0x1b>

008002f5 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002f5:	55                   	push   %ebp
  8002f6:	89 e5                	mov    %esp,%ebp
  8002f8:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800301:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800304:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  800307:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  80030a:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80030d:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800310:	0f 87 34 01 00 00    	ja     80044a <serve_thread+0x155>
  800316:	8b 03                	mov    (%ebx),%eax
  800318:	ff 24 85 24 26 81 00 	jmp    *0x812624(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80031f:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800322:	89 44 24 08          	mov    %eax,0x8(%esp)
  800326:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800329:	89 44 24 04          	mov    %eax,0x4(%esp)
  80032d:	8b 06                	mov    (%esi),%eax
  80032f:	89 04 24             	mov    %eax,(%esp)
  800332:	e8 fb 49 00 00       	call   804d32 <lwip_accept>
  800337:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800339:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800340:	00 
  800341:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
  800348:	89 34 24             	mov    %esi,(%esp)
  80034b:	e8 85 0f 00 00       	call   8012d5 <memmove>
		break;
  800350:	e9 13 01 00 00       	jmp    800468 <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800355:	8b 46 14             	mov    0x14(%esi),%eax
  800358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80035c:	8d 46 04             	lea    0x4(%esi),%eax
  80035f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800363:	8b 06                	mov    (%esi),%eax
  800365:	89 04 24             	mov    %eax,(%esp)
  800368:	e8 0c 49 00 00       	call   804c79 <lwip_bind>
  80036d:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80036f:	e9 f4 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800374:	8b 46 04             	mov    0x4(%esi),%eax
  800377:	89 44 24 04          	mov    %eax,0x4(%esp)
  80037b:	8b 06                	mov    (%esi),%eax
  80037d:	89 04 24             	mov    %eax,(%esp)
  800380:	e8 99 47 00 00       	call   804b1e <lwip_shutdown>
  800385:	89 c7                	mov    %eax,%edi
		break;
  800387:	e9 dc 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80038c:	8b 06                	mov    (%esi),%eax
  80038e:	89 04 24             	mov    %eax,(%esp)
  800391:	e8 0c 47 00 00       	call   804aa2 <lwip_close>
  800396:	89 c7                	mov    %eax,%edi
		break;
  800398:	e9 cb 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80039d:	8b 46 14             	mov    0x14(%esi),%eax
  8003a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003a4:	8d 46 04             	lea    0x4(%esi),%eax
  8003a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003ab:	8b 06                	mov    (%esi),%eax
  8003ad:	89 04 24             	mov    %eax,(%esp)
  8003b0:	e8 0b 48 00 00       	call   804bc0 <lwip_connect>
  8003b5:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003b7:	e9 ac 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003bc:	8b 46 04             	mov    0x4(%esi),%eax
  8003bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003c3:	8b 06                	mov    (%esi),%eax
  8003c5:	89 04 24             	mov    %eax,(%esp)
  8003c8:	e8 64 47 00 00       	call   804b31 <lwip_listen>
  8003cd:	89 c7                	mov    %eax,%edi
		break;
  8003cf:	e9 94 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003d4:	8b 46 08             	mov    0x8(%esi),%eax
  8003d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003db:	8b 46 04             	mov    0x4(%esi),%eax
  8003de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003e6:	8b 06                	mov    (%esi),%eax
  8003e8:	89 04 24             	mov    %eax,(%esp)
  8003eb:	e8 41 46 00 00       	call   804a31 <lwip_recv>
  8003f0:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003f2:	eb 74                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003f4:	8b 46 08             	mov    0x8(%esi),%eax
  8003f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003fb:	8b 46 04             	mov    0x4(%esi),%eax
  8003fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800402:	8d 46 0c             	lea    0xc(%esi),%eax
  800405:	89 44 24 04          	mov    %eax,0x4(%esp)
  800409:	8b 06                	mov    (%esi),%eax
  80040b:	89 04 24             	mov    %eax,(%esp)
  80040e:	e8 97 41 00 00       	call   8045aa <lwip_send>
  800413:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800415:	eb 51                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800417:	8b 46 08             	mov    0x8(%esi),%eax
  80041a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80041e:	8b 46 04             	mov    0x4(%esi),%eax
  800421:	89 44 24 04          	mov    %eax,0x4(%esp)
  800425:	8b 06                	mov    (%esi),%eax
  800427:	89 04 24             	mov    %eax,(%esp)
  80042a:	e8 8d 40 00 00       	call   8044bc <lwip_socket>
  80042f:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800431:	eb 35                	jmp    800468 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800433:	89 74 24 04          	mov    %esi,0x4(%esp)
  800437:	c7 04 24 c0 e5 b3 00 	movl   $0xb3e5c0,(%esp)
  80043e:	e8 37 e0 00 00       	call   80e47a <jif_input>
  800443:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800448:	eb 4c                	jmp    800496 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80044a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80044e:	8b 43 04             	mov    0x4(%ebx),%eax
  800451:	89 44 24 04          	mov    %eax,0x4(%esp)
  800455:	c7 04 24 84 25 81 00 	movl   $0x812584,(%esp)
  80045c:	e8 e0 05 00 00       	call   800a41 <cprintf>
  800461:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800466:	eb 2e                	jmp    800496 <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800468:	83 ff ff             	cmp    $0xffffffff,%edi
  80046b:	75 29                	jne    800496 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80046d:	8b 03                	mov    (%ebx),%eax
  80046f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800473:	c7 44 24 08 7f 24 81 	movl   $0x81247f,0x8(%esp)
  80047a:	00 
  80047b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800482:	00 
  800483:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800486:	89 34 24             	mov    %esi,(%esp)
  800489:	e8 eb 0b 00 00       	call   801079 <snprintf>
		perror(buf);
  80048e:	89 34 24             	mov    %esi,(%esp)
  800491:	e8 b1 dd 00 00       	call   80e247 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800496:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800499:	74 1f                	je     8004ba <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8004a2:	00 
  8004a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8004aa:	00 
  8004ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8004af:	8b 43 04             	mov    0x4(%ebx),%eax
  8004b2:	89 04 24             	mov    %eax,(%esp)
  8004b5:	e8 76 18 00 00       	call   801d30 <ipc_send>

	put_buffer(args->req);
  8004ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8004bd:	e8 7e fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8004c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004d0:	e8 e5 12 00 00       	call   8017ba <sys_page_unmap>
	free(args);
  8004d5:	89 1c 24             	mov    %ebx,(%esp)
  8004d8:	e8 33 27 00 00       	call   802c10 <free>
}
  8004dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004e6:	89 ec                	mov    %ebp,%esp
  8004e8:	5d                   	pop    %ebp
  8004e9:	c3                   	ret    

008004ea <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004ea:	55                   	push   %ebp
  8004eb:	89 e5                	mov    %esp,%ebp
  8004ed:	56                   	push   %esi
  8004ee:	53                   	push   %ebx
  8004ef:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004f2:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004f5:	e8 dd 10 00 00       	call   8015d7 <sys_time_msec>
  8004fa:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004fc:	e8 58 d0 00 00       	call   80d559 <lwip_core_lock>
		t->func();
  800501:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800504:	e8 55 d0 00 00       	call   80d55e <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800509:	03 33                	add    (%ebx),%esi
  80050b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800516:	00 
  800517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80051e:	e8 5c dc 00 00       	call   80e17f <thread_wait>
  800523:	eb d0                	jmp    8004f5 <net_timer+0xb>

00800525 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800525:	55                   	push   %ebp
  800526:	89 e5                	mov    %esp,%ebp
  800528:	53                   	push   %ebx
  800529:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80052c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80052f:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800531:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800534:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800537:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80053b:	c7 44 24 08 ea 04 80 	movl   $0x8004ea,0x8(%esp)
  800542:	00 
  800543:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80054e:	e8 e4 da 00 00       	call   80e037 <thread_create>
	if (r < 0)
  800553:	85 c0                	test   %eax,%eax
  800555:	79 28                	jns    80057f <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800557:	89 04 24             	mov    %eax,(%esp)
  80055a:	e8 d9 dc 00 00       	call   80e238 <e2s>
  80055f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800563:	c7 44 24 08 a8 25 81 	movl   $0x8125a8,0x8(%esp)
  80056a:	00 
  80056b:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800572:	00 
  800573:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  80057a:	e8 fd 03 00 00       	call   80097c <_panic>
}
  80057f:	83 c4 14             	add    $0x14,%esp
  800582:	5b                   	pop    %ebx
  800583:	5d                   	pop    %ebp
  800584:	c3                   	ret    

00800585 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800585:	55                   	push   %ebp
  800586:	89 e5                	mov    %esp,%ebp
  800588:	56                   	push   %esi
  800589:	53                   	push   %ebx
  80058a:	83 ec 30             	sub    $0x30,%esp
  80058d:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800590:	e8 c4 cf 00 00       	call   80d559 <lwip_core_lock>

	uint32_t done = 0;
  800595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80059f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8005a3:	c7 04 24 67 07 80 00 	movl   $0x800767,(%esp)
  8005aa:	e8 74 49 00 00       	call   804f23 <tcpip_init>
	lwip_core_unlock();
  8005af:	e8 aa cf 00 00       	call   80d55e <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005b4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005bb:	ff 
  8005bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005c3:	00 
  8005c4:	89 1c 24             	mov    %ebx,(%esp)
  8005c7:	e8 b3 db 00 00       	call   80e17f <thread_wait>
	lwip_core_lock();
  8005cc:	e8 88 cf 00 00       	call   80d559 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005d1:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005da:	8b 45 10             	mov    0x10(%ebp),%eax
  8005dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005e0:	c7 44 24 18 94 9b 80 	movl   $0x809b94,0x18(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 14 80 e2 80 	movl   $0x80e280,0x14(%esp)
  8005ef:	00 
  8005f0:	c7 44 24 10 ac 83 81 	movl   $0x8183ac,0x10(%esp)
  8005f7:	00 
  8005f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800602:	89 44 24 08          	mov    %eax,0x8(%esp)
  800606:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800609:	89 44 24 04          	mov    %eax,0x4(%esp)
  80060d:	c7 04 24 c0 e5 b3 00 	movl   $0xb3e5c0,(%esp)
  800614:	e8 c8 73 00 00       	call   8079e1 <netif_add>
  800619:	85 c0                	test   %eax,%eax
  80061b:	75 1c                	jne    800639 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  80061d:	c7 44 24 08 c8 25 81 	movl   $0x8125c8,0x8(%esp)
  800624:	00 
  800625:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  80062c:	00 
  80062d:	c7 04 24 4e 24 81 00 	movl   $0x81244e,(%esp)
  800634:	e8 43 03 00 00       	call   80097c <_panic>

	netif_set_default(nif);
  800639:	c7 04 24 c0 e5 b3 00 	movl   $0xb3e5c0,(%esp)
  800640:	e8 1c 72 00 00       	call   807861 <netif_set_default>
	netif_set_up(nif);
  800645:	c7 04 24 c0 e5 b3 00 	movl   $0xb3e5c0,(%esp)
  80064c:	e8 9d 72 00 00       	call   8078ee <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800651:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800658:	b9 8e 24 81 00       	mov    $0x81248e,%ecx
  80065d:	ba fc cf 80 00       	mov    $0x80cffc,%edx
  800662:	b8 80 83 81 00       	mov    $0x818380,%eax
  800667:	e8 b9 fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80066c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800673:	b9 98 24 81 00       	mov    $0x812498,%ecx
  800678:	ba 8b 89 80 00       	mov    $0x80898b,%edx
  80067d:	b8 8c 83 81 00       	mov    $0x81838c,%eax
  800682:	e8 9e fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800687:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80068e:	b9 a4 24 81 00       	mov    $0x8124a4,%ecx
  800693:	ba be 92 80 00       	mov    $0x8092be,%edx
  800698:	b8 98 83 81 00       	mov    $0x818398,%eax
  80069d:	e8 83 fe ff ff       	call   800525 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x" 
  8006a2:	89 34 24             	mov    %esi,(%esp)
  8006a5:	e8 66 a5 00 00       	call   80ac10 <inet_ntoa>
  8006aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006ae:	0f b6 05 ea e5 b3 00 	movzbl 0xb3e5ea,%eax
  8006b5:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006b9:	0f b6 05 e9 e5 b3 00 	movzbl 0xb3e5e9,%eax
  8006c0:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006c4:	0f b6 05 e8 e5 b3 00 	movzbl 0xb3e5e8,%eax
  8006cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006cf:	0f b6 05 e7 e5 b3 00 	movzbl 0xb3e5e7,%eax
  8006d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006da:	0f b6 05 e6 e5 b3 00 	movzbl 0xb3e5e6,%eax
  8006e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006e5:	0f b6 05 e5 e5 b3 00 	movzbl 0xb3e5e5,%eax
  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006f0:	c7 04 24 e8 25 81 00 	movl   $0x8125e8,(%esp)
  8006f7:	e8 45 03 00 00       	call   800a41 <cprintf>
		" bound to static IP %s\n", 
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006fc:	e8 5d ce 00 00       	call   80d55e <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800701:	c7 04 24 b0 24 81 00 	movl   $0x8124b0,(%esp)
  800708:	e8 34 03 00 00       	call   800a41 <cprintf>
}
  80070d:	83 c4 30             	add    $0x30,%esp
  800710:	5b                   	pop    %ebx
  800711:	5e                   	pop    %esi
  800712:	5d                   	pop    %ebp
  800713:	c3                   	ret    

00800714 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800714:	55                   	push   %ebp
  800715:	89 e5                	mov    %esp,%ebp
  800717:	83 ec 18             	sub    $0x18,%esp
  80071a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80071d:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800720:	c7 04 24 c9 24 81 00 	movl   $0x8124c9,(%esp)
  800727:	e8 cc a7 00 00       	call   80aef8 <inet_addr>
  80072c:	89 c3                	mov    %eax,%ebx
  80072e:	c7 04 24 d2 24 81 00 	movl   $0x8124d2,(%esp)
  800735:	e8 be a7 00 00       	call   80aef8 <inet_addr>
  80073a:	89 c6                	mov    %eax,%esi
  80073c:	c7 04 24 e0 24 81 00 	movl   $0x8124e0,(%esp)
  800743:	e8 b0 a7 00 00       	call   80aef8 <inet_addr>
  800748:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80074c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800750:	89 04 24             	mov    %eax,(%esp)
  800753:	e8 2d fe ff ff       	call   800585 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800758:	e8 ff f9 ff ff       	call   80015c <serve>
}
  80075d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800760:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800763:	89 ec                	mov    %ebp,%esp
  800765:	5d                   	pop    %ebp
  800766:	c3                   	ret    

00800767 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800767:	55                   	push   %ebp
  800768:	89 e5                	mov    %esp,%ebp
  80076a:	83 ec 18             	sub    $0x18,%esp
  80076d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800770:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800776:	89 04 24             	mov    %eax,(%esp)
  800779:	e8 01 d7 00 00       	call   80de7f <thread_wakeup>
}
  80077e:	c9                   	leave  
  80077f:	c3                   	ret    

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 75 08             	mov    0x8(%ebp),%esi
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 46 0e 00 00       	call   8015d7 <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 80 81 00 50 	movl   $0x812650,0x818000
  80079d:	26 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
			sys_yield();
  8007a5:	e8 2b 11 00 00       	call   8018d5 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
  8007aa:	e8 28 0e 00 00       	call   8015d7 <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	77 f2                	ja     8007a5 <timer+0x25>
			sys_yield();
		}

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007ba:	00 
  8007bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c2:	00 
  8007c3:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007ca:	00 
  8007cb:	89 34 24             	mov    %esi,(%esp)
  8007ce:	e8 5d 15 00 00       	call   801d30 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007da:	00 
  8007db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e2:	00 
  8007e3:	89 3c 24             	mov    %edi,(%esp)
  8007e6:	e8 a7 15 00 00       	call   801d92 <ipc_recv>
  8007eb:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8007ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007f0:	39 c6                	cmp    %eax,%esi
  8007f2:	74 12                	je     800806 <timer+0x86>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f8:	c7 04 24 5c 26 81 00 	movl   $0x81265c,(%esp)
  8007ff:	e8 3d 02 00 00       	call   800a41 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800804:	eb cd                	jmp    8007d3 <timer+0x53>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800806:	e8 cc 0d 00 00       	call   8015d7 <sys_time_msec>
  80080b:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  80080e:	66 90                	xchg   %ax,%ax
  800810:	eb 98                	jmp    8007aa <timer+0x2a>
	...

00800814 <input>:
extern union Nsipc nsipcbuf;
uint32_t len=0;

void
input(envid_t ns_envid)
{
  800814:	55                   	push   %ebp
  800815:	89 e5                	mov    %esp,%ebp
  800817:	53                   	push   %ebx
  800818:	83 ec 14             	sub    $0x14,%esp
  80081b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_input";
  80081e:	c7 05 00 80 81 00 97 	movl   $0x812697,0x818000
  800825:	26 81 00 
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
           
   while(1)
   {
     if(sys_page_alloc(sys_getenvid(),&nsipcbuf,PTE_W|PTE_U|PTE_P)< 0 )
  800828:	e8 dc 10 00 00       	call   801909 <sys_getenvid>
  80082d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  800834:	00 
  800835:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  80083c:	00 
  80083d:	89 04 24             	mov    %eax,(%esp)
  800840:	e8 31 10 00 00       	call   801876 <sys_page_alloc>
  800845:	85 c0                	test   %eax,%eax
  800847:	79 1c                	jns    800865 <input+0x51>
        panic("\nout of pages\n");
  800849:	c7 44 24 08 a0 26 81 	movl   $0x8126a0,0x8(%esp)
  800850:	00 
  800851:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  800858:	00 
  800859:	c7 04 24 af 26 81 00 	movl   $0x8126af,(%esp)
  800860:	e8 17 01 00 00       	call   80097c <_panic>
      
       //cprintf("len--->%x",&len);
    	if(sys_call_receive_packet(nsipcbuf.pkt.jp_data,&nsipcbuf.pkt.jp_len)>=0)
  800865:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  80086c:	00 
  80086d:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  800874:	e8 ca 0c 00 00       	call   801543 <sys_call_receive_packet>
  800879:	85 c0                	test   %eax,%eax
  80087b:	78 36                	js     8008b3 <input+0x9f>
	{
        	 //cprintf("\nHere inside input.c -ve\n"); 
		cprintf("\nInside else---->>>>>>\n");
  80087d:	c7 04 24 bb 26 81 00 	movl   $0x8126bb,(%esp)
  800884:	e8 b8 01 00 00       	call   800a41 <cprintf>
        	ipc_send(ns_envid,NSREQ_INPUT,&nsipcbuf,PTE_W|PTE_U|PTE_P);
  800889:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  800890:	00 
  800891:	c7 44 24 08 00 70 81 	movl   $0x817000,0x8(%esp)
  800898:	00 
  800899:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008a0:	00 
  8008a1:	89 1c 24             	mov    %ebx,(%esp)
  8008a4:	e8 87 14 00 00       	call   801d30 <ipc_send>
   		sys_yield();
  8008a9:	e8 27 10 00 00       	call   8018d5 <sys_yield>
  		sys_yield();
  8008ae:	e8 22 10 00 00       	call   8018d5 <sys_yield>
	}

  sys_page_unmap(0,&nsipcbuf);
  8008b3:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  8008ba:	00 
  8008bb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8008c2:	e8 f3 0e 00 00       	call   8017ba <sys_page_unmap>

}
  8008c7:	e9 5c ff ff ff       	jmp    800828 <input+0x14>

008008cc <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008cc:	55                   	push   %ebp
  8008cd:	89 e5                	mov    %esp,%ebp
  8008cf:	83 ec 18             	sub    $0x18,%esp
	binaryname = "ns_output";
  8008d2:	c7 05 00 80 81 00 d3 	movl   $0x8126d3,0x818000
  8008d9:	26 81 00 
	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
   while(1)
    {
       ipc_recv(NULL,(void *)&nsipcbuf,NULL);
  8008dc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8008e3:	00 
  8008e4:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  8008eb:	00 
  8008ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8008f3:	e8 9a 14 00 00       	call   801d92 <ipc_recv>
         {
           cprintf("%c",nsipcbuf.pkt.jp_data[i]);
           i++;
         }
*/
       sys_call_packet_send((void *)nsipcbuf.pkt.jp_data,nsipcbuf.pkt.jp_len); 
  8008f8:	a1 00 70 81 00       	mov    0x817000,%eax
  8008fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  800901:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  800908:	e8 6c 0c 00 00       	call   801579 <sys_call_packet_send>
  80090d:	eb cd                	jmp    8008dc <output+0x10>
	...

00800910 <libmain>:
volatile struct Env *env;
char *binaryname = "(PROGRAM NAME UNKNOWN)";

void
libmain(int argc, char **argv)
{
  800910:	55                   	push   %ebp
  800911:	89 e5                	mov    %esp,%ebp
  800913:	83 ec 18             	sub    $0x18,%esp
  800916:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800919:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80091c:	8b 75 08             	mov    0x8(%ebp),%esi
  80091f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set env to point at our env structure in envs[].
	// LAB 3: Your code here.
       // uint32_t envid=sys_getenvid();
	env = (envs+ENVX(sys_getenvid()));
  800922:	e8 e2 0f 00 00       	call   801909 <sys_getenvid>
  800927:	25 ff 03 00 00       	and    $0x3ff,%eax
  80092c:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80092f:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  800934:	a3 f4 e5 b3 00       	mov    %eax,0xb3e5f4

	// save the name of the program so that panic() can use it
	if (argc > 0)
  800939:	85 f6                	test   %esi,%esi
  80093b:	7e 07                	jle    800944 <libmain+0x34>
		binaryname = argv[0];
  80093d:	8b 03                	mov    (%ebx),%eax
  80093f:	a3 00 80 81 00       	mov    %eax,0x818000

	// call user main routine
	umain(argc, argv);
  800944:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800948:	89 34 24             	mov    %esi,(%esp)
  80094b:	e8 08 f7 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  800950:	e8 0b 00 00 00       	call   800960 <exit>
}
  800955:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800958:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80095b:	89 ec                	mov    %ebp,%esp
  80095d:	5d                   	pop    %ebp
  80095e:	c3                   	ret    
	...

00800960 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  800960:	55                   	push   %ebp
  800961:	89 e5                	mov    %esp,%ebp
  800963:	83 ec 18             	sub    $0x18,%esp
	close_all();
  800966:	e8 70 19 00 00       	call   8022db <close_all>
	sys_env_destroy(0);
  80096b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800972:	e8 c6 0f 00 00       	call   80193d <sys_env_destroy>
}
  800977:	c9                   	leave  
  800978:	c3                   	ret    
  800979:	00 00                	add    %al,(%eax)
	...

0080097c <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80097c:	55                   	push   %ebp
  80097d:	89 e5                	mov    %esp,%ebp
  80097f:	53                   	push   %ebx
  800980:	83 ec 14             	sub    $0x14,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
  800983:	8d 5d 14             	lea    0x14(%ebp),%ebx
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	if (argv0)
  800986:	a1 f8 e5 b3 00       	mov    0xb3e5f8,%eax
  80098b:	85 c0                	test   %eax,%eax
  80098d:	74 10                	je     80099f <_panic+0x23>
		cprintf("%s: ", argv0);
  80098f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800993:	c7 04 24 f4 26 81 00 	movl   $0x8126f4,(%esp)
  80099a:	e8 a2 00 00 00       	call   800a41 <cprintf>
	cprintf("user panic in %s at %s:%d: ", binaryname, file, line);
  80099f:	8b 45 0c             	mov    0xc(%ebp),%eax
  8009a2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8009a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8009a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8009ad:	a1 00 80 81 00       	mov    0x818000,%eax
  8009b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009b6:	c7 04 24 f9 26 81 00 	movl   $0x8126f9,(%esp)
  8009bd:	e8 7f 00 00 00       	call   800a41 <cprintf>
	vcprintf(fmt, ap);
  8009c2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8009c6:	8b 45 10             	mov    0x10(%ebp),%eax
  8009c9:	89 04 24             	mov    %eax,(%esp)
  8009cc:	e8 0f 00 00 00       	call   8009e0 <vcprintf>
	cprintf("\n");
  8009d1:	c7 04 24 c7 24 81 00 	movl   $0x8124c7,(%esp)
  8009d8:	e8 64 00 00 00       	call   800a41 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  8009dd:	cc                   	int3   
  8009de:	eb fd                	jmp    8009dd <_panic+0x61>

008009e0 <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  8009e0:	55                   	push   %ebp
  8009e1:	89 e5                	mov    %esp,%ebp
  8009e3:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  8009e9:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  8009f0:	00 00 00 
	b.cnt = 0;
  8009f3:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  8009fa:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  8009fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  800a00:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a04:	8b 45 08             	mov    0x8(%ebp),%eax
  800a07:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a0b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  800a11:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a15:	c7 04 24 5b 0a 80 00 	movl   $0x800a5b,(%esp)
  800a1c:	e8 cc 01 00 00       	call   800bed <vprintfmt>
	sys_cputs(b.buf, b.idx);
  800a21:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  800a27:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a2b:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  800a31:	89 04 24             	mov    %eax,(%esp)
  800a34:	e8 d7 0a 00 00       	call   801510 <sys_cputs>

	return b.cnt;
}
  800a39:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  800a3f:	c9                   	leave  
  800a40:	c3                   	ret    

00800a41 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800a41:	55                   	push   %ebp
  800a42:	89 e5                	mov    %esp,%ebp
  800a44:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  800a47:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  800a4a:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a4e:	8b 45 08             	mov    0x8(%ebp),%eax
  800a51:	89 04 24             	mov    %eax,(%esp)
  800a54:	e8 87 ff ff ff       	call   8009e0 <vcprintf>
	va_end(ap);

	return cnt;
}
  800a59:	c9                   	leave  
  800a5a:	c3                   	ret    

00800a5b <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  800a5b:	55                   	push   %ebp
  800a5c:	89 e5                	mov    %esp,%ebp
  800a5e:	53                   	push   %ebx
  800a5f:	83 ec 14             	sub    $0x14,%esp
  800a62:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  800a65:	8b 03                	mov    (%ebx),%eax
  800a67:	8b 55 08             	mov    0x8(%ebp),%edx
  800a6a:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  800a6e:	83 c0 01             	add    $0x1,%eax
  800a71:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  800a73:	3d ff 00 00 00       	cmp    $0xff,%eax
  800a78:	75 19                	jne    800a93 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  800a7a:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800a81:	00 
  800a82:	8d 43 08             	lea    0x8(%ebx),%eax
  800a85:	89 04 24             	mov    %eax,(%esp)
  800a88:	e8 83 0a 00 00       	call   801510 <sys_cputs>
		b->idx = 0;
  800a8d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800a93:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  800a97:	83 c4 14             	add    $0x14,%esp
  800a9a:	5b                   	pop    %ebx
  800a9b:	5d                   	pop    %ebp
  800a9c:	c3                   	ret    
  800a9d:	00 00                	add    %al,(%eax)
	...

00800aa0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800aa0:	55                   	push   %ebp
  800aa1:	89 e5                	mov    %esp,%ebp
  800aa3:	57                   	push   %edi
  800aa4:	56                   	push   %esi
  800aa5:	53                   	push   %ebx
  800aa6:	83 ec 4c             	sub    $0x4c,%esp
  800aa9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800aac:	89 d6                	mov    %edx,%esi
  800aae:	8b 45 08             	mov    0x8(%ebp),%eax
  800ab1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800ab4:	8b 55 0c             	mov    0xc(%ebp),%edx
  800ab7:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800aba:	8b 45 10             	mov    0x10(%ebp),%eax
  800abd:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800ac0:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800ac3:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800ac6:	b9 00 00 00 00       	mov    $0x0,%ecx
  800acb:	39 d1                	cmp    %edx,%ecx
  800acd:	72 15                	jb     800ae4 <printnum+0x44>
  800acf:	77 07                	ja     800ad8 <printnum+0x38>
  800ad1:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800ad4:	39 d0                	cmp    %edx,%eax
  800ad6:	76 0c                	jbe    800ae4 <printnum+0x44>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800ad8:	83 eb 01             	sub    $0x1,%ebx
  800adb:	85 db                	test   %ebx,%ebx
  800add:	8d 76 00             	lea    0x0(%esi),%esi
  800ae0:	7f 61                	jg     800b43 <printnum+0xa3>
  800ae2:	eb 70                	jmp    800b54 <printnum+0xb4>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800ae4:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800ae8:	83 eb 01             	sub    $0x1,%ebx
  800aeb:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800aef:	89 44 24 08          	mov    %eax,0x8(%esp)
  800af3:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  800af7:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  800afb:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800afe:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800b01:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800b04:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800b08:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800b0f:	00 
  800b10:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800b13:	89 04 24             	mov    %eax,(%esp)
  800b16:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800b19:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b1d:	e8 ae 16 01 00       	call   8121d0 <__udivdi3>
  800b22:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800b25:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800b28:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800b2c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b30:	89 04 24             	mov    %eax,(%esp)
  800b33:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b37:	89 f2                	mov    %esi,%edx
  800b39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b3c:	e8 5f ff ff ff       	call   800aa0 <printnum>
  800b41:	eb 11                	jmp    800b54 <printnum+0xb4>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800b43:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b47:	89 3c 24             	mov    %edi,(%esp)
  800b4a:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800b4d:	83 eb 01             	sub    $0x1,%ebx
  800b50:	85 db                	test   %ebx,%ebx
  800b52:	7f ef                	jg     800b43 <printnum+0xa3>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800b54:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b58:	8b 74 24 04          	mov    0x4(%esp),%esi
  800b5c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800b5f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b63:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800b6a:	00 
  800b6b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800b6e:	89 14 24             	mov    %edx,(%esp)
  800b71:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800b74:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800b78:	e8 83 17 01 00       	call   812300 <__umoddi3>
  800b7d:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b81:	0f be 80 15 27 81 00 	movsbl 0x812715(%eax),%eax
  800b88:	89 04 24             	mov    %eax,(%esp)
  800b8b:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800b8e:	83 c4 4c             	add    $0x4c,%esp
  800b91:	5b                   	pop    %ebx
  800b92:	5e                   	pop    %esi
  800b93:	5f                   	pop    %edi
  800b94:	5d                   	pop    %ebp
  800b95:	c3                   	ret    

00800b96 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800b96:	55                   	push   %ebp
  800b97:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800b99:	83 fa 01             	cmp    $0x1,%edx
  800b9c:	7e 0e                	jle    800bac <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  800b9e:	8b 10                	mov    (%eax),%edx
  800ba0:	8d 4a 08             	lea    0x8(%edx),%ecx
  800ba3:	89 08                	mov    %ecx,(%eax)
  800ba5:	8b 02                	mov    (%edx),%eax
  800ba7:	8b 52 04             	mov    0x4(%edx),%edx
  800baa:	eb 22                	jmp    800bce <getuint+0x38>
	else if (lflag)
  800bac:	85 d2                	test   %edx,%edx
  800bae:	74 10                	je     800bc0 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  800bb0:	8b 10                	mov    (%eax),%edx
  800bb2:	8d 4a 04             	lea    0x4(%edx),%ecx
  800bb5:	89 08                	mov    %ecx,(%eax)
  800bb7:	8b 02                	mov    (%edx),%eax
  800bb9:	ba 00 00 00 00       	mov    $0x0,%edx
  800bbe:	eb 0e                	jmp    800bce <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  800bc0:	8b 10                	mov    (%eax),%edx
  800bc2:	8d 4a 04             	lea    0x4(%edx),%ecx
  800bc5:	89 08                	mov    %ecx,(%eax)
  800bc7:	8b 02                	mov    (%edx),%eax
  800bc9:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800bce:	5d                   	pop    %ebp
  800bcf:	c3                   	ret    

00800bd0 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800bd0:	55                   	push   %ebp
  800bd1:	89 e5                	mov    %esp,%ebp
  800bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  800bd6:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800bda:	8b 10                	mov    (%eax),%edx
  800bdc:	3b 50 04             	cmp    0x4(%eax),%edx
  800bdf:	73 0a                	jae    800beb <sprintputch+0x1b>
		*b->buf++ = ch;
  800be1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800be4:	88 0a                	mov    %cl,(%edx)
  800be6:	83 c2 01             	add    $0x1,%edx
  800be9:	89 10                	mov    %edx,(%eax)
}
  800beb:	5d                   	pop    %ebp
  800bec:	c3                   	ret    

00800bed <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800bed:	55                   	push   %ebp
  800bee:	89 e5                	mov    %esp,%ebp
  800bf0:	57                   	push   %edi
  800bf1:	56                   	push   %esi
  800bf2:	53                   	push   %ebx
  800bf3:	83 ec 5c             	sub    $0x5c,%esp
  800bf6:	8b 7d 08             	mov    0x8(%ebp),%edi
  800bf9:	8b 75 0c             	mov    0xc(%ebp),%esi
  800bfc:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800bff:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  800c06:	eb 11                	jmp    800c19 <vprintfmt+0x2c>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800c08:	85 c0                	test   %eax,%eax
  800c0a:	0f 84 09 04 00 00    	je     801019 <vprintfmt+0x42c>
				return;
			putch(ch, putdat);
  800c10:	89 74 24 04          	mov    %esi,0x4(%esp)
  800c14:	89 04 24             	mov    %eax,(%esp)
  800c17:	ff d7                	call   *%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800c19:	0f b6 03             	movzbl (%ebx),%eax
  800c1c:	83 c3 01             	add    $0x1,%ebx
  800c1f:	83 f8 25             	cmp    $0x25,%eax
  800c22:	75 e4                	jne    800c08 <vprintfmt+0x1b>
  800c24:	c6 45 dc 20          	movb   $0x20,-0x24(%ebp)
  800c28:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  800c2f:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
  800c36:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  800c3d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800c42:	eb 06                	jmp    800c4a <vprintfmt+0x5d>
  800c44:	c6 45 dc 2d          	movb   $0x2d,-0x24(%ebp)
  800c48:	89 c3                	mov    %eax,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800c4a:	0f b6 13             	movzbl (%ebx),%edx
  800c4d:	0f b6 c2             	movzbl %dl,%eax
  800c50:	89 45 e0             	mov    %eax,-0x20(%ebp)
  800c53:	8d 43 01             	lea    0x1(%ebx),%eax
  800c56:	83 ea 23             	sub    $0x23,%edx
  800c59:	80 fa 55             	cmp    $0x55,%dl
  800c5c:	0f 87 9a 03 00 00    	ja     800ffc <vprintfmt+0x40f>
  800c62:	0f b6 d2             	movzbl %dl,%edx
  800c65:	ff 24 95 60 28 81 00 	jmp    *0x812860(,%edx,4)
  800c6c:	c6 45 dc 30          	movb   $0x30,-0x24(%ebp)
  800c70:	eb d6                	jmp    800c48 <vprintfmt+0x5b>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800c72:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800c75:	83 ea 30             	sub    $0x30,%edx
  800c78:	89 55 cc             	mov    %edx,-0x34(%ebp)
				ch = *fmt;
  800c7b:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c7e:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c81:	83 fb 09             	cmp    $0x9,%ebx
  800c84:	77 4c                	ja     800cd2 <vprintfmt+0xe5>
  800c86:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  800c89:	8b 4d cc             	mov    -0x34(%ebp),%ecx
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800c8c:	83 c0 01             	add    $0x1,%eax
				precision = precision * 10 + ch - '0';
  800c8f:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  800c92:	8d 4c 4a d0          	lea    -0x30(%edx,%ecx,2),%ecx
				ch = *fmt;
  800c96:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c99:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c9c:	83 fb 09             	cmp    $0x9,%ebx
  800c9f:	76 eb                	jbe    800c8c <vprintfmt+0x9f>
  800ca1:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  800ca4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800ca7:	eb 29                	jmp    800cd2 <vprintfmt+0xe5>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800ca9:	8b 55 14             	mov    0x14(%ebp),%edx
  800cac:	8d 5a 04             	lea    0x4(%edx),%ebx
  800caf:	89 5d 14             	mov    %ebx,0x14(%ebp)
  800cb2:	8b 12                	mov    (%edx),%edx
  800cb4:	89 55 cc             	mov    %edx,-0x34(%ebp)
			goto process_precision;
  800cb7:	eb 19                	jmp    800cd2 <vprintfmt+0xe5>

		case '.':
			if (width < 0)
  800cb9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800cbc:	c1 fa 1f             	sar    $0x1f,%edx
  800cbf:	f7 d2                	not    %edx
  800cc1:	21 55 e4             	and    %edx,-0x1c(%ebp)
  800cc4:	eb 82                	jmp    800c48 <vprintfmt+0x5b>
  800cc6:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  800ccd:	e9 76 ff ff ff       	jmp    800c48 <vprintfmt+0x5b>

		process_precision:
			if (width < 0)
  800cd2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800cd6:	0f 89 6c ff ff ff    	jns    800c48 <vprintfmt+0x5b>
  800cdc:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800cdf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  800ce2:	8b 55 c8             	mov    -0x38(%ebp),%edx
  800ce5:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800ce8:	e9 5b ff ff ff       	jmp    800c48 <vprintfmt+0x5b>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800ced:	83 c1 01             	add    $0x1,%ecx
			goto reswitch;
  800cf0:	e9 53 ff ff ff       	jmp    800c48 <vprintfmt+0x5b>
  800cf5:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800cf8:	8b 45 14             	mov    0x14(%ebp),%eax
  800cfb:	8d 50 04             	lea    0x4(%eax),%edx
  800cfe:	89 55 14             	mov    %edx,0x14(%ebp)
  800d01:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d05:	8b 00                	mov    (%eax),%eax
  800d07:	89 04 24             	mov    %eax,(%esp)
  800d0a:	ff d7                	call   *%edi
  800d0c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
			break;
  800d0f:	e9 05 ff ff ff       	jmp    800c19 <vprintfmt+0x2c>
  800d14:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  800d17:	8b 45 14             	mov    0x14(%ebp),%eax
  800d1a:	8d 50 04             	lea    0x4(%eax),%edx
  800d1d:	89 55 14             	mov    %edx,0x14(%ebp)
  800d20:	8b 00                	mov    (%eax),%eax
  800d22:	89 c2                	mov    %eax,%edx
  800d24:	c1 fa 1f             	sar    $0x1f,%edx
  800d27:	31 d0                	xor    %edx,%eax
  800d29:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800d2b:	83 f8 0f             	cmp    $0xf,%eax
  800d2e:	7f 0b                	jg     800d3b <vprintfmt+0x14e>
  800d30:	8b 14 85 c0 29 81 00 	mov    0x8129c0(,%eax,4),%edx
  800d37:	85 d2                	test   %edx,%edx
  800d39:	75 20                	jne    800d5b <vprintfmt+0x16e>
				printfmt(putch, putdat, "error %d", err);
  800d3b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800d3f:	c7 44 24 08 26 27 81 	movl   $0x812726,0x8(%esp)
  800d46:	00 
  800d47:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d4b:	89 3c 24             	mov    %edi,(%esp)
  800d4e:	e8 4e 03 00 00       	call   8010a1 <printfmt>
  800d53:	8b 5d e0             	mov    -0x20(%ebp),%ebx
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800d56:	e9 be fe ff ff       	jmp    800c19 <vprintfmt+0x2c>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800d5b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800d5f:	c7 44 24 08 dd 2b 81 	movl   $0x812bdd,0x8(%esp)
  800d66:	00 
  800d67:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d6b:	89 3c 24             	mov    %edi,(%esp)
  800d6e:	e8 2e 03 00 00       	call   8010a1 <printfmt>
  800d73:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  800d76:	e9 9e fe ff ff       	jmp    800c19 <vprintfmt+0x2c>
  800d7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  800d7e:	89 c3                	mov    %eax,%ebx
  800d80:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  800d83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800d86:	89 45 c0             	mov    %eax,-0x40(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800d89:	8b 45 14             	mov    0x14(%ebp),%eax
  800d8c:	8d 50 04             	lea    0x4(%eax),%edx
  800d8f:	89 55 14             	mov    %edx,0x14(%ebp)
  800d92:	8b 00                	mov    (%eax),%eax
  800d94:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  800d97:	85 c0                	test   %eax,%eax
  800d99:	75 07                	jne    800da2 <vprintfmt+0x1b5>
  800d9b:	c7 45 c4 2f 27 81 00 	movl   $0x81272f,-0x3c(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
  800da2:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  800da6:	7e 06                	jle    800dae <vprintfmt+0x1c1>
  800da8:	80 7d dc 2d          	cmpb   $0x2d,-0x24(%ebp)
  800dac:	75 13                	jne    800dc1 <vprintfmt+0x1d4>
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800dae:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  800db1:	0f be 02             	movsbl (%edx),%eax
  800db4:	85 c0                	test   %eax,%eax
  800db6:	0f 85 99 00 00 00    	jne    800e55 <vprintfmt+0x268>
  800dbc:	e9 86 00 00 00       	jmp    800e47 <vprintfmt+0x25a>
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800dc1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800dc5:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  800dc8:	89 0c 24             	mov    %ecx,(%esp)
  800dcb:	e8 1b 03 00 00       	call   8010eb <strnlen>
  800dd0:	8b 55 c0             	mov    -0x40(%ebp),%edx
  800dd3:	29 c2                	sub    %eax,%edx
  800dd5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  800dd8:	85 d2                	test   %edx,%edx
  800dda:	7e d2                	jle    800dae <vprintfmt+0x1c1>
					putch(padc, putdat);
  800ddc:	0f be 4d dc          	movsbl -0x24(%ebp),%ecx
  800de0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800de3:	89 5d c0             	mov    %ebx,-0x40(%ebp)
  800de6:	89 d3                	mov    %edx,%ebx
  800de8:	89 74 24 04          	mov    %esi,0x4(%esp)
  800dec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800def:	89 04 24             	mov    %eax,(%esp)
  800df2:	ff d7                	call   *%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800df4:	83 eb 01             	sub    $0x1,%ebx
  800df7:	85 db                	test   %ebx,%ebx
  800df9:	7f ed                	jg     800de8 <vprintfmt+0x1fb>
  800dfb:	8b 5d c0             	mov    -0x40(%ebp),%ebx
  800dfe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  800e05:	eb a7                	jmp    800dae <vprintfmt+0x1c1>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e07:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  800e0b:	74 18                	je     800e25 <vprintfmt+0x238>
  800e0d:	8d 50 e0             	lea    -0x20(%eax),%edx
  800e10:	83 fa 5e             	cmp    $0x5e,%edx
  800e13:	76 10                	jbe    800e25 <vprintfmt+0x238>
					putch('?', putdat);
  800e15:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e19:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800e20:	ff 55 dc             	call   *-0x24(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e23:	eb 0a                	jmp    800e2f <vprintfmt+0x242>
					putch('?', putdat);
				else
					putch(ch, putdat);
  800e25:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e29:	89 04 24             	mov    %eax,(%esp)
  800e2c:	ff 55 dc             	call   *-0x24(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e2f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
  800e33:	0f be 03             	movsbl (%ebx),%eax
  800e36:	85 c0                	test   %eax,%eax
  800e38:	74 05                	je     800e3f <vprintfmt+0x252>
  800e3a:	83 c3 01             	add    $0x1,%ebx
  800e3d:	eb 29                	jmp    800e68 <vprintfmt+0x27b>
  800e3f:	89 fe                	mov    %edi,%esi
  800e41:	8b 7d dc             	mov    -0x24(%ebp),%edi
  800e44:	8b 5d cc             	mov    -0x34(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800e47:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800e4b:	7f 2e                	jg     800e7b <vprintfmt+0x28e>
  800e4d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  800e50:	e9 c4 fd ff ff       	jmp    800c19 <vprintfmt+0x2c>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e55:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  800e58:	83 c2 01             	add    $0x1,%edx
  800e5b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  800e5e:	89 f7                	mov    %esi,%edi
  800e60:	8b 75 cc             	mov    -0x34(%ebp),%esi
  800e63:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  800e66:	89 d3                	mov    %edx,%ebx
  800e68:	85 f6                	test   %esi,%esi
  800e6a:	78 9b                	js     800e07 <vprintfmt+0x21a>
  800e6c:	83 ee 01             	sub    $0x1,%esi
  800e6f:	79 96                	jns    800e07 <vprintfmt+0x21a>
  800e71:	89 fe                	mov    %edi,%esi
  800e73:	8b 7d dc             	mov    -0x24(%ebp),%edi
  800e76:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  800e79:	eb cc                	jmp    800e47 <vprintfmt+0x25a>
  800e7b:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  800e7e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  800e81:	89 74 24 04          	mov    %esi,0x4(%esp)
  800e85:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800e8c:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800e8e:	83 eb 01             	sub    $0x1,%ebx
  800e91:	85 db                	test   %ebx,%ebx
  800e93:	7f ec                	jg     800e81 <vprintfmt+0x294>
  800e95:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800e98:	e9 7c fd ff ff       	jmp    800c19 <vprintfmt+0x2c>
  800e9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800ea0:	83 f9 01             	cmp    $0x1,%ecx
  800ea3:	7e 16                	jle    800ebb <vprintfmt+0x2ce>
		return va_arg(*ap, long long);
  800ea5:	8b 45 14             	mov    0x14(%ebp),%eax
  800ea8:	8d 50 08             	lea    0x8(%eax),%edx
  800eab:	89 55 14             	mov    %edx,0x14(%ebp)
  800eae:	8b 10                	mov    (%eax),%edx
  800eb0:	8b 48 04             	mov    0x4(%eax),%ecx
  800eb3:	89 55 d0             	mov    %edx,-0x30(%ebp)
  800eb6:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  800eb9:	eb 32                	jmp    800eed <vprintfmt+0x300>
	else if (lflag)
  800ebb:	85 c9                	test   %ecx,%ecx
  800ebd:	74 18                	je     800ed7 <vprintfmt+0x2ea>
		return va_arg(*ap, long);
  800ebf:	8b 45 14             	mov    0x14(%ebp),%eax
  800ec2:	8d 50 04             	lea    0x4(%eax),%edx
  800ec5:	89 55 14             	mov    %edx,0x14(%ebp)
  800ec8:	8b 00                	mov    (%eax),%eax
  800eca:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800ecd:	89 c1                	mov    %eax,%ecx
  800ecf:	c1 f9 1f             	sar    $0x1f,%ecx
  800ed2:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  800ed5:	eb 16                	jmp    800eed <vprintfmt+0x300>
	else
		return va_arg(*ap, int);
  800ed7:	8b 45 14             	mov    0x14(%ebp),%eax
  800eda:	8d 50 04             	lea    0x4(%eax),%edx
  800edd:	89 55 14             	mov    %edx,0x14(%ebp)
  800ee0:	8b 00                	mov    (%eax),%eax
  800ee2:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800ee5:	89 c2                	mov    %eax,%edx
  800ee7:	c1 fa 1f             	sar    $0x1f,%edx
  800eea:	89 55 d4             	mov    %edx,-0x2c(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800eed:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800ef0:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800ef3:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  800ef8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800efc:	0f 89 b8 00 00 00    	jns    800fba <vprintfmt+0x3cd>
				putch('-', putdat);
  800f02:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f06:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800f0d:	ff d7                	call   *%edi
				num = -(long long) num;
  800f0f:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800f12:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800f15:	f7 d9                	neg    %ecx
  800f17:	83 d3 00             	adc    $0x0,%ebx
  800f1a:	f7 db                	neg    %ebx
  800f1c:	b8 0a 00 00 00       	mov    $0xa,%eax
  800f21:	e9 94 00 00 00       	jmp    800fba <vprintfmt+0x3cd>
  800f26:	89 45 e0             	mov    %eax,-0x20(%ebp)
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800f29:	89 ca                	mov    %ecx,%edx
  800f2b:	8d 45 14             	lea    0x14(%ebp),%eax
  800f2e:	e8 63 fc ff ff       	call   800b96 <getuint>
  800f33:	89 c1                	mov    %eax,%ecx
  800f35:	89 d3                	mov    %edx,%ebx
  800f37:	b8 0a 00 00 00       	mov    $0xa,%eax
			base = 10;
			goto number;
  800f3c:	eb 7c                	jmp    800fba <vprintfmt+0x3cd>
  800f3e:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800f41:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f45:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  800f4c:	ff d7                	call   *%edi
			putch('X', putdat);
  800f4e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f52:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  800f59:	ff d7                	call   *%edi
			putch('X', putdat);
  800f5b:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f5f:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  800f66:	ff d7                	call   *%edi
  800f68:	8b 5d e0             	mov    -0x20(%ebp),%ebx
			break;
  800f6b:	e9 a9 fc ff ff       	jmp    800c19 <vprintfmt+0x2c>
  800f70:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
  800f73:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f77:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800f7e:	ff d7                	call   *%edi
			putch('x', putdat);
  800f80:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f84:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800f8b:	ff d7                	call   *%edi
			num = (unsigned long long)
  800f8d:	8b 45 14             	mov    0x14(%ebp),%eax
  800f90:	8d 50 04             	lea    0x4(%eax),%edx
  800f93:	89 55 14             	mov    %edx,0x14(%ebp)
  800f96:	8b 08                	mov    (%eax),%ecx
  800f98:	bb 00 00 00 00       	mov    $0x0,%ebx
  800f9d:	b8 10 00 00 00       	mov    $0x10,%eax
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  800fa2:	eb 16                	jmp    800fba <vprintfmt+0x3cd>
  800fa4:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800fa7:	89 ca                	mov    %ecx,%edx
  800fa9:	8d 45 14             	lea    0x14(%ebp),%eax
  800fac:	e8 e5 fb ff ff       	call   800b96 <getuint>
  800fb1:	89 c1                	mov    %eax,%ecx
  800fb3:	89 d3                	mov    %edx,%ebx
  800fb5:	b8 10 00 00 00       	mov    $0x10,%eax
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  800fba:	0f be 55 dc          	movsbl -0x24(%ebp),%edx
  800fbe:	89 54 24 10          	mov    %edx,0x10(%esp)
  800fc2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800fc5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800fc9:	89 44 24 08          	mov    %eax,0x8(%esp)
  800fcd:	89 0c 24             	mov    %ecx,(%esp)
  800fd0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800fd4:	89 f2                	mov    %esi,%edx
  800fd6:	89 f8                	mov    %edi,%eax
  800fd8:	e8 c3 fa ff ff       	call   800aa0 <printnum>
  800fdd:	8b 5d e0             	mov    -0x20(%ebp),%ebx
			break;
  800fe0:	e9 34 fc ff ff       	jmp    800c19 <vprintfmt+0x2c>
  800fe5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800fe8:	89 45 e0             	mov    %eax,-0x20(%ebp)

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800feb:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fef:	89 14 24             	mov    %edx,(%esp)
  800ff2:	ff d7                	call   *%edi
  800ff4:	8b 5d e0             	mov    -0x20(%ebp),%ebx
			break;
  800ff7:	e9 1d fc ff ff       	jmp    800c19 <vprintfmt+0x2c>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800ffc:	89 74 24 04          	mov    %esi,0x4(%esp)
  801000:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  801007:	ff d7                	call   *%edi
			for (fmt--; fmt[-1] != '%'; fmt--)
  801009:	8d 43 ff             	lea    -0x1(%ebx),%eax
  80100c:	80 38 25             	cmpb   $0x25,(%eax)
  80100f:	0f 84 04 fc ff ff    	je     800c19 <vprintfmt+0x2c>
  801015:	89 c3                	mov    %eax,%ebx
  801017:	eb f0                	jmp    801009 <vprintfmt+0x41c>
				/* do nothing */;
			break;
		}
	}
}
  801019:	83 c4 5c             	add    $0x5c,%esp
  80101c:	5b                   	pop    %ebx
  80101d:	5e                   	pop    %esi
  80101e:	5f                   	pop    %edi
  80101f:	5d                   	pop    %ebp
  801020:	c3                   	ret    

00801021 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801021:	55                   	push   %ebp
  801022:	89 e5                	mov    %esp,%ebp
  801024:	83 ec 28             	sub    $0x28,%esp
  801027:	8b 45 08             	mov    0x8(%ebp),%eax
  80102a:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  80102d:	85 c0                	test   %eax,%eax
  80102f:	74 04                	je     801035 <vsnprintf+0x14>
  801031:	85 d2                	test   %edx,%edx
  801033:	7f 07                	jg     80103c <vsnprintf+0x1b>
  801035:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80103a:	eb 3b                	jmp    801077 <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  80103c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80103f:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  801043:	89 45 f0             	mov    %eax,-0x10(%ebp)
  801046:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80104d:	8b 45 14             	mov    0x14(%ebp),%eax
  801050:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801054:	8b 45 10             	mov    0x10(%ebp),%eax
  801057:	89 44 24 08          	mov    %eax,0x8(%esp)
  80105b:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80105e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801062:	c7 04 24 d0 0b 80 00 	movl   $0x800bd0,(%esp)
  801069:	e8 7f fb ff ff       	call   800bed <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80106e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  801071:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  801074:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  801077:	c9                   	leave  
  801078:	c3                   	ret    

00801079 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801079:	55                   	push   %ebp
  80107a:	89 e5                	mov    %esp,%ebp
  80107c:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  80107f:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  801082:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801086:	8b 45 10             	mov    0x10(%ebp),%eax
  801089:	89 44 24 08          	mov    %eax,0x8(%esp)
  80108d:	8b 45 0c             	mov    0xc(%ebp),%eax
  801090:	89 44 24 04          	mov    %eax,0x4(%esp)
  801094:	8b 45 08             	mov    0x8(%ebp),%eax
  801097:	89 04 24             	mov    %eax,(%esp)
  80109a:	e8 82 ff ff ff       	call   801021 <vsnprintf>
	va_end(ap);

	return rc;
}
  80109f:	c9                   	leave  
  8010a0:	c3                   	ret    

008010a1 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  8010a1:	55                   	push   %ebp
  8010a2:	89 e5                	mov    %esp,%ebp
  8010a4:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  8010a7:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  8010aa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8010ae:	8b 45 10             	mov    0x10(%ebp),%eax
  8010b1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8010b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010bc:	8b 45 08             	mov    0x8(%ebp),%eax
  8010bf:	89 04 24             	mov    %eax,(%esp)
  8010c2:	e8 26 fb ff ff       	call   800bed <vprintfmt>
	va_end(ap);
}
  8010c7:	c9                   	leave  
  8010c8:	c3                   	ret    
  8010c9:	00 00                	add    %al,(%eax)
  8010cb:	00 00                	add    %al,(%eax)
  8010cd:	00 00                	add    %al,(%eax)
	...

008010d0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8010d0:	55                   	push   %ebp
  8010d1:	89 e5                	mov    %esp,%ebp
  8010d3:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  8010d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8010db:	80 3a 00             	cmpb   $0x0,(%edx)
  8010de:	74 09                	je     8010e9 <strlen+0x19>
		n++;
  8010e0:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8010e3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  8010e7:	75 f7                	jne    8010e0 <strlen+0x10>
		n++;
	return n;
}
  8010e9:	5d                   	pop    %ebp
  8010ea:	c3                   	ret    

008010eb <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8010eb:	55                   	push   %ebp
  8010ec:	89 e5                	mov    %esp,%ebp
  8010ee:	53                   	push   %ebx
  8010ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8010f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010f5:	85 c9                	test   %ecx,%ecx
  8010f7:	74 19                	je     801112 <strnlen+0x27>
  8010f9:	80 3b 00             	cmpb   $0x0,(%ebx)
  8010fc:	74 14                	je     801112 <strnlen+0x27>
  8010fe:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  801103:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801106:	39 c8                	cmp    %ecx,%eax
  801108:	74 0d                	je     801117 <strnlen+0x2c>
  80110a:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  80110e:	75 f3                	jne    801103 <strnlen+0x18>
  801110:	eb 05                	jmp    801117 <strnlen+0x2c>
  801112:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  801117:	5b                   	pop    %ebx
  801118:	5d                   	pop    %ebp
  801119:	c3                   	ret    

0080111a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80111a:	55                   	push   %ebp
  80111b:	89 e5                	mov    %esp,%ebp
  80111d:	53                   	push   %ebx
  80111e:	8b 45 08             	mov    0x8(%ebp),%eax
  801121:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801124:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  801129:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80112d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  801130:	83 c2 01             	add    $0x1,%edx
  801133:	84 c9                	test   %cl,%cl
  801135:	75 f2                	jne    801129 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  801137:	5b                   	pop    %ebx
  801138:	5d                   	pop    %ebp
  801139:	c3                   	ret    

0080113a <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80113a:	55                   	push   %ebp
  80113b:	89 e5                	mov    %esp,%ebp
  80113d:	56                   	push   %esi
  80113e:	53                   	push   %ebx
  80113f:	8b 45 08             	mov    0x8(%ebp),%eax
  801142:	8b 55 0c             	mov    0xc(%ebp),%edx
  801145:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801148:	85 f6                	test   %esi,%esi
  80114a:	74 18                	je     801164 <strncpy+0x2a>
  80114c:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  801151:	0f b6 1a             	movzbl (%edx),%ebx
  801154:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801157:	80 3a 01             	cmpb   $0x1,(%edx)
  80115a:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80115d:	83 c1 01             	add    $0x1,%ecx
  801160:	39 ce                	cmp    %ecx,%esi
  801162:	77 ed                	ja     801151 <strncpy+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801164:	5b                   	pop    %ebx
  801165:	5e                   	pop    %esi
  801166:	5d                   	pop    %ebp
  801167:	c3                   	ret    

00801168 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801168:	55                   	push   %ebp
  801169:	89 e5                	mov    %esp,%ebp
  80116b:	56                   	push   %esi
  80116c:	53                   	push   %ebx
  80116d:	8b 75 08             	mov    0x8(%ebp),%esi
  801170:	8b 55 0c             	mov    0xc(%ebp),%edx
  801173:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  801176:	89 f0                	mov    %esi,%eax
  801178:	85 c9                	test   %ecx,%ecx
  80117a:	74 27                	je     8011a3 <strlcpy+0x3b>
		while (--size > 0 && *src != '\0')
  80117c:	83 e9 01             	sub    $0x1,%ecx
  80117f:	74 1d                	je     80119e <strlcpy+0x36>
  801181:	0f b6 1a             	movzbl (%edx),%ebx
  801184:	84 db                	test   %bl,%bl
  801186:	74 16                	je     80119e <strlcpy+0x36>
			*dst++ = *src++;
  801188:	88 18                	mov    %bl,(%eax)
  80118a:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80118d:	83 e9 01             	sub    $0x1,%ecx
  801190:	74 0e                	je     8011a0 <strlcpy+0x38>
			*dst++ = *src++;
  801192:	83 c2 01             	add    $0x1,%edx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801195:	0f b6 1a             	movzbl (%edx),%ebx
  801198:	84 db                	test   %bl,%bl
  80119a:	75 ec                	jne    801188 <strlcpy+0x20>
  80119c:	eb 02                	jmp    8011a0 <strlcpy+0x38>
  80119e:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  8011a0:	c6 00 00             	movb   $0x0,(%eax)
  8011a3:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  8011a5:	5b                   	pop    %ebx
  8011a6:	5e                   	pop    %esi
  8011a7:	5d                   	pop    %ebp
  8011a8:	c3                   	ret    

008011a9 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8011a9:	55                   	push   %ebp
  8011aa:	89 e5                	mov    %esp,%ebp
  8011ac:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011af:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  8011b2:	0f b6 01             	movzbl (%ecx),%eax
  8011b5:	84 c0                	test   %al,%al
  8011b7:	74 15                	je     8011ce <strcmp+0x25>
  8011b9:	3a 02                	cmp    (%edx),%al
  8011bb:	75 11                	jne    8011ce <strcmp+0x25>
		p++, q++;
  8011bd:	83 c1 01             	add    $0x1,%ecx
  8011c0:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8011c3:	0f b6 01             	movzbl (%ecx),%eax
  8011c6:	84 c0                	test   %al,%al
  8011c8:	74 04                	je     8011ce <strcmp+0x25>
  8011ca:	3a 02                	cmp    (%edx),%al
  8011cc:	74 ef                	je     8011bd <strcmp+0x14>
  8011ce:	0f b6 c0             	movzbl %al,%eax
  8011d1:	0f b6 12             	movzbl (%edx),%edx
  8011d4:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8011d6:	5d                   	pop    %ebp
  8011d7:	c3                   	ret    

008011d8 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8011d8:	55                   	push   %ebp
  8011d9:	89 e5                	mov    %esp,%ebp
  8011db:	53                   	push   %ebx
  8011dc:	8b 55 08             	mov    0x8(%ebp),%edx
  8011df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8011e2:	8b 45 10             	mov    0x10(%ebp),%eax
	while (n > 0 && *p && *p == *q)
  8011e5:	85 c0                	test   %eax,%eax
  8011e7:	74 23                	je     80120c <strncmp+0x34>
  8011e9:	0f b6 1a             	movzbl (%edx),%ebx
  8011ec:	84 db                	test   %bl,%bl
  8011ee:	74 24                	je     801214 <strncmp+0x3c>
  8011f0:	3a 19                	cmp    (%ecx),%bl
  8011f2:	75 20                	jne    801214 <strncmp+0x3c>
  8011f4:	83 e8 01             	sub    $0x1,%eax
  8011f7:	74 13                	je     80120c <strncmp+0x34>
		n--, p++, q++;
  8011f9:	83 c2 01             	add    $0x1,%edx
  8011fc:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8011ff:	0f b6 1a             	movzbl (%edx),%ebx
  801202:	84 db                	test   %bl,%bl
  801204:	74 0e                	je     801214 <strncmp+0x3c>
  801206:	3a 19                	cmp    (%ecx),%bl
  801208:	74 ea                	je     8011f4 <strncmp+0x1c>
  80120a:	eb 08                	jmp    801214 <strncmp+0x3c>
  80120c:	b8 00 00 00 00       	mov    $0x0,%eax
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  801211:	5b                   	pop    %ebx
  801212:	5d                   	pop    %ebp
  801213:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801214:	0f b6 02             	movzbl (%edx),%eax
  801217:	0f b6 11             	movzbl (%ecx),%edx
  80121a:	29 d0                	sub    %edx,%eax
  80121c:	eb f3                	jmp    801211 <strncmp+0x39>

0080121e <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80121e:	55                   	push   %ebp
  80121f:	89 e5                	mov    %esp,%ebp
  801221:	8b 45 08             	mov    0x8(%ebp),%eax
  801224:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801228:	0f b6 10             	movzbl (%eax),%edx
  80122b:	84 d2                	test   %dl,%dl
  80122d:	74 15                	je     801244 <strchr+0x26>
		if (*s == c)
  80122f:	38 ca                	cmp    %cl,%dl
  801231:	75 07                	jne    80123a <strchr+0x1c>
  801233:	eb 14                	jmp    801249 <strchr+0x2b>
  801235:	38 ca                	cmp    %cl,%dl
  801237:	90                   	nop
  801238:	74 0f                	je     801249 <strchr+0x2b>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80123a:	83 c0 01             	add    $0x1,%eax
  80123d:	0f b6 10             	movzbl (%eax),%edx
  801240:	84 d2                	test   %dl,%dl
  801242:	75 f1                	jne    801235 <strchr+0x17>
  801244:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801249:	5d                   	pop    %ebp
  80124a:	c3                   	ret    

0080124b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80124b:	55                   	push   %ebp
  80124c:	89 e5                	mov    %esp,%ebp
  80124e:	8b 45 08             	mov    0x8(%ebp),%eax
  801251:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801255:	0f b6 10             	movzbl (%eax),%edx
  801258:	84 d2                	test   %dl,%dl
  80125a:	74 18                	je     801274 <strfind+0x29>
		if (*s == c)
  80125c:	38 ca                	cmp    %cl,%dl
  80125e:	75 0a                	jne    80126a <strfind+0x1f>
  801260:	eb 12                	jmp    801274 <strfind+0x29>
  801262:	38 ca                	cmp    %cl,%dl
  801264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801268:	74 0a                	je     801274 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80126a:	83 c0 01             	add    $0x1,%eax
  80126d:	0f b6 10             	movzbl (%eax),%edx
  801270:	84 d2                	test   %dl,%dl
  801272:	75 ee                	jne    801262 <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  801274:	5d                   	pop    %ebp
  801275:	c3                   	ret    

00801276 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801276:	55                   	push   %ebp
  801277:	89 e5                	mov    %esp,%ebp
  801279:	83 ec 0c             	sub    $0xc,%esp
  80127c:	89 1c 24             	mov    %ebx,(%esp)
  80127f:	89 74 24 04          	mov    %esi,0x4(%esp)
  801283:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801287:	8b 7d 08             	mov    0x8(%ebp),%edi
  80128a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80128d:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  801290:	85 c9                	test   %ecx,%ecx
  801292:	74 30                	je     8012c4 <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  801294:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80129a:	75 25                	jne    8012c1 <memset+0x4b>
  80129c:	f6 c1 03             	test   $0x3,%cl
  80129f:	75 20                	jne    8012c1 <memset+0x4b>
		c &= 0xFF;
  8012a1:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8012a4:	89 d3                	mov    %edx,%ebx
  8012a6:	c1 e3 08             	shl    $0x8,%ebx
  8012a9:	89 d6                	mov    %edx,%esi
  8012ab:	c1 e6 18             	shl    $0x18,%esi
  8012ae:	89 d0                	mov    %edx,%eax
  8012b0:	c1 e0 10             	shl    $0x10,%eax
  8012b3:	09 f0                	or     %esi,%eax
  8012b5:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  8012b7:	09 d8                	or     %ebx,%eax
  8012b9:	c1 e9 02             	shr    $0x2,%ecx
  8012bc:	fc                   	cld    
  8012bd:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012bf:	eb 03                	jmp    8012c4 <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8012c1:	fc                   	cld    
  8012c2:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  8012c4:	89 f8                	mov    %edi,%eax
  8012c6:	8b 1c 24             	mov    (%esp),%ebx
  8012c9:	8b 74 24 04          	mov    0x4(%esp),%esi
  8012cd:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8012d1:	89 ec                	mov    %ebp,%esp
  8012d3:	5d                   	pop    %ebp
  8012d4:	c3                   	ret    

008012d5 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8012d5:	55                   	push   %ebp
  8012d6:	89 e5                	mov    %esp,%ebp
  8012d8:	83 ec 08             	sub    $0x8,%esp
  8012db:	89 34 24             	mov    %esi,(%esp)
  8012de:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8012e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8012e5:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  8012e8:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  8012eb:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  8012ed:	39 c6                	cmp    %eax,%esi
  8012ef:	73 35                	jae    801326 <memmove+0x51>
  8012f1:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  8012f4:	39 d0                	cmp    %edx,%eax
  8012f6:	73 2e                	jae    801326 <memmove+0x51>
		s += n;
		d += n;
  8012f8:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  8012fa:	f6 c2 03             	test   $0x3,%dl
  8012fd:	75 1b                	jne    80131a <memmove+0x45>
  8012ff:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801305:	75 13                	jne    80131a <memmove+0x45>
  801307:	f6 c1 03             	test   $0x3,%cl
  80130a:	75 0e                	jne    80131a <memmove+0x45>
			asm volatile("std; rep movsl\n"
  80130c:	83 ef 04             	sub    $0x4,%edi
  80130f:	8d 72 fc             	lea    -0x4(%edx),%esi
  801312:	c1 e9 02             	shr    $0x2,%ecx
  801315:	fd                   	std    
  801316:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801318:	eb 09                	jmp    801323 <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80131a:	83 ef 01             	sub    $0x1,%edi
  80131d:	8d 72 ff             	lea    -0x1(%edx),%esi
  801320:	fd                   	std    
  801321:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801323:	fc                   	cld    
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
  801324:	eb 20                	jmp    801346 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801326:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80132c:	75 15                	jne    801343 <memmove+0x6e>
  80132e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801334:	75 0d                	jne    801343 <memmove+0x6e>
  801336:	f6 c1 03             	test   $0x3,%cl
  801339:	75 08                	jne    801343 <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80133b:	c1 e9 02             	shr    $0x2,%ecx
  80133e:	fc                   	cld    
  80133f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801341:	eb 03                	jmp    801346 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  801343:	fc                   	cld    
  801344:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  801346:	8b 34 24             	mov    (%esp),%esi
  801349:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80134d:	89 ec                	mov    %ebp,%esp
  80134f:	5d                   	pop    %ebp
  801350:	c3                   	ret    

00801351 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801351:	55                   	push   %ebp
  801352:	89 e5                	mov    %esp,%ebp
  801354:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  801357:	8b 45 10             	mov    0x10(%ebp),%eax
  80135a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80135e:	8b 45 0c             	mov    0xc(%ebp),%eax
  801361:	89 44 24 04          	mov    %eax,0x4(%esp)
  801365:	8b 45 08             	mov    0x8(%ebp),%eax
  801368:	89 04 24             	mov    %eax,(%esp)
  80136b:	e8 65 ff ff ff       	call   8012d5 <memmove>
}
  801370:	c9                   	leave  
  801371:	c3                   	ret    

00801372 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  801372:	55                   	push   %ebp
  801373:	89 e5                	mov    %esp,%ebp
  801375:	57                   	push   %edi
  801376:	56                   	push   %esi
  801377:	53                   	push   %ebx
  801378:	8b 75 08             	mov    0x8(%ebp),%esi
  80137b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80137e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  801381:	85 c9                	test   %ecx,%ecx
  801383:	74 36                	je     8013bb <memcmp+0x49>
		if (*s1 != *s2)
  801385:	0f b6 06             	movzbl (%esi),%eax
  801388:	0f b6 1f             	movzbl (%edi),%ebx
  80138b:	38 d8                	cmp    %bl,%al
  80138d:	74 20                	je     8013af <memcmp+0x3d>
  80138f:	eb 14                	jmp    8013a5 <memcmp+0x33>
  801391:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  801396:	0f b6 5c 17 01       	movzbl 0x1(%edi,%edx,1),%ebx
  80139b:	83 c2 01             	add    $0x1,%edx
  80139e:	83 e9 01             	sub    $0x1,%ecx
  8013a1:	38 d8                	cmp    %bl,%al
  8013a3:	74 12                	je     8013b7 <memcmp+0x45>
			return (int) *s1 - (int) *s2;
  8013a5:	0f b6 c0             	movzbl %al,%eax
  8013a8:	0f b6 db             	movzbl %bl,%ebx
  8013ab:	29 d8                	sub    %ebx,%eax
  8013ad:	eb 11                	jmp    8013c0 <memcmp+0x4e>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013af:	83 e9 01             	sub    $0x1,%ecx
  8013b2:	ba 00 00 00 00       	mov    $0x0,%edx
  8013b7:	85 c9                	test   %ecx,%ecx
  8013b9:	75 d6                	jne    801391 <memcmp+0x1f>
  8013bb:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  8013c0:	5b                   	pop    %ebx
  8013c1:	5e                   	pop    %esi
  8013c2:	5f                   	pop    %edi
  8013c3:	5d                   	pop    %ebp
  8013c4:	c3                   	ret    

008013c5 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8013c5:	55                   	push   %ebp
  8013c6:	89 e5                	mov    %esp,%ebp
  8013c8:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  8013cb:	89 c2                	mov    %eax,%edx
  8013cd:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  8013d0:	39 d0                	cmp    %edx,%eax
  8013d2:	73 15                	jae    8013e9 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  8013d4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  8013d8:	38 08                	cmp    %cl,(%eax)
  8013da:	75 06                	jne    8013e2 <memfind+0x1d>
  8013dc:	eb 0b                	jmp    8013e9 <memfind+0x24>
  8013de:	38 08                	cmp    %cl,(%eax)
  8013e0:	74 07                	je     8013e9 <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8013e2:	83 c0 01             	add    $0x1,%eax
  8013e5:	39 c2                	cmp    %eax,%edx
  8013e7:	77 f5                	ja     8013de <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  8013e9:	5d                   	pop    %ebp
  8013ea:	c3                   	ret    

008013eb <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8013eb:	55                   	push   %ebp
  8013ec:	89 e5                	mov    %esp,%ebp
  8013ee:	57                   	push   %edi
  8013ef:	56                   	push   %esi
  8013f0:	53                   	push   %ebx
  8013f1:	83 ec 04             	sub    $0x4,%esp
  8013f4:	8b 55 08             	mov    0x8(%ebp),%edx
  8013f7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8013fa:	0f b6 02             	movzbl (%edx),%eax
  8013fd:	3c 20                	cmp    $0x20,%al
  8013ff:	74 04                	je     801405 <strtol+0x1a>
  801401:	3c 09                	cmp    $0x9,%al
  801403:	75 0e                	jne    801413 <strtol+0x28>
		s++;
  801405:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  801408:	0f b6 02             	movzbl (%edx),%eax
  80140b:	3c 20                	cmp    $0x20,%al
  80140d:	74 f6                	je     801405 <strtol+0x1a>
  80140f:	3c 09                	cmp    $0x9,%al
  801411:	74 f2                	je     801405 <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  801413:	3c 2b                	cmp    $0x2b,%al
  801415:	75 0c                	jne    801423 <strtol+0x38>
		s++;
  801417:	83 c2 01             	add    $0x1,%edx
  80141a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801421:	eb 15                	jmp    801438 <strtol+0x4d>
	else if (*s == '-')
  801423:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80142a:	3c 2d                	cmp    $0x2d,%al
  80142c:	75 0a                	jne    801438 <strtol+0x4d>
		s++, neg = 1;
  80142e:	83 c2 01             	add    $0x1,%edx
  801431:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  801438:	85 db                	test   %ebx,%ebx
  80143a:	0f 94 c0             	sete   %al
  80143d:	74 05                	je     801444 <strtol+0x59>
  80143f:	83 fb 10             	cmp    $0x10,%ebx
  801442:	75 18                	jne    80145c <strtol+0x71>
  801444:	80 3a 30             	cmpb   $0x30,(%edx)
  801447:	75 13                	jne    80145c <strtol+0x71>
  801449:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80144d:	8d 76 00             	lea    0x0(%esi),%esi
  801450:	75 0a                	jne    80145c <strtol+0x71>
		s += 2, base = 16;
  801452:	83 c2 02             	add    $0x2,%edx
  801455:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80145a:	eb 15                	jmp    801471 <strtol+0x86>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80145c:	84 c0                	test   %al,%al
  80145e:	66 90                	xchg   %ax,%ax
  801460:	74 0f                	je     801471 <strtol+0x86>
  801462:	bb 0a 00 00 00       	mov    $0xa,%ebx
  801467:	80 3a 30             	cmpb   $0x30,(%edx)
  80146a:	75 05                	jne    801471 <strtol+0x86>
		s++, base = 8;
  80146c:	83 c2 01             	add    $0x1,%edx
  80146f:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  801471:	b8 00 00 00 00       	mov    $0x0,%eax
  801476:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  801478:	0f b6 0a             	movzbl (%edx),%ecx
  80147b:	89 cf                	mov    %ecx,%edi
  80147d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  801480:	80 fb 09             	cmp    $0x9,%bl
  801483:	77 08                	ja     80148d <strtol+0xa2>
			dig = *s - '0';
  801485:	0f be c9             	movsbl %cl,%ecx
  801488:	83 e9 30             	sub    $0x30,%ecx
  80148b:	eb 1e                	jmp    8014ab <strtol+0xc0>
		else if (*s >= 'a' && *s <= 'z')
  80148d:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  801490:	80 fb 19             	cmp    $0x19,%bl
  801493:	77 08                	ja     80149d <strtol+0xb2>
			dig = *s - 'a' + 10;
  801495:	0f be c9             	movsbl %cl,%ecx
  801498:	83 e9 57             	sub    $0x57,%ecx
  80149b:	eb 0e                	jmp    8014ab <strtol+0xc0>
		else if (*s >= 'A' && *s <= 'Z')
  80149d:	8d 5f bf             	lea    -0x41(%edi),%ebx
  8014a0:	80 fb 19             	cmp    $0x19,%bl
  8014a3:	77 15                	ja     8014ba <strtol+0xcf>
			dig = *s - 'A' + 10;
  8014a5:	0f be c9             	movsbl %cl,%ecx
  8014a8:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  8014ab:	39 f1                	cmp    %esi,%ecx
  8014ad:	7d 0b                	jge    8014ba <strtol+0xcf>
			break;
		s++, val = (val * base) + dig;
  8014af:	83 c2 01             	add    $0x1,%edx
  8014b2:	0f af c6             	imul   %esi,%eax
  8014b5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  8014b8:	eb be                	jmp    801478 <strtol+0x8d>
  8014ba:	89 c1                	mov    %eax,%ecx

	if (endptr)
  8014bc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8014c0:	74 05                	je     8014c7 <strtol+0xdc>
		*endptr = (char *) s;
  8014c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8014c5:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  8014c7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  8014cb:	74 04                	je     8014d1 <strtol+0xe6>
  8014cd:	89 c8                	mov    %ecx,%eax
  8014cf:	f7 d8                	neg    %eax
}
  8014d1:	83 c4 04             	add    $0x4,%esp
  8014d4:	5b                   	pop    %ebx
  8014d5:	5e                   	pop    %esi
  8014d6:	5f                   	pop    %edi
  8014d7:	5d                   	pop    %ebp
  8014d8:	c3                   	ret    
  8014d9:	00 00                	add    %al,(%eax)
	...

008014dc <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  8014dc:	55                   	push   %ebp
  8014dd:	89 e5                	mov    %esp,%ebp
  8014df:	83 ec 0c             	sub    $0xc,%esp
  8014e2:	89 1c 24             	mov    %ebx,(%esp)
  8014e5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8014e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8014ed:	ba 00 00 00 00       	mov    $0x0,%edx
  8014f2:	b8 01 00 00 00       	mov    $0x1,%eax
  8014f7:	89 d1                	mov    %edx,%ecx
  8014f9:	89 d3                	mov    %edx,%ebx
  8014fb:	89 d7                	mov    %edx,%edi
  8014fd:	89 d6                	mov    %edx,%esi
  8014ff:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  801501:	8b 1c 24             	mov    (%esp),%ebx
  801504:	8b 74 24 04          	mov    0x4(%esp),%esi
  801508:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80150c:	89 ec                	mov    %ebp,%esp
  80150e:	5d                   	pop    %ebp
  80150f:	c3                   	ret    

00801510 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  801510:	55                   	push   %ebp
  801511:	89 e5                	mov    %esp,%ebp
  801513:	83 ec 0c             	sub    $0xc,%esp
  801516:	89 1c 24             	mov    %ebx,(%esp)
  801519:	89 74 24 04          	mov    %esi,0x4(%esp)
  80151d:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801521:	b8 00 00 00 00       	mov    $0x0,%eax
  801526:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801529:	8b 55 08             	mov    0x8(%ebp),%edx
  80152c:	89 c3                	mov    %eax,%ebx
  80152e:	89 c7                	mov    %eax,%edi
  801530:	89 c6                	mov    %eax,%esi
  801532:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  801534:	8b 1c 24             	mov    (%esp),%ebx
  801537:	8b 74 24 04          	mov    0x4(%esp),%esi
  80153b:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80153f:	89 ec                	mov    %ebp,%esp
  801541:	5d                   	pop    %ebp
  801542:	c3                   	ret    

00801543 <sys_call_receive_packet>:
{
   return syscall(SYS_call_packet_send,1,(uint32_t)va,(uint32_t)len,0,0,0);
}

int sys_call_receive_packet(void *va, void *len)
{
  801543:	55                   	push   %ebp
  801544:	89 e5                	mov    %esp,%ebp
  801546:	83 ec 0c             	sub    $0xc,%esp
  801549:	89 1c 24             	mov    %ebx,(%esp)
  80154c:	89 74 24 04          	mov    %esi,0x4(%esp)
  801550:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801554:	bb 00 00 00 00       	mov    $0x0,%ebx
  801559:	b8 10 00 00 00       	mov    $0x10,%eax
  80155e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801561:	8b 55 08             	mov    0x8(%ebp),%edx
  801564:	89 df                	mov    %ebx,%edi
  801566:	89 de                	mov    %ebx,%esi
  801568:	cd 30                	int    $0x30
}

int sys_call_receive_packet(void *va, void *len)
{
   return syscall(SYS_call_receive_packet,0,(uint32_t)va,(uint32_t)len,0,0,0);
}
  80156a:	8b 1c 24             	mov    (%esp),%ebx
  80156d:	8b 74 24 04          	mov    0x4(%esp),%esi
  801571:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801575:	89 ec                	mov    %ebp,%esp
  801577:	5d                   	pop    %ebp
  801578:	c3                   	ret    

00801579 <sys_call_packet_send>:
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}

int sys_call_packet_send(void *va, size_t len)
{
  801579:	55                   	push   %ebp
  80157a:	89 e5                	mov    %esp,%ebp
  80157c:	83 ec 38             	sub    $0x38,%esp
  80157f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801582:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801585:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801588:	bb 00 00 00 00       	mov    $0x0,%ebx
  80158d:	b8 0f 00 00 00       	mov    $0xf,%eax
  801592:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801595:	8b 55 08             	mov    0x8(%ebp),%edx
  801598:	89 df                	mov    %ebx,%edi
  80159a:	89 de                	mov    %ebx,%esi
  80159c:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  80159e:	85 c0                	test   %eax,%eax
  8015a0:	7e 28                	jle    8015ca <sys_call_packet_send+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8015a2:	89 44 24 10          	mov    %eax,0x10(%esp)
  8015a6:	c7 44 24 0c 0f 00 00 	movl   $0xf,0xc(%esp)
  8015ad:	00 
  8015ae:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  8015b5:	00 
  8015b6:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8015bd:	00 
  8015be:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  8015c5:	e8 b2 f3 ff ff       	call   80097c <_panic>
}

int sys_call_packet_send(void *va, size_t len)
{
   return syscall(SYS_call_packet_send,1,(uint32_t)va,(uint32_t)len,0,0,0);
}
  8015ca:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8015cd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8015d0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8015d3:	89 ec                	mov    %ebp,%esp
  8015d5:	5d                   	pop    %ebp
  8015d6:	c3                   	ret    

008015d7 <sys_time_msec>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  8015d7:	55                   	push   %ebp
  8015d8:	89 e5                	mov    %esp,%ebp
  8015da:	83 ec 0c             	sub    $0xc,%esp
  8015dd:	89 1c 24             	mov    %ebx,(%esp)
  8015e0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8015e4:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8015e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8015ed:	b8 0e 00 00 00       	mov    $0xe,%eax
  8015f2:	89 d1                	mov    %edx,%ecx
  8015f4:	89 d3                	mov    %edx,%ebx
  8015f6:	89 d7                	mov    %edx,%edi
  8015f8:	89 d6                	mov    %edx,%esi
  8015fa:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  8015fc:	8b 1c 24             	mov    (%esp),%ebx
  8015ff:	8b 74 24 04          	mov    0x4(%esp),%esi
  801603:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801607:	89 ec                	mov    %ebp,%esp
  801609:	5d                   	pop    %ebp
  80160a:	c3                   	ret    

0080160b <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  80160b:	55                   	push   %ebp
  80160c:	89 e5                	mov    %esp,%ebp
  80160e:	83 ec 38             	sub    $0x38,%esp
  801611:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801614:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801617:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80161a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80161f:	b8 0d 00 00 00       	mov    $0xd,%eax
  801624:	8b 55 08             	mov    0x8(%ebp),%edx
  801627:	89 cb                	mov    %ecx,%ebx
  801629:	89 cf                	mov    %ecx,%edi
  80162b:	89 ce                	mov    %ecx,%esi
  80162d:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  80162f:	85 c0                	test   %eax,%eax
  801631:	7e 28                	jle    80165b <sys_ipc_recv+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801633:	89 44 24 10          	mov    %eax,0x10(%esp)
  801637:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80163e:	00 
  80163f:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  801646:	00 
  801647:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80164e:	00 
  80164f:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  801656:	e8 21 f3 ff ff       	call   80097c <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80165b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80165e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801661:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801664:	89 ec                	mov    %ebp,%esp
  801666:	5d                   	pop    %ebp
  801667:	c3                   	ret    

00801668 <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  801668:	55                   	push   %ebp
  801669:	89 e5                	mov    %esp,%ebp
  80166b:	83 ec 0c             	sub    $0xc,%esp
  80166e:	89 1c 24             	mov    %ebx,(%esp)
  801671:	89 74 24 04          	mov    %esi,0x4(%esp)
  801675:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801679:	be 00 00 00 00       	mov    $0x0,%esi
  80167e:	b8 0c 00 00 00       	mov    $0xc,%eax
  801683:	8b 7d 14             	mov    0x14(%ebp),%edi
  801686:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801689:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80168c:	8b 55 08             	mov    0x8(%ebp),%edx
  80168f:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  801691:	8b 1c 24             	mov    (%esp),%ebx
  801694:	8b 74 24 04          	mov    0x4(%esp),%esi
  801698:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80169c:	89 ec                	mov    %ebp,%esp
  80169e:	5d                   	pop    %ebp
  80169f:	c3                   	ret    

008016a0 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  8016a0:	55                   	push   %ebp
  8016a1:	89 e5                	mov    %esp,%ebp
  8016a3:	83 ec 38             	sub    $0x38,%esp
  8016a6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8016a9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8016ac:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8016af:	bb 00 00 00 00       	mov    $0x0,%ebx
  8016b4:	b8 0a 00 00 00       	mov    $0xa,%eax
  8016b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8016bc:	8b 55 08             	mov    0x8(%ebp),%edx
  8016bf:	89 df                	mov    %ebx,%edi
  8016c1:	89 de                	mov    %ebx,%esi
  8016c3:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8016c5:	85 c0                	test   %eax,%eax
  8016c7:	7e 28                	jle    8016f1 <sys_env_set_pgfault_upcall+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8016c9:	89 44 24 10          	mov    %eax,0x10(%esp)
  8016cd:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  8016d4:	00 
  8016d5:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  8016dc:	00 
  8016dd:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8016e4:	00 
  8016e5:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  8016ec:	e8 8b f2 ff ff       	call   80097c <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  8016f1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8016f4:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8016f7:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8016fa:	89 ec                	mov    %ebp,%esp
  8016fc:	5d                   	pop    %ebp
  8016fd:	c3                   	ret    

008016fe <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8016fe:	55                   	push   %ebp
  8016ff:	89 e5                	mov    %esp,%ebp
  801701:	83 ec 38             	sub    $0x38,%esp
  801704:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801707:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80170a:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80170d:	bb 00 00 00 00       	mov    $0x0,%ebx
  801712:	b8 09 00 00 00       	mov    $0x9,%eax
  801717:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80171a:	8b 55 08             	mov    0x8(%ebp),%edx
  80171d:	89 df                	mov    %ebx,%edi
  80171f:	89 de                	mov    %ebx,%esi
  801721:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801723:	85 c0                	test   %eax,%eax
  801725:	7e 28                	jle    80174f <sys_env_set_trapframe+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801727:	89 44 24 10          	mov    %eax,0x10(%esp)
  80172b:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  801732:	00 
  801733:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  80173a:	00 
  80173b:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801742:	00 
  801743:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  80174a:	e8 2d f2 ff ff       	call   80097c <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80174f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801752:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801755:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801758:	89 ec                	mov    %ebp,%esp
  80175a:	5d                   	pop    %ebp
  80175b:	c3                   	ret    

0080175c <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80175c:	55                   	push   %ebp
  80175d:	89 e5                	mov    %esp,%ebp
  80175f:	83 ec 38             	sub    $0x38,%esp
  801762:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801765:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801768:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80176b:	bb 00 00 00 00       	mov    $0x0,%ebx
  801770:	b8 08 00 00 00       	mov    $0x8,%eax
  801775:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801778:	8b 55 08             	mov    0x8(%ebp),%edx
  80177b:	89 df                	mov    %ebx,%edi
  80177d:	89 de                	mov    %ebx,%esi
  80177f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801781:	85 c0                	test   %eax,%eax
  801783:	7e 28                	jle    8017ad <sys_env_set_status+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801785:	89 44 24 10          	mov    %eax,0x10(%esp)
  801789:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  801790:	00 
  801791:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  801798:	00 
  801799:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8017a0:	00 
  8017a1:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  8017a8:	e8 cf f1 ff ff       	call   80097c <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  8017ad:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8017b0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8017b3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8017b6:	89 ec                	mov    %ebp,%esp
  8017b8:	5d                   	pop    %ebp
  8017b9:	c3                   	ret    

008017ba <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  8017ba:	55                   	push   %ebp
  8017bb:	89 e5                	mov    %esp,%ebp
  8017bd:	83 ec 38             	sub    $0x38,%esp
  8017c0:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8017c3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8017c6:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8017c9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8017ce:	b8 06 00 00 00       	mov    $0x6,%eax
  8017d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8017d6:	8b 55 08             	mov    0x8(%ebp),%edx
  8017d9:	89 df                	mov    %ebx,%edi
  8017db:	89 de                	mov    %ebx,%esi
  8017dd:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8017df:	85 c0                	test   %eax,%eax
  8017e1:	7e 28                	jle    80180b <sys_page_unmap+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8017e3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8017e7:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8017ee:	00 
  8017ef:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  8017f6:	00 
  8017f7:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8017fe:	00 
  8017ff:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  801806:	e8 71 f1 ff ff       	call   80097c <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80180b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80180e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801811:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801814:	89 ec                	mov    %ebp,%esp
  801816:	5d                   	pop    %ebp
  801817:	c3                   	ret    

00801818 <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  801818:	55                   	push   %ebp
  801819:	89 e5                	mov    %esp,%ebp
  80181b:	83 ec 38             	sub    $0x38,%esp
  80181e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801821:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801824:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801827:	b8 05 00 00 00       	mov    $0x5,%eax
  80182c:	8b 75 18             	mov    0x18(%ebp),%esi
  80182f:	8b 7d 14             	mov    0x14(%ebp),%edi
  801832:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801835:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801838:	8b 55 08             	mov    0x8(%ebp),%edx
  80183b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  80183d:	85 c0                	test   %eax,%eax
  80183f:	7e 28                	jle    801869 <sys_page_map+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801841:	89 44 24 10          	mov    %eax,0x10(%esp)
  801845:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80184c:	00 
  80184d:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  801854:	00 
  801855:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80185c:	00 
  80185d:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  801864:	e8 13 f1 ff ff       	call   80097c <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  801869:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80186c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80186f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801872:	89 ec                	mov    %ebp,%esp
  801874:	5d                   	pop    %ebp
  801875:	c3                   	ret    

00801876 <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  801876:	55                   	push   %ebp
  801877:	89 e5                	mov    %esp,%ebp
  801879:	83 ec 38             	sub    $0x38,%esp
  80187c:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80187f:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801882:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801885:	be 00 00 00 00       	mov    $0x0,%esi
  80188a:	b8 04 00 00 00       	mov    $0x4,%eax
  80188f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801892:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801895:	8b 55 08             	mov    0x8(%ebp),%edx
  801898:	89 f7                	mov    %esi,%edi
  80189a:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  80189c:	85 c0                	test   %eax,%eax
  80189e:	7e 28                	jle    8018c8 <sys_page_alloc+0x52>
		panic("syscall %d returned %d (> 0)", num, ret);
  8018a0:	89 44 24 10          	mov    %eax,0x10(%esp)
  8018a4:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  8018ab:	00 
  8018ac:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  8018b3:	00 
  8018b4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8018bb:	00 
  8018bc:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  8018c3:	e8 b4 f0 ff ff       	call   80097c <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  8018c8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8018cb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8018ce:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8018d1:	89 ec                	mov    %ebp,%esp
  8018d3:	5d                   	pop    %ebp
  8018d4:	c3                   	ret    

008018d5 <sys_yield>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

void
sys_yield(void)
{
  8018d5:	55                   	push   %ebp
  8018d6:	89 e5                	mov    %esp,%ebp
  8018d8:	83 ec 0c             	sub    $0xc,%esp
  8018db:	89 1c 24             	mov    %ebx,(%esp)
  8018de:	89 74 24 04          	mov    %esi,0x4(%esp)
  8018e2:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8018e6:	ba 00 00 00 00       	mov    $0x0,%edx
  8018eb:	b8 0b 00 00 00       	mov    $0xb,%eax
  8018f0:	89 d1                	mov    %edx,%ecx
  8018f2:	89 d3                	mov    %edx,%ebx
  8018f4:	89 d7                	mov    %edx,%edi
  8018f6:	89 d6                	mov    %edx,%esi
  8018f8:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  8018fa:	8b 1c 24             	mov    (%esp),%ebx
  8018fd:	8b 74 24 04          	mov    0x4(%esp),%esi
  801901:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801905:	89 ec                	mov    %ebp,%esp
  801907:	5d                   	pop    %ebp
  801908:	c3                   	ret    

00801909 <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  801909:	55                   	push   %ebp
  80190a:	89 e5                	mov    %esp,%ebp
  80190c:	83 ec 0c             	sub    $0xc,%esp
  80190f:	89 1c 24             	mov    %ebx,(%esp)
  801912:	89 74 24 04          	mov    %esi,0x4(%esp)
  801916:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80191a:	ba 00 00 00 00       	mov    $0x0,%edx
  80191f:	b8 02 00 00 00       	mov    $0x2,%eax
  801924:	89 d1                	mov    %edx,%ecx
  801926:	89 d3                	mov    %edx,%ebx
  801928:	89 d7                	mov    %edx,%edi
  80192a:	89 d6                	mov    %edx,%esi
  80192c:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80192e:	8b 1c 24             	mov    (%esp),%ebx
  801931:	8b 74 24 04          	mov    0x4(%esp),%esi
  801935:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801939:	89 ec                	mov    %ebp,%esp
  80193b:	5d                   	pop    %ebp
  80193c:	c3                   	ret    

0080193d <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  80193d:	55                   	push   %ebp
  80193e:	89 e5                	mov    %esp,%ebp
  801940:	83 ec 38             	sub    $0x38,%esp
  801943:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801946:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801949:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80194c:	b9 00 00 00 00       	mov    $0x0,%ecx
  801951:	b8 03 00 00 00       	mov    $0x3,%eax
  801956:	8b 55 08             	mov    0x8(%ebp),%edx
  801959:	89 cb                	mov    %ecx,%ebx
  80195b:	89 cf                	mov    %ecx,%edi
  80195d:	89 ce                	mov    %ecx,%esi
  80195f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801961:	85 c0                	test   %eax,%eax
  801963:	7e 28                	jle    80198d <sys_env_destroy+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801965:	89 44 24 10          	mov    %eax,0x10(%esp)
  801969:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  801970:	00 
  801971:	c7 44 24 08 1f 2a 81 	movl   $0x812a1f,0x8(%esp)
  801978:	00 
  801979:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801980:	00 
  801981:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  801988:	e8 ef ef ff ff       	call   80097c <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80198d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801990:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801993:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801996:	89 ec                	mov    %ebp,%esp
  801998:	5d                   	pop    %ebp
  801999:	c3                   	ret    
	...

0080199c <sfork>:
}

// Challenge!
int
sfork(void)
{
  80199c:	55                   	push   %ebp
  80199d:	89 e5                	mov    %esp,%ebp
  80199f:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  8019a2:	c7 44 24 08 4a 2a 81 	movl   $0x812a4a,0x8(%esp)
  8019a9:	00 
  8019aa:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  8019b1:	00 
  8019b2:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  8019b9:	e8 be ef ff ff       	call   80097c <_panic>

008019be <duppage>:
// It is also OK to panic on error.
// 

static int
duppage(envid_t envid, unsigned pn)
{
  8019be:	55                   	push   %ebp
  8019bf:	89 e5                	mov    %esp,%ebp
  8019c1:	83 ec 28             	sub    $0x28,%esp
  8019c4:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8019c7:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8019ca:	89 c3                	mov    %eax,%ebx
	int r;

	// LAB 4: Your code here.
     pde_t pgDirEntry = vpd[PDX(pn*PGSIZE)];
  8019cc:	89 d6                	mov    %edx,%esi
  8019ce:	c1 e6 0c             	shl    $0xc,%esi
  8019d1:	89 f0                	mov    %esi,%eax
  8019d3:	c1 e8 16             	shr    $0x16,%eax
  8019d6:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
       
        if( 0 == pgDirEntry )
  8019dd:	85 c0                	test   %eax,%eax
  8019df:	0f 84 fc 00 00 00    	je     801ae1 <duppage+0x123>
                return -1;
     
       int perm = vpt[pn] & 0xFFF;
  8019e5:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  8019ec:	89 c2                	mov    %eax,%edx
  8019ee:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
        //cprintf("Below %d",vpt[pn]);
                //if(perm!=0)  //commented nw.
                   // cprintf("perm bit %d",perm);
	
	
	if((perm & PTE_W) && (perm & PTE_SHARE))
  8019f4:	25 02 04 00 00       	and    $0x402,%eax
  8019f9:	3d 02 04 00 00       	cmp    $0x402,%eax
  8019fe:	75 4d                	jne    801a4d <duppage+0x8f>
	{	
		if ((r = sys_page_map(0,(void *)(pn*PGSIZE),envid,(void *)(pn*PGSIZE),PTE_SHARE|(perm & PTE_USER))) < 0)
  801a00:	81 e2 07 0a 00 00    	and    $0xa07,%edx
  801a06:	80 ce 04             	or     $0x4,%dh
  801a09:	89 54 24 10          	mov    %edx,0x10(%esp)
  801a0d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801a11:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801a15:	89 74 24 04          	mov    %esi,0x4(%esp)
  801a19:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a20:	e8 f3 fd ff ff       	call   801818 <sys_page_map>
  801a25:	85 c0                	test   %eax,%eax
  801a27:	0f 89 bb 00 00 00    	jns    801ae8 <duppage+0x12a>
                panic("sys_page_map: %e", r);
  801a2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a31:	c7 44 24 08 6b 2a 81 	movl   $0x812a6b,0x8(%esp)
  801a38:	00 
  801a39:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  801a40:	00 
  801a41:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801a48:	e8 2f ef ff ff       	call   80097c <_panic>
	}	


        else if((perm & PTE_W)!=0 || (perm & PTE_COW)!=0)
  801a4d:	f7 c2 02 08 00 00    	test   $0x802,%edx
  801a53:	0f 84 8f 00 00 00    	je     801ae8 <duppage+0x12a>
         {
          //cprintf("\nInside Setting Cow\n"); 
        if ((r = sys_page_map(0,(void *)(pn*PGSIZE),envid,(void *)(pn*PGSIZE),PTE_P|PTE_U|PTE_COW)) < 0)
  801a59:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  801a60:	00 
  801a61:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801a65:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801a69:	89 74 24 04          	mov    %esi,0x4(%esp)
  801a6d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a74:	e8 9f fd ff ff       	call   801818 <sys_page_map>
  801a79:	85 c0                	test   %eax,%eax
  801a7b:	79 20                	jns    801a9d <duppage+0xdf>
                panic("sys_page_map: %e", r);
  801a7d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a81:	c7 44 24 08 6b 2a 81 	movl   $0x812a6b,0x8(%esp)
  801a88:	00 
  801a89:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  801a90:	00 
  801a91:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801a98:	e8 df ee ff ff       	call   80097c <_panic>
        if ((r = sys_page_map(envid,(void *)(pn*PGSIZE),0,(void *)(pn*PGSIZE),PTE_P|PTE_U|PTE_COW)) < 0)
  801a9d:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  801aa4:	00 
  801aa5:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801aa9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801ab0:	00 
  801ab1:	89 74 24 04          	mov    %esi,0x4(%esp)
  801ab5:	89 1c 24             	mov    %ebx,(%esp)
  801ab8:	e8 5b fd ff ff       	call   801818 <sys_page_map>
  801abd:	85 c0                	test   %eax,%eax
  801abf:	79 27                	jns    801ae8 <duppage+0x12a>
                panic("sys_page_map: %e", r);
  801ac1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ac5:	c7 44 24 08 6b 2a 81 	movl   $0x812a6b,0x8(%esp)
  801acc:	00 
  801acd:	c7 44 24 04 66 00 00 	movl   $0x66,0x4(%esp)
  801ad4:	00 
  801ad5:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801adc:	e8 9b ee ff ff       	call   80097c <_panic>
  801ae1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ae6:	eb 05                	jmp    801aed <duppage+0x12f>
  801ae8:	b8 00 00 00 00       	mov    $0x0,%eax
         }


//	panic("duppage not implemented");
	return 0;
}
  801aed:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801af0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  801af3:	89 ec                	mov    %ebp,%esp
  801af5:	5d                   	pop    %ebp
  801af6:	c3                   	ret    

00801af7 <fork>:
//


envid_t
fork(void)
{
  801af7:	55                   	push   %ebp
  801af8:	89 e5                	mov    %esp,%ebp
  801afa:	56                   	push   %esi
  801afb:	53                   	push   %ebx
  801afc:	83 ec 10             	sub    $0x10,%esp

        envid_t envid;
        uint8_t *addr;
        int r;
        extern unsigned char end[];
        set_pgfault_handler(pgfault);
  801aff:	c7 04 24 0e 1c 80 00 	movl   $0x801c0e,(%esp)
  801b06:	e8 41 19 00 00       	call   80344c <set_pgfault_handler>
static __inline envid_t sys_exofork(void) __attribute__((always_inline));
static __inline envid_t
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  801b0b:	be 07 00 00 00       	mov    $0x7,%esi
  801b10:	89 f0                	mov    %esi,%eax
  801b12:	cd 30                	int    $0x30
  801b14:	89 c6                	mov    %eax,%esi

        envid = sys_exofork();
        if (envid < 0)
  801b16:	85 c0                	test   %eax,%eax
  801b18:	79 20                	jns    801b3a <fork+0x43>
                panic("sys_exofork: %e", envid);
  801b1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b1e:	c7 44 24 08 7c 2a 81 	movl   $0x812a7c,0x8(%esp)
  801b25:	00 
  801b26:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  801b2d:	00 
  801b2e:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801b35:	e8 42 ee ff ff       	call   80097c <_panic>
                // We're the child.
                // The copied value of the global variable 'env'
                // is no longer valid (it refers to the parent!).
                // Fix it and return 0.
                env = &envs[ENVX(sys_getenvid())];
                return 0;
  801b3a:	bb 00 00 80 00       	mov    $0x800000,%ebx
        set_pgfault_handler(pgfault);

        envid = sys_exofork();
        if (envid < 0)
                panic("sys_exofork: %e", envid);
        if (envid == 0) {
  801b3f:	85 c0                	test   %eax,%eax
  801b41:	75 1c                	jne    801b5f <fork+0x68>
                // We're the child.
                // The copied value of the global variable 'env'
                // is no longer valid (it refers to the parent!).
                // Fix it and return 0.
                env = &envs[ENVX(sys_getenvid())];
  801b43:	e8 c1 fd ff ff       	call   801909 <sys_getenvid>
  801b48:	25 ff 03 00 00       	and    $0x3ff,%eax
  801b4d:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801b50:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801b55:	a3 f4 e5 b3 00       	mov    %eax,0xb3e5f4
                return 0;
  801b5a:	e9 a6 00 00 00       	jmp    801c05 <fork+0x10e>
        }
	//cprintf("\nEnd------------>%x\n",end);
       for (addr = (uint8_t*) UTEXT; addr < (uint8_t*)(USTACKTOP-PGSIZE); addr += PGSIZE)
                {  //  cprintf("\nADDress %x ROUND %x\n",addr,ROUNDDOWN(addr,PGSIZE));
			//cprintf("\nAddr------------>%x\n",addr);                     
			duppage(envid, VPN(addr));
  801b5f:	89 da                	mov    %ebx,%edx
  801b61:	c1 ea 0c             	shr    $0xc,%edx
  801b64:	89 f0                	mov    %esi,%eax
  801b66:	e8 53 fe ff ff       	call   8019be <duppage>
                // Fix it and return 0.
                env = &envs[ENVX(sys_getenvid())];
                return 0;
        }
	//cprintf("\nEnd------------>%x\n",end);
       for (addr = (uint8_t*) UTEXT; addr < (uint8_t*)(USTACKTOP-PGSIZE); addr += PGSIZE)
  801b6b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  801b71:	81 fb 00 d0 bf ee    	cmp    $0xeebfd000,%ebx
  801b77:	75 e6                	jne    801b5f <fork+0x68>
                {  //  cprintf("\nADDress %x ROUND %x\n",addr,ROUNDDOWN(addr,PGSIZE));
			//cprintf("\nAddr------------>%x\n",addr);                     
			duppage(envid, VPN(addr));
                }
              duppage(envid,VPN(USTACKTOP-PGSIZE));
  801b79:	ba fd eb 0e 00       	mov    $0xeebfd,%edx
  801b7e:	89 f0                	mov    %esi,%eax
  801b80:	e8 39 fe ff ff       	call   8019be <duppage>
        // Also copy the stack we are currently running on.
       //if(sys_page_alloc(envid, (void *)(ROUNDDOWN(&addr, PGSIZE)),PTE_U|PTE_P|PTE_W)<0)
         //                      panic("stack not allocated");
     
   
     sys_env_set_pgfault_upcall(envid,env->env_pgfault_upcall);
  801b85:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  801b8a:	8b 40 64             	mov    0x64(%eax),%eax
  801b8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801b91:	89 34 24             	mov    %esi,(%esp)
  801b94:	e8 07 fb ff ff       	call   8016a0 <sys_env_set_pgfault_upcall>

     if(sys_page_alloc(envid,(void *)UXSTACKTOP-PGSIZE,PTE_P|PTE_U|PTE_W)<0)
  801b99:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801ba0:	00 
  801ba1:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801ba8:	ee 
  801ba9:	89 34 24             	mov    %esi,(%esp)
  801bac:	e8 c5 fc ff ff       	call   801876 <sys_page_alloc>
  801bb1:	85 c0                	test   %eax,%eax
  801bb3:	79 1c                	jns    801bd1 <fork+0xda>
                          panic("Cant allocate Page");
  801bb5:	c7 44 24 08 8c 2a 81 	movl   $0x812a8c,0x8(%esp)
  801bbc:	00 
  801bbd:	c7 44 24 04 a9 00 00 	movl   $0xa9,0x4(%esp)
  801bc4:	00 
  801bc5:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801bcc:	e8 ab ed ff ff       	call   80097c <_panic>

        // Start the child environment running
        if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  801bd1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801bd8:	00 
  801bd9:	89 34 24             	mov    %esi,(%esp)
  801bdc:	e8 7b fb ff ff       	call   80175c <sys_env_set_status>
  801be1:	85 c0                	test   %eax,%eax
  801be3:	79 20                	jns    801c05 <fork+0x10e>
                panic("sys_env_set_status: %e", r);
  801be5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801be9:	c7 44 24 08 9f 2a 81 	movl   $0x812a9f,0x8(%esp)
  801bf0:	00 
  801bf1:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
  801bf8:	00 
  801bf9:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801c00:	e8 77 ed ff ff       	call   80097c <_panic>
         return envid;
           
//panic("fork not implemented");
}
  801c05:	89 f0                	mov    %esi,%eax
  801c07:	83 c4 10             	add    $0x10,%esp
  801c0a:	5b                   	pop    %ebx
  801c0b:	5e                   	pop    %esi
  801c0c:	5d                   	pop    %ebp
  801c0d:	c3                   	ret    

00801c0e <pgfault>:
// map in our own private writable copy.
//

static void
pgfault(struct UTrapframe *utf)
{
  801c0e:	55                   	push   %ebp
  801c0f:	89 e5                	mov    %esp,%ebp
  801c11:	53                   	push   %ebx
  801c12:	83 ec 24             	sub    $0x24,%esp
  801c15:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  801c18:	8b 18                	mov    (%eax),%ebx
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).
 
         int perm = vpt[VPN(addr)] & 0xFFF;
  801c1a:	89 da                	mov    %ebx,%edx
  801c1c:	c1 ea 0c             	shr    $0xc,%edx
  801c1f:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx

static void
pgfault(struct UTrapframe *utf)
{
	void *addr = (void *) utf->utf_fault_va;
	uint32_t err = utf->utf_err;
  801c26:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  801c2a:	74 21                	je     801c4d <pgfault+0x3f>
 
         int perm = vpt[VPN(addr)] & 0xFFF;
        if((err & FEC_WR)!=0)
           {
//              cprintf("\n>>>>>Due to write\n");
            if((perm & PTE_COW) == 0)
  801c2c:	f6 c6 08             	test   $0x8,%dh
  801c2f:	75 1c                	jne    801c4d <pgfault+0x3f>
             {
                   panic("Not Set Cow");
  801c31:	c7 44 24 08 b6 2a 81 	movl   $0x812ab6,0x8(%esp)
  801c38:	00 
  801c39:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  801c40:	00 
  801c41:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801c48:	e8 2f ed ff ff       	call   80097c <_panic>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
        if(sys_page_alloc(0,PFTEMP,PTE_P|PTE_U|PTE_W)<0)
  801c4d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801c54:	00 
  801c55:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801c5c:	00 
  801c5d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c64:	e8 0d fc ff ff       	call   801876 <sys_page_alloc>
  801c69:	85 c0                	test   %eax,%eax
  801c6b:	79 1c                	jns    801c89 <pgfault+0x7b>
              panic("\nPage not allocated\n");
  801c6d:	c7 44 24 08 c2 2a 81 	movl   $0x812ac2,0x8(%esp)
  801c74:	00 
  801c75:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  801c7c:	00 
  801c7d:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801c84:	e8 f3 ec ff ff       	call   80097c <_panic>
           memmove(PFTEMP,ROUNDDOWN(addr,PGSIZE),PGSIZE);
  801c89:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  801c8f:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801c96:	00 
  801c97:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801c9b:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  801ca2:	e8 2e f6 ff ff       	call   8012d5 <memmove>
          if(sys_page_map(0,ROUNDDOWN(PFTEMP,PGSIZE),0,ROUNDDOWN(addr,PGSIZE),PTE_U|PTE_P|PTE_W)<0)
  801ca7:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801cae:	00 
  801caf:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  801cb3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801cba:	00 
  801cbb:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801cc2:	00 
  801cc3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801cca:	e8 49 fb ff ff       	call   801818 <sys_page_map>
  801ccf:	85 c0                	test   %eax,%eax
  801cd1:	79 1c                	jns    801cef <pgfault+0xe1>
                   panic("not mapped properly");
  801cd3:	c7 44 24 08 d7 2a 81 	movl   $0x812ad7,0x8(%esp)
  801cda:	00 
  801cdb:	c7 44 24 04 33 00 00 	movl   $0x33,0x4(%esp)
  801ce2:	00 
  801ce3:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801cea:	e8 8d ec ff ff       	call   80097c <_panic>
         if( 0 > sys_page_unmap(0, PFTEMP) )
  801cef:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801cf6:	00 
  801cf7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801cfe:	e8 b7 fa ff ff       	call   8017ba <sys_page_unmap>
  801d03:	85 c0                	test   %eax,%eax
  801d05:	79 1c                	jns    801d23 <pgfault+0x115>
                panic("sys_page_unmap failed\n");
  801d07:	c7 44 24 08 eb 2a 81 	movl   $0x812aeb,0x8(%esp)
  801d0e:	00 
  801d0f:	c7 44 24 04 35 00 00 	movl   $0x35,0x4(%esp)
  801d16:	00 
  801d17:	c7 04 24 60 2a 81 00 	movl   $0x812a60,(%esp)
  801d1e:	e8 59 ec ff ff       	call   80097c <_panic>
   
//	panic("pgfault not implemented");
}
  801d23:	83 c4 24             	add    $0x24,%esp
  801d26:	5b                   	pop    %ebx
  801d27:	5d                   	pop    %ebp
  801d28:	c3                   	ret    
  801d29:	00 00                	add    %al,(%eax)
  801d2b:	00 00                	add    %al,(%eax)
  801d2d:	00 00                	add    %al,(%eax)
	...

00801d30 <ipc_send>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)

void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801d30:	55                   	push   %ebp
  801d31:	89 e5                	mov    %esp,%ebp
  801d33:	57                   	push   %edi
  801d34:	56                   	push   %esi
  801d35:	53                   	push   %ebx
  801d36:	83 ec 1c             	sub    $0x1c,%esp
  801d39:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801d3c:	8b 75 0c             	mov    0xc(%ebp),%esi
  801d3f:	8b 7d 10             	mov    0x10(%ebp),%edi
           int r;
       // if(pg==NULL)
         //  pg=(void *)UTOP;
       while(1)
        { 
          r = sys_ipc_try_send(to_env,val,pg,perm);
  801d42:	8b 45 14             	mov    0x14(%ebp),%eax
  801d45:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d49:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801d4d:	89 74 24 04          	mov    %esi,0x4(%esp)
  801d51:	89 1c 24             	mov    %ebx,(%esp)
  801d54:	e8 0f f9 ff ff       	call   801668 <sys_ipc_try_send>
           if(r<0 && r!=-E_IPC_NOT_RECV)
  801d59:	85 c0                	test   %eax,%eax
  801d5b:	79 21                	jns    801d7e <ipc_send+0x4e>
  801d5d:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801d60:	74 1c                	je     801d7e <ipc_send+0x4e>
                    panic("Panic at ipc_send");
  801d62:	c7 44 24 08 02 2b 81 	movl   $0x812b02,0x8(%esp)
  801d69:	00 
  801d6a:	c7 44 24 04 43 00 00 	movl   $0x43,0x4(%esp)
  801d71:	00 
  801d72:	c7 04 24 14 2b 81 00 	movl   $0x812b14,(%esp)
  801d79:	e8 fe eb ff ff       	call   80097c <_panic>
          else if(r==-E_IPC_NOT_RECV)
  801d7e:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801d81:	75 07                	jne    801d8a <ipc_send+0x5a>
           sys_yield();
  801d83:	e8 4d fb ff ff       	call   8018d5 <sys_yield>
          else
            break;
        }
  801d88:	eb b8                	jmp    801d42 <ipc_send+0x12>
//	panic("ipc_send not implemented");
}
  801d8a:	83 c4 1c             	add    $0x1c,%esp
  801d8d:	5b                   	pop    %ebx
  801d8e:	5e                   	pop    %esi
  801d8f:	5f                   	pop    %edi
  801d90:	5d                   	pop    %ebp
  801d91:	c3                   	ret    

00801d92 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801d92:	55                   	push   %ebp
  801d93:	89 e5                	mov    %esp,%ebp
  801d95:	83 ec 18             	sub    $0x18,%esp
  801d98:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801d9b:	89 75 fc             	mov    %esi,-0x4(%ebp)
  801d9e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801da1:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 4: Your code here.
     int r; 
     r= sys_ipc_recv(pg);
  801da4:	8b 45 0c             	mov    0xc(%ebp),%eax
  801da7:	89 04 24             	mov    %eax,(%esp)
  801daa:	e8 5c f8 ff ff       	call   80160b <sys_ipc_recv>
        if(r<0)
  801daf:	85 c0                	test   %eax,%eax
  801db1:	79 17                	jns    801dca <ipc_recv+0x38>
        {
          if(from_env_store!=NULL)
  801db3:	85 db                	test   %ebx,%ebx
  801db5:	74 06                	je     801dbd <ipc_recv+0x2b>
               *from_env_store =0;
  801db7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
          if(perm_store!=NULL)
  801dbd:	85 f6                	test   %esi,%esi
  801dbf:	90                   	nop
  801dc0:	74 2c                	je     801dee <ipc_recv+0x5c>
              *perm_store=0;
  801dc2:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  801dc8:	eb 24                	jmp    801dee <ipc_recv+0x5c>
          return r;
       }

      if(from_env_store!=NULL)
  801dca:	85 db                	test   %ebx,%ebx
  801dcc:	74 0a                	je     801dd8 <ipc_recv+0x46>
       *from_env_store = env->env_ipc_from;
  801dce:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  801dd3:	8b 40 74             	mov    0x74(%eax),%eax
  801dd6:	89 03                	mov    %eax,(%ebx)

      if(perm_store!=NULL)
  801dd8:	85 f6                	test   %esi,%esi
  801dda:	74 0a                	je     801de6 <ipc_recv+0x54>
         *perm_store =env->env_ipc_perm; 
  801ddc:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  801de1:	8b 40 78             	mov    0x78(%eax),%eax
  801de4:	89 06                	mov    %eax,(%esi)

//env->env_tf.tf_eflags = 0;   
      return env->env_ipc_value;
  801de6:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  801deb:	8b 40 70             	mov    0x70(%eax),%eax
}
  801dee:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801df1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  801df4:	89 ec                	mov    %ebp,%esp
  801df6:	5d                   	pop    %ebp
  801df7:	c3                   	ret    
	...

00801e00 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  801e00:	55                   	push   %ebp
  801e01:	89 e5                	mov    %esp,%ebp
  801e03:	8b 45 08             	mov    0x8(%ebp),%eax
  801e06:	05 00 00 00 30       	add    $0x30000000,%eax
  801e0b:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  801e0e:	5d                   	pop    %ebp
  801e0f:	c3                   	ret    

00801e10 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  801e10:	55                   	push   %ebp
  801e11:	89 e5                	mov    %esp,%ebp
  801e13:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  801e16:	8b 45 08             	mov    0x8(%ebp),%eax
  801e19:	89 04 24             	mov    %eax,(%esp)
  801e1c:	e8 df ff ff ff       	call   801e00 <fd2num>
  801e21:	05 20 00 0d 00       	add    $0xd0020,%eax
  801e26:	c1 e0 0c             	shl    $0xc,%eax
}
  801e29:	c9                   	leave  
  801e2a:	c3                   	ret    

00801e2b <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801e2b:	55                   	push   %ebp
  801e2c:	89 e5                	mov    %esp,%ebp
  801e2e:	57                   	push   %edi
  801e2f:	56                   	push   %esi
  801e30:	53                   	push   %ebx
  801e31:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
  801e34:	a1 00 dd 7b ef       	mov    0xef7bdd00,%eax
  801e39:	a8 01                	test   $0x1,%al
  801e3b:	74 36                	je     801e73 <fd_alloc+0x48>
  801e3d:	a1 00 00 74 ef       	mov    0xef740000,%eax
  801e42:	a8 01                	test   $0x1,%al
  801e44:	74 2d                	je     801e73 <fd_alloc+0x48>
  801e46:	b8 00 10 00 d0       	mov    $0xd0001000,%eax
  801e4b:	b9 00 d0 7b ef       	mov    $0xef7bd000,%ecx
  801e50:	be 00 00 40 ef       	mov    $0xef400000,%esi
  801e55:	89 c3                	mov    %eax,%ebx
  801e57:	89 c2                	mov    %eax,%edx
  801e59:	c1 ea 16             	shr    $0x16,%edx
  801e5c:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  801e5f:	f6 c2 01             	test   $0x1,%dl
  801e62:	74 14                	je     801e78 <fd_alloc+0x4d>
  801e64:	89 c2                	mov    %eax,%edx
  801e66:	c1 ea 0c             	shr    $0xc,%edx
  801e69:	8b 14 96             	mov    (%esi,%edx,4),%edx
  801e6c:	f6 c2 01             	test   $0x1,%dl
  801e6f:	75 10                	jne    801e81 <fd_alloc+0x56>
  801e71:	eb 05                	jmp    801e78 <fd_alloc+0x4d>
  801e73:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
			*fd_store = fd;
  801e78:	89 1f                	mov    %ebx,(%edi)
  801e7a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801e7f:	eb 17                	jmp    801e98 <fd_alloc+0x6d>
  801e81:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801e86:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  801e8b:	75 c8                	jne    801e55 <fd_alloc+0x2a>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  801e8d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801e93:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  801e98:	5b                   	pop    %ebx
  801e99:	5e                   	pop    %esi
  801e9a:	5f                   	pop    %edi
  801e9b:	5d                   	pop    %ebp
  801e9c:	c3                   	ret    

00801e9d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801e9d:	55                   	push   %ebp
  801e9e:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  801ea0:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea3:	83 f8 1f             	cmp    $0x1f,%eax
  801ea6:	77 36                	ja     801ede <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  801ea8:	05 00 00 0d 00       	add    $0xd0000,%eax
  801ead:	c1 e0 0c             	shl    $0xc,%eax
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[VPN(fd)] & PTE_P)) {
  801eb0:	89 c2                	mov    %eax,%edx
  801eb2:	c1 ea 16             	shr    $0x16,%edx
  801eb5:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  801ebc:	f6 c2 01             	test   $0x1,%dl
  801ebf:	74 1d                	je     801ede <fd_lookup+0x41>
  801ec1:	89 c2                	mov    %eax,%edx
  801ec3:	c1 ea 0c             	shr    $0xc,%edx
  801ec6:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  801ecd:	f6 c2 01             	test   $0x1,%dl
  801ed0:	74 0c                	je     801ede <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  801ed2:	8b 55 0c             	mov    0xc(%ebp),%edx
  801ed5:	89 02                	mov    %eax,(%edx)
  801ed7:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
  801edc:	eb 05                	jmp    801ee3 <fd_lookup+0x46>
  801ede:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801ee3:	5d                   	pop    %ebp
  801ee4:	c3                   	ret    

00801ee5 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  801ee5:	55                   	push   %ebp
  801ee6:	89 e5                	mov    %esp,%ebp
  801ee8:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801eeb:	8d 45 fc             	lea    -0x4(%ebp),%eax
  801eee:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ef2:	8b 45 08             	mov    0x8(%ebp),%eax
  801ef5:	89 04 24             	mov    %eax,(%esp)
  801ef8:	e8 a0 ff ff ff       	call   801e9d <fd_lookup>
  801efd:	85 c0                	test   %eax,%eax
  801eff:	78 0e                	js     801f0f <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  801f01:	8b 45 fc             	mov    -0x4(%ebp),%eax
  801f04:	8b 55 0c             	mov    0xc(%ebp),%edx
  801f07:	89 50 04             	mov    %edx,0x4(%eax)
  801f0a:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  801f0f:	c9                   	leave  
  801f10:	c3                   	ret    

00801f11 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  801f11:	55                   	push   %ebp
  801f12:	89 e5                	mov    %esp,%ebp
  801f14:	56                   	push   %esi
  801f15:	53                   	push   %ebx
  801f16:	83 ec 10             	sub    $0x10,%esp
  801f19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801f1c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
// File functions
// --------------------------------------------------------------

static struct Dev *devtab[] =
{
	&devfile,
  801f1f:	b8 04 80 81 00       	mov    $0x818004,%eax
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  801f24:	ba 00 00 00 00       	mov    $0x0,%edx

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  801f29:	be 9c 2b 81 00       	mov    $0x812b9c,%esi
		if (devtab[i]->dev_id == dev_id) {
  801f2e:	39 08                	cmp    %ecx,(%eax)
  801f30:	75 10                	jne    801f42 <dev_lookup+0x31>
  801f32:	eb 04                	jmp    801f38 <dev_lookup+0x27>
  801f34:	39 08                	cmp    %ecx,(%eax)
  801f36:	75 0a                	jne    801f42 <dev_lookup+0x31>
			*dev = devtab[i];
  801f38:	89 03                	mov    %eax,(%ebx)
  801f3a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801f3f:	90                   	nop
  801f40:	eb 31                	jmp    801f73 <dev_lookup+0x62>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  801f42:	83 c2 01             	add    $0x1,%edx
  801f45:	8b 04 96             	mov    (%esi,%edx,4),%eax
  801f48:	85 c0                	test   %eax,%eax
  801f4a:	75 e8                	jne    801f34 <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", env->env_id, dev_id);
  801f4c:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  801f51:	8b 40 4c             	mov    0x4c(%eax),%eax
  801f54:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  801f58:	89 44 24 04          	mov    %eax,0x4(%esp)
  801f5c:	c7 04 24 20 2b 81 00 	movl   $0x812b20,(%esp)
  801f63:	e8 d9 ea ff ff       	call   800a41 <cprintf>
	*dev = 0;
  801f68:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  801f6e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  801f73:	83 c4 10             	add    $0x10,%esp
  801f76:	5b                   	pop    %ebx
  801f77:	5e                   	pop    %esi
  801f78:	5d                   	pop    %ebp
  801f79:	c3                   	ret    

00801f7a <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  801f7a:	55                   	push   %ebp
  801f7b:	89 e5                	mov    %esp,%ebp
  801f7d:	53                   	push   %ebx
  801f7e:	83 ec 24             	sub    $0x24,%esp
  801f81:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  801f84:	8d 45 f0             	lea    -0x10(%ebp),%eax
  801f87:	89 44 24 04          	mov    %eax,0x4(%esp)
  801f8b:	8b 45 08             	mov    0x8(%ebp),%eax
  801f8e:	89 04 24             	mov    %eax,(%esp)
  801f91:	e8 07 ff ff ff       	call   801e9d <fd_lookup>
  801f96:	85 c0                	test   %eax,%eax
  801f98:	78 53                	js     801fed <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  801f9a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801f9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801fa1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801fa4:	8b 00                	mov    (%eax),%eax
  801fa6:	89 04 24             	mov    %eax,(%esp)
  801fa9:	e8 63 ff ff ff       	call   801f11 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  801fae:	85 c0                	test   %eax,%eax
  801fb0:	78 3b                	js     801fed <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  801fb2:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  801fb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
  801fba:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  801fbe:	74 2d                	je     801fed <fstat+0x73>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  801fc0:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  801fc3:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  801fca:	00 00 00 
	stat->st_isdir = 0;
  801fcd:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  801fd4:	00 00 00 
	stat->st_dev = dev;
  801fd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  801fda:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  801fe0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801fe4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  801fe7:	89 14 24             	mov    %edx,(%esp)
  801fea:	ff 50 14             	call   *0x14(%eax)
}
  801fed:	83 c4 24             	add    $0x24,%esp
  801ff0:	5b                   	pop    %ebx
  801ff1:	5d                   	pop    %ebp
  801ff2:	c3                   	ret    

00801ff3 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  801ff3:	55                   	push   %ebp
  801ff4:	89 e5                	mov    %esp,%ebp
  801ff6:	53                   	push   %ebx
  801ff7:	83 ec 24             	sub    $0x24,%esp
  801ffa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  801ffd:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802000:	89 44 24 04          	mov    %eax,0x4(%esp)
  802004:	89 1c 24             	mov    %ebx,(%esp)
  802007:	e8 91 fe ff ff       	call   801e9d <fd_lookup>
  80200c:	85 c0                	test   %eax,%eax
  80200e:	78 5f                	js     80206f <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802010:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802013:	89 44 24 04          	mov    %eax,0x4(%esp)
  802017:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80201a:	8b 00                	mov    (%eax),%eax
  80201c:	89 04 24             	mov    %eax,(%esp)
  80201f:	e8 ed fe ff ff       	call   801f11 <dev_lookup>
ftruncate(int fdnum, off_t newsize)
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  802024:	85 c0                	test   %eax,%eax
  802026:	78 47                	js     80206f <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  802028:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80202b:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  80202f:	75 23                	jne    802054 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			env->env_id, fdnum); 
  802031:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  802036:	8b 40 4c             	mov    0x4c(%eax),%eax
  802039:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80203d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802041:	c7 04 24 40 2b 81 00 	movl   $0x812b40,(%esp)
  802048:	e8 f4 e9 ff ff       	call   800a41 <cprintf>
  80204d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			env->env_id, fdnum); 
		return -E_INVAL;
  802052:	eb 1b                	jmp    80206f <ftruncate+0x7c>
	}
	if (!dev->dev_trunc)
  802054:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802057:	8b 48 18             	mov    0x18(%eax),%ecx
  80205a:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80205f:	85 c9                	test   %ecx,%ecx
  802061:	74 0c                	je     80206f <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  802063:	8b 45 0c             	mov    0xc(%ebp),%eax
  802066:	89 44 24 04          	mov    %eax,0x4(%esp)
  80206a:	89 14 24             	mov    %edx,(%esp)
  80206d:	ff d1                	call   *%ecx
}
  80206f:	83 c4 24             	add    $0x24,%esp
  802072:	5b                   	pop    %ebx
  802073:	5d                   	pop    %ebp
  802074:	c3                   	ret    

00802075 <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  802075:	55                   	push   %ebp
  802076:	89 e5                	mov    %esp,%ebp
  802078:	53                   	push   %ebx
  802079:	83 ec 24             	sub    $0x24,%esp
  80207c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80207f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802082:	89 44 24 04          	mov    %eax,0x4(%esp)
  802086:	89 1c 24             	mov    %ebx,(%esp)
  802089:	e8 0f fe ff ff       	call   801e9d <fd_lookup>
  80208e:	85 c0                	test   %eax,%eax
  802090:	78 66                	js     8020f8 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802092:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802095:	89 44 24 04          	mov    %eax,0x4(%esp)
  802099:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80209c:	8b 00                	mov    (%eax),%eax
  80209e:	89 04 24             	mov    %eax,(%esp)
  8020a1:	e8 6b fe ff ff       	call   801f11 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020a6:	85 c0                	test   %eax,%eax
  8020a8:	78 4e                	js     8020f8 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8020aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8020ad:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  8020b1:	75 23                	jne    8020d6 <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", env->env_id, fdnum);
  8020b3:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  8020b8:	8b 40 4c             	mov    0x4c(%eax),%eax
  8020bb:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8020bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020c3:	c7 04 24 61 2b 81 00 	movl   $0x812b61,(%esp)
  8020ca:	e8 72 e9 ff ff       	call   800a41 <cprintf>
  8020cf:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  8020d4:	eb 22                	jmp    8020f8 <write+0x83>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  8020d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8020d9:	8b 48 0c             	mov    0xc(%eax),%ecx
  8020dc:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8020e1:	85 c9                	test   %ecx,%ecx
  8020e3:	74 13                	je     8020f8 <write+0x83>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  8020e5:	8b 45 10             	mov    0x10(%ebp),%eax
  8020e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8020ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  8020ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020f3:	89 14 24             	mov    %edx,(%esp)
  8020f6:	ff d1                	call   *%ecx
}
  8020f8:	83 c4 24             	add    $0x24,%esp
  8020fb:	5b                   	pop    %ebx
  8020fc:	5d                   	pop    %ebp
  8020fd:	c3                   	ret    

008020fe <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8020fe:	55                   	push   %ebp
  8020ff:	89 e5                	mov    %esp,%ebp
  802101:	53                   	push   %ebx
  802102:	83 ec 24             	sub    $0x24,%esp
  802105:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802108:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80210b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80210f:	89 1c 24             	mov    %ebx,(%esp)
  802112:	e8 86 fd ff ff       	call   801e9d <fd_lookup>
  802117:	85 c0                	test   %eax,%eax
  802119:	78 6b                	js     802186 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80211b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80211e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802122:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802125:	8b 00                	mov    (%eax),%eax
  802127:	89 04 24             	mov    %eax,(%esp)
  80212a:	e8 e2 fd ff ff       	call   801f11 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80212f:	85 c0                	test   %eax,%eax
  802131:	78 53                	js     802186 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  802133:	8b 55 f0             	mov    -0x10(%ebp),%edx
  802136:	8b 42 08             	mov    0x8(%edx),%eax
  802139:	83 e0 03             	and    $0x3,%eax
  80213c:	83 f8 01             	cmp    $0x1,%eax
  80213f:	75 23                	jne    802164 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", env->env_id, fdnum); 
  802141:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  802146:	8b 40 4c             	mov    0x4c(%eax),%eax
  802149:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80214d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802151:	c7 04 24 7e 2b 81 00 	movl   $0x812b7e,(%esp)
  802158:	e8 e4 e8 ff ff       	call   800a41 <cprintf>
  80215d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802162:	eb 22                	jmp    802186 <read+0x88>
	}
	if (!dev->dev_read)
  802164:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802167:	8b 48 08             	mov    0x8(%eax),%ecx
  80216a:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80216f:	85 c9                	test   %ecx,%ecx
  802171:	74 13                	je     802186 <read+0x88>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  802173:	8b 45 10             	mov    0x10(%ebp),%eax
  802176:	89 44 24 08          	mov    %eax,0x8(%esp)
  80217a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80217d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802181:	89 14 24             	mov    %edx,(%esp)
  802184:	ff d1                	call   *%ecx
}
  802186:	83 c4 24             	add    $0x24,%esp
  802189:	5b                   	pop    %ebx
  80218a:	5d                   	pop    %ebp
  80218b:	c3                   	ret    

0080218c <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80218c:	55                   	push   %ebp
  80218d:	89 e5                	mov    %esp,%ebp
  80218f:	57                   	push   %edi
  802190:	56                   	push   %esi
  802191:	53                   	push   %ebx
  802192:	83 ec 1c             	sub    $0x1c,%esp
  802195:	8b 7d 08             	mov    0x8(%ebp),%edi
  802198:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80219b:	ba 00 00 00 00       	mov    $0x0,%edx
  8021a0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8021a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8021aa:	85 f6                	test   %esi,%esi
  8021ac:	74 29                	je     8021d7 <readn+0x4b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  8021ae:	89 f0                	mov    %esi,%eax
  8021b0:	29 d0                	sub    %edx,%eax
  8021b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8021b6:	03 55 0c             	add    0xc(%ebp),%edx
  8021b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8021bd:	89 3c 24             	mov    %edi,(%esp)
  8021c0:	e8 39 ff ff ff       	call   8020fe <read>
		if (m < 0)
  8021c5:	85 c0                	test   %eax,%eax
  8021c7:	78 0e                	js     8021d7 <readn+0x4b>
			return m;
		if (m == 0)
  8021c9:	85 c0                	test   %eax,%eax
  8021cb:	74 08                	je     8021d5 <readn+0x49>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8021cd:	01 c3                	add    %eax,%ebx
  8021cf:	89 da                	mov    %ebx,%edx
  8021d1:	39 f3                	cmp    %esi,%ebx
  8021d3:	72 d9                	jb     8021ae <readn+0x22>
  8021d5:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  8021d7:	83 c4 1c             	add    $0x1c,%esp
  8021da:	5b                   	pop    %ebx
  8021db:	5e                   	pop    %esi
  8021dc:	5f                   	pop    %edi
  8021dd:	5d                   	pop    %ebp
  8021de:	c3                   	ret    

008021df <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8021df:	55                   	push   %ebp
  8021e0:	89 e5                	mov    %esp,%ebp
  8021e2:	56                   	push   %esi
  8021e3:	53                   	push   %ebx
  8021e4:	83 ec 20             	sub    $0x20,%esp
  8021e7:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8021ea:	89 34 24             	mov    %esi,(%esp)
  8021ed:	e8 0e fc ff ff       	call   801e00 <fd2num>
  8021f2:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8021f5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8021f9:	89 04 24             	mov    %eax,(%esp)
  8021fc:	e8 9c fc ff ff       	call   801e9d <fd_lookup>
  802201:	89 c3                	mov    %eax,%ebx
  802203:	85 c0                	test   %eax,%eax
  802205:	78 05                	js     80220c <fd_close+0x2d>
  802207:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80220a:	74 0c                	je     802218 <fd_close+0x39>
	    || fd != fd2)
		return (must_exist ? r : 0);
  80220c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  802210:	19 c0                	sbb    %eax,%eax
  802212:	f7 d0                	not    %eax
  802214:	21 c3                	and    %eax,%ebx
  802216:	eb 3d                	jmp    802255 <fd_close+0x76>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  802218:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80221b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80221f:	8b 06                	mov    (%esi),%eax
  802221:	89 04 24             	mov    %eax,(%esp)
  802224:	e8 e8 fc ff ff       	call   801f11 <dev_lookup>
  802229:	89 c3                	mov    %eax,%ebx
  80222b:	85 c0                	test   %eax,%eax
  80222d:	78 16                	js     802245 <fd_close+0x66>
		if (dev->dev_close)
  80222f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802232:	8b 40 10             	mov    0x10(%eax),%eax
  802235:	bb 00 00 00 00       	mov    $0x0,%ebx
  80223a:	85 c0                	test   %eax,%eax
  80223c:	74 07                	je     802245 <fd_close+0x66>
			r = (*dev->dev_close)(fd);
  80223e:	89 34 24             	mov    %esi,(%esp)
  802241:	ff d0                	call   *%eax
  802243:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  802245:	89 74 24 04          	mov    %esi,0x4(%esp)
  802249:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802250:	e8 65 f5 ff ff       	call   8017ba <sys_page_unmap>
	return r;
}
  802255:	89 d8                	mov    %ebx,%eax
  802257:	83 c4 20             	add    $0x20,%esp
  80225a:	5b                   	pop    %ebx
  80225b:	5e                   	pop    %esi
  80225c:	5d                   	pop    %ebp
  80225d:	c3                   	ret    

0080225e <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80225e:	55                   	push   %ebp
  80225f:	89 e5                	mov    %esp,%ebp
  802261:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802264:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802267:	89 44 24 04          	mov    %eax,0x4(%esp)
  80226b:	8b 45 08             	mov    0x8(%ebp),%eax
  80226e:	89 04 24             	mov    %eax,(%esp)
  802271:	e8 27 fc ff ff       	call   801e9d <fd_lookup>
  802276:	85 c0                	test   %eax,%eax
  802278:	78 13                	js     80228d <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  80227a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  802281:	00 
  802282:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802285:	89 04 24             	mov    %eax,(%esp)
  802288:	e8 52 ff ff ff       	call   8021df <fd_close>
}
  80228d:	c9                   	leave  
  80228e:	c3                   	ret    

0080228f <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  80228f:	55                   	push   %ebp
  802290:	89 e5                	mov    %esp,%ebp
  802292:	83 ec 18             	sub    $0x18,%esp
  802295:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802298:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80229b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8022a2:	00 
  8022a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8022a6:	89 04 24             	mov    %eax,(%esp)
  8022a9:	e8 a9 03 00 00       	call   802657 <open>
  8022ae:	89 c3                	mov    %eax,%ebx
  8022b0:	85 c0                	test   %eax,%eax
  8022b2:	78 1b                	js     8022cf <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  8022b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8022bb:	89 1c 24             	mov    %ebx,(%esp)
  8022be:	e8 b7 fc ff ff       	call   801f7a <fstat>
  8022c3:	89 c6                	mov    %eax,%esi
	close(fd);
  8022c5:	89 1c 24             	mov    %ebx,(%esp)
  8022c8:	e8 91 ff ff ff       	call   80225e <close>
  8022cd:	89 f3                	mov    %esi,%ebx
	return r;
}
  8022cf:	89 d8                	mov    %ebx,%eax
  8022d1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8022d4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8022d7:	89 ec                	mov    %ebp,%esp
  8022d9:	5d                   	pop    %ebp
  8022da:	c3                   	ret    

008022db <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  8022db:	55                   	push   %ebp
  8022dc:	89 e5                	mov    %esp,%ebp
  8022de:	53                   	push   %ebx
  8022df:	83 ec 14             	sub    $0x14,%esp
  8022e2:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  8022e7:	89 1c 24             	mov    %ebx,(%esp)
  8022ea:	e8 6f ff ff ff       	call   80225e <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8022ef:	83 c3 01             	add    $0x1,%ebx
  8022f2:	83 fb 20             	cmp    $0x20,%ebx
  8022f5:	75 f0                	jne    8022e7 <close_all+0xc>
		close(i);
}
  8022f7:	83 c4 14             	add    $0x14,%esp
  8022fa:	5b                   	pop    %ebx
  8022fb:	5d                   	pop    %ebp
  8022fc:	c3                   	ret    

008022fd <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8022fd:	55                   	push   %ebp
  8022fe:	89 e5                	mov    %esp,%ebp
  802300:	83 ec 58             	sub    $0x58,%esp
  802303:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802306:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802309:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80230c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80230f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  802312:	89 44 24 04          	mov    %eax,0x4(%esp)
  802316:	8b 45 08             	mov    0x8(%ebp),%eax
  802319:	89 04 24             	mov    %eax,(%esp)
  80231c:	e8 7c fb ff ff       	call   801e9d <fd_lookup>
  802321:	89 c3                	mov    %eax,%ebx
  802323:	85 c0                	test   %eax,%eax
  802325:	0f 88 e0 00 00 00    	js     80240b <dup+0x10e>
		return r;
	close(newfdnum);
  80232b:	89 3c 24             	mov    %edi,(%esp)
  80232e:	e8 2b ff ff ff       	call   80225e <close>

	newfd = INDEX2FD(newfdnum);
  802333:	8d b7 00 00 0d 00    	lea    0xd0000(%edi),%esi
  802339:	c1 e6 0c             	shl    $0xc,%esi
	ova = fd2data(oldfd);
  80233c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80233f:	89 04 24             	mov    %eax,(%esp)
  802342:	e8 c9 fa ff ff       	call   801e10 <fd2data>
  802347:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  802349:	89 34 24             	mov    %esi,(%esp)
  80234c:	e8 bf fa ff ff       	call   801e10 <fd2data>
  802351:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[VPN(ova)] & PTE_P))
  802354:	89 da                	mov    %ebx,%edx
  802356:	89 d8                	mov    %ebx,%eax
  802358:	c1 e8 16             	shr    $0x16,%eax
  80235b:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802362:	a8 01                	test   $0x1,%al
  802364:	74 43                	je     8023a9 <dup+0xac>
  802366:	c1 ea 0c             	shr    $0xc,%edx
  802369:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802370:	a8 01                	test   $0x1,%al
  802372:	74 35                	je     8023a9 <dup+0xac>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[VPN(ova)] & PTE_USER)) < 0)
  802374:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80237b:	25 07 0e 00 00       	and    $0xe07,%eax
  802380:	89 44 24 10          	mov    %eax,0x10(%esp)
  802384:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802387:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80238b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802392:	00 
  802393:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802397:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80239e:	e8 75 f4 ff ff       	call   801818 <sys_page_map>
  8023a3:	89 c3                	mov    %eax,%ebx
  8023a5:	85 c0                	test   %eax,%eax
  8023a7:	78 3f                	js     8023e8 <dup+0xeb>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] & PTE_USER)) < 0)
  8023a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8023ac:	89 c2                	mov    %eax,%edx
  8023ae:	c1 ea 0c             	shr    $0xc,%edx
  8023b1:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8023b8:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  8023be:	89 54 24 10          	mov    %edx,0x10(%esp)
  8023c2:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8023c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023cd:	00 
  8023ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023d2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8023d9:	e8 3a f4 ff ff       	call   801818 <sys_page_map>
  8023de:	89 c3                	mov    %eax,%ebx
  8023e0:	85 c0                	test   %eax,%eax
  8023e2:	78 04                	js     8023e8 <dup+0xeb>
  8023e4:	89 fb                	mov    %edi,%ebx
  8023e6:	eb 23                	jmp    80240b <dup+0x10e>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8023e8:	89 74 24 04          	mov    %esi,0x4(%esp)
  8023ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8023f3:	e8 c2 f3 ff ff       	call   8017ba <sys_page_unmap>
	sys_page_unmap(0, nva);
  8023f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8023fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802406:	e8 af f3 ff ff       	call   8017ba <sys_page_unmap>
	return r;
}
  80240b:	89 d8                	mov    %ebx,%eax
  80240d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802410:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802413:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802416:	89 ec                	mov    %ebp,%esp
  802418:	5d                   	pop    %ebp
  802419:	c3                   	ret    
	...

0080241c <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80241c:	55                   	push   %ebp
  80241d:	89 e5                	mov    %esp,%ebp
  80241f:	53                   	push   %ebx
  802420:	83 ec 14             	sub    $0x14,%esp
  802423:	89 d3                	mov    %edx,%ebx
	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", env->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(envs[1].env_id, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  802425:	8b 15 c8 00 c0 ee    	mov    0xeec000c8,%edx
  80242b:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802432:	00 
  802433:	c7 44 24 08 00 50 81 	movl   $0x815000,0x8(%esp)
  80243a:	00 
  80243b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80243f:	89 14 24             	mov    %edx,(%esp)
  802442:	e8 e9 f8 ff ff       	call   801d30 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  802447:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80244e:	00 
  80244f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802453:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80245a:	e8 33 f9 ff ff       	call   801d92 <ipc_recv>
}
  80245f:	83 c4 14             	add    $0x14,%esp
  802462:	5b                   	pop    %ebx
  802463:	5d                   	pop    %ebp
  802464:	c3                   	ret    

00802465 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802465:	55                   	push   %ebp
  802466:	89 e5                	mov    %esp,%ebp
  802468:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80246b:	8b 45 08             	mov    0x8(%ebp),%eax
  80246e:	8b 40 0c             	mov    0xc(%eax),%eax
  802471:	a3 00 50 81 00       	mov    %eax,0x815000
	fsipcbuf.set_size.req_size = newsize;
  802476:	8b 45 0c             	mov    0xc(%ebp),%eax
  802479:	a3 04 50 81 00       	mov    %eax,0x815004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80247e:	ba 00 00 00 00       	mov    $0x0,%edx
  802483:	b8 02 00 00 00       	mov    $0x2,%eax
  802488:	e8 8f ff ff ff       	call   80241c <fsipc>
}
  80248d:	c9                   	leave  
  80248e:	c3                   	ret    

0080248f <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  80248f:	55                   	push   %ebp
  802490:	89 e5                	mov    %esp,%ebp
  802492:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  802495:	ba 00 00 00 00       	mov    $0x0,%edx
  80249a:	b8 08 00 00 00       	mov    $0x8,%eax
  80249f:	e8 78 ff ff ff       	call   80241c <fsipc>
}
  8024a4:	c9                   	leave  
  8024a5:	c3                   	ret    

008024a6 <devfile_stat>:
}


static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8024a6:	55                   	push   %ebp
  8024a7:	89 e5                	mov    %esp,%ebp
  8024a9:	53                   	push   %ebx
  8024aa:	83 ec 14             	sub    $0x14,%esp
  8024ad:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8024b0:	8b 45 08             	mov    0x8(%ebp),%eax
  8024b3:	8b 40 0c             	mov    0xc(%eax),%eax
  8024b6:	a3 00 50 81 00       	mov    %eax,0x815000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8024bb:	ba 00 00 00 00       	mov    $0x0,%edx
  8024c0:	b8 05 00 00 00       	mov    $0x5,%eax
  8024c5:	e8 52 ff ff ff       	call   80241c <fsipc>
  8024ca:	85 c0                	test   %eax,%eax
  8024cc:	78 2b                	js     8024f9 <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8024ce:	c7 44 24 04 00 50 81 	movl   $0x815000,0x4(%esp)
  8024d5:	00 
  8024d6:	89 1c 24             	mov    %ebx,(%esp)
  8024d9:	e8 3c ec ff ff       	call   80111a <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8024de:	a1 80 50 81 00       	mov    0x815080,%eax
  8024e3:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8024e9:	a1 84 50 81 00       	mov    0x815084,%eax
  8024ee:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  8024f4:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  8024f9:	83 c4 14             	add    $0x14,%esp
  8024fc:	5b                   	pop    %ebx
  8024fd:	5d                   	pop    %ebp
  8024fe:	c3                   	ret    

008024ff <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  8024ff:	55                   	push   %ebp
  802500:	89 e5                	mov    %esp,%ebp
  802502:	83 ec 18             	sub    $0x18,%esp
        memset(&fsipcbuf,0,PGSIZE);
  802505:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80250c:	00 
  80250d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802514:	00 
  802515:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  80251c:	e8 55 ed ff ff       	call   801276 <memset>
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  802521:	8b 45 08             	mov    0x8(%ebp),%eax
  802524:	8b 40 0c             	mov    0xc(%eax),%eax
  802527:	a3 00 50 81 00       	mov    %eax,0x815000
	return fsipc(FSREQ_FLUSH, NULL);
  80252c:	ba 00 00 00 00       	mov    $0x0,%edx
  802531:	b8 06 00 00 00       	mov    $0x6,%eax
  802536:	e8 e1 fe ff ff       	call   80241c <fsipc>
}
  80253b:	c9                   	leave  
  80253c:	c3                   	ret    

0080253d <devfile_write>:
//	 The number of bytes successfully written.
//	 < 0 on error.

static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80253d:	55                   	push   %ebp
  80253e:	89 e5                	mov    %esp,%ebp
  802540:	83 ec 18             	sub    $0x18,%esp
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
       int r=0;
      uint32_t numberOfBytes;
      memset(&fsipcbuf,0,PGSIZE);
  802543:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80254a:	00 
  80254b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802552:	00 
  802553:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  80255a:	e8 17 ed ff ff       	call   801276 <memset>
  80255f:	8b 45 10             	mov    0x10(%ebp),%eax
  802562:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  802567:	76 05                	jbe    80256e <devfile_write+0x31>
  802569:	b8 f8 0f 00 00       	mov    $0xff8,%eax
       if(n > PGSIZE - (sizeof(int) + sizeof(size_t)))
          numberOfBytes=PGSIZE - (sizeof(int) + sizeof(size_t));
       else
          numberOfBytes = n; 
        fsipcbuf.write.req_fileid = fd->fd_file.id;
  80256e:	8b 55 08             	mov    0x8(%ebp),%edx
  802571:	8b 52 0c             	mov    0xc(%edx),%edx
  802574:	89 15 00 50 81 00    	mov    %edx,0x815000
        fsipcbuf.write.req_n = numberOfBytes;
  80257a:	a3 04 50 81 00       	mov    %eax,0x815004
     //  strcpy(fsipcbuf.write.req_buf,buf);   
     memmove(fsipcbuf.write.req_buf,buf,numberOfBytes);        
  80257f:	89 44 24 08          	mov    %eax,0x8(%esp)
  802583:	8b 45 0c             	mov    0xc(%ebp),%eax
  802586:	89 44 24 04          	mov    %eax,0x4(%esp)
  80258a:	c7 04 24 08 50 81 00 	movl   $0x815008,(%esp)
  802591:	e8 3f ed ff ff       	call   8012d5 <memmove>
       if((r = fsipc(FSREQ_WRITE,NULL))<0)
  802596:	ba 00 00 00 00       	mov    $0x0,%edx
  80259b:	b8 04 00 00 00       	mov    $0x4,%eax
  8025a0:	e8 77 fe ff ff       	call   80241c <fsipc>
              return r;
        return r;
}
  8025a5:	c9                   	leave  
  8025a6:	c3                   	ret    

008025a7 <devfile_read>:
// 	The number of bytes successfully read.
// 	< 0 on error.

static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  8025a7:	55                   	push   %ebp
  8025a8:	89 e5                	mov    %esp,%ebp
  8025aa:	53                   	push   %ebx
  8025ab:	83 ec 14             	sub    $0x14,%esp
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
        int r=0;
        memset(&fsipcbuf,0,PGSIZE); 
  8025ae:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  8025b5:	00 
  8025b6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8025bd:	00 
  8025be:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  8025c5:	e8 ac ec ff ff       	call   801276 <memset>
        fsipcbuf.read.req_fileid = fd->fd_file.id;
  8025ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8025cd:	8b 40 0c             	mov    0xc(%eax),%eax
  8025d0:	a3 00 50 81 00       	mov    %eax,0x815000
        fsipcbuf.read.req_n = n;
  8025d5:	8b 45 10             	mov    0x10(%ebp),%eax
  8025d8:	a3 04 50 81 00       	mov    %eax,0x815004
       
        if((r = fsipc(FSREQ_READ,NULL))<0)
  8025dd:	ba 00 00 00 00       	mov    $0x0,%edx
  8025e2:	b8 03 00 00 00       	mov    $0x3,%eax
  8025e7:	e8 30 fe ff ff       	call   80241c <fsipc>
  8025ec:	89 c3                	mov    %eax,%ebx
  8025ee:	85 c0                	test   %eax,%eax
  8025f0:	78 17                	js     802609 <devfile_read+0x62>
              return r;
        //strcpy(buf,fsipcbuf.readRet.ret_buf);
     // cprintf("\n---->n=%d r=%d buffersize=%d\n",n,r,sizeof(buf));
        memmove(buf,fsipcbuf.readRet.ret_buf,r);
  8025f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8025f6:	c7 44 24 04 00 50 81 	movl   $0x815000,0x4(%esp)
  8025fd:	00 
  8025fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  802601:	89 04 24             	mov    %eax,(%esp)
  802604:	e8 cc ec ff ff       	call   8012d5 <memmove>
        return r;
}
  802609:	89 d8                	mov    %ebx,%eax
  80260b:	83 c4 14             	add    $0x14,%esp
  80260e:	5b                   	pop    %ebx
  80260f:	5d                   	pop    %ebp
  802610:	c3                   	ret    

00802611 <remove>:
}

// Delete a file
int
remove(const char *path)
{
  802611:	55                   	push   %ebp
  802612:	89 e5                	mov    %esp,%ebp
  802614:	53                   	push   %ebx
  802615:	83 ec 14             	sub    $0x14,%esp
  802618:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  80261b:	89 1c 24             	mov    %ebx,(%esp)
  80261e:	e8 ad ea ff ff       	call   8010d0 <strlen>
  802623:	89 c2                	mov    %eax,%edx
  802625:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  80262a:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  802630:	7f 1f                	jg     802651 <remove+0x40>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  802632:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802636:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  80263d:	e8 d8 ea ff ff       	call   80111a <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  802642:	ba 00 00 00 00       	mov    $0x0,%edx
  802647:	b8 07 00 00 00       	mov    $0x7,%eax
  80264c:	e8 cb fd ff ff       	call   80241c <fsipc>
}
  802651:	83 c4 14             	add    $0x14,%esp
  802654:	5b                   	pop    %ebx
  802655:	5d                   	pop    %ebp
  802656:	c3                   	ret    

00802657 <open>:
// 	< 0 for other errors.


int
open(const char *path, int mode)
{
  802657:	55                   	push   %ebp
  802658:	89 e5                	mov    %esp,%ebp
  80265a:	56                   	push   %esi
  80265b:	53                   	push   %ebx
  80265c:	83 ec 20             	sub    $0x20,%esp
  80265f:	8b 75 08             	mov    0x8(%ebp),%esi

	// LAB 5: Your code here.

      struct Fd *fd;
       int r;        
 memset(&fsipcbuf,0,PGSIZE);
  802662:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  802669:	00 
  80266a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802671:	00 
  802672:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  802679:	e8 f8 eb ff ff       	call   801276 <memset>
    if(strlen(path)>=MAXPATHLEN)
  80267e:	89 34 24             	mov    %esi,(%esp)
  802681:	e8 4a ea ff ff       	call   8010d0 <strlen>
  802686:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  80268b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  802690:	0f 8f 84 00 00 00    	jg     80271a <open+0xc3>
            return -E_BAD_PATH;

       if((r = fd_alloc(&fd))<0)
  802696:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802699:	89 04 24             	mov    %eax,(%esp)
  80269c:	e8 8a f7 ff ff       	call   801e2b <fd_alloc>
  8026a1:	89 c3                	mov    %eax,%ebx
  8026a3:	85 c0                	test   %eax,%eax
  8026a5:	78 73                	js     80271a <open+0xc3>
           return r;
 int i=0;
  while(path[i]!='\0')
  8026a7:	0f b6 06             	movzbl (%esi),%eax
  8026aa:	84 c0                	test   %al,%al
  8026ac:	74 20                	je     8026ce <open+0x77>
  8026ae:	89 f3                	mov    %esi,%ebx
    {
       cprintf("%c",path[i]);
  8026b0:	0f be c0             	movsbl %al,%eax
  8026b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026b7:	c7 04 24 b0 2b 81 00 	movl   $0x812bb0,(%esp)
  8026be:	e8 7e e3 ff ff       	call   800a41 <cprintf>
            return -E_BAD_PATH;

       if((r = fd_alloc(&fd))<0)
           return r;
 int i=0;
  while(path[i]!='\0')
  8026c3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8026c7:	83 c3 01             	add    $0x1,%ebx
  8026ca:	84 c0                	test   %al,%al
  8026cc:	75 e2                	jne    8026b0 <open+0x59>
    {
       cprintf("%c",path[i]);
        i++;
    }
    strcpy(fsipcbuf.open.req_path, path);
  8026ce:	89 74 24 04          	mov    %esi,0x4(%esp)
  8026d2:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  8026d9:	e8 3c ea ff ff       	call   80111a <strcpy>
    fsipcbuf.open.req_omode = mode;
  8026de:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026e1:	a3 00 54 81 00       	mov    %eax,0x815400
    if((r = fsipc(FSREQ_OPEN,fd))<0)
  8026e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8026e9:	b8 01 00 00 00       	mov    $0x1,%eax
  8026ee:	e8 29 fd ff ff       	call   80241c <fsipc>
  8026f3:	89 c3                	mov    %eax,%ebx
  8026f5:	85 c0                	test   %eax,%eax
  8026f7:	79 15                	jns    80270e <open+0xb7>
        {
            fd_close(fd,1);
  8026f9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  802700:	00 
  802701:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802704:	89 04 24             	mov    %eax,(%esp)
  802707:	e8 d3 fa ff ff       	call   8021df <fd_close>
             return r;
  80270c:	eb 0c                	jmp    80271a <open+0xc3>
        }
     int fdindex = ((uint32_t)fd-0xD0000000)/PGSIZE;       
  80270e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802711:	81 c3 00 00 00 30    	add    $0x30000000,%ebx
  802717:	c1 eb 0c             	shr    $0xc,%ebx
             return fdindex; 

	//panic("open not implemented");
}
  80271a:	89 d8                	mov    %ebx,%eax
  80271c:	83 c4 20             	add    $0x20,%esp
  80271f:	5b                   	pop    %ebx
  802720:	5e                   	pop    %esi
  802721:	5d                   	pop    %ebp
  802722:	c3                   	ret    
	...

00802730 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802730:	55                   	push   %ebp
  802731:	89 e5                	mov    %esp,%ebp
  802733:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  802736:	c7 44 24 04 b3 2b 81 	movl   $0x812bb3,0x4(%esp)
  80273d:	00 
  80273e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802741:	89 04 24             	mov    %eax,(%esp)
  802744:	e8 d1 e9 ff ff       	call   80111a <strcpy>
	return 0;
}
  802749:	b8 00 00 00 00       	mov    $0x0,%eax
  80274e:	c9                   	leave  
  80274f:	c3                   	ret    

00802750 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  802750:	55                   	push   %ebp
  802751:	89 e5                	mov    %esp,%ebp
  802753:	83 ec 18             	sub    $0x18,%esp
	return nsipc_close(fd->fd_sock.sockid);
  802756:	8b 45 08             	mov    0x8(%ebp),%eax
  802759:	8b 40 0c             	mov    0xc(%eax),%eax
  80275c:	89 04 24             	mov    %eax,(%esp)
  80275f:	e8 9e 02 00 00       	call   802a02 <nsipc_close>
}
  802764:	c9                   	leave  
  802765:	c3                   	ret    

00802766 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  802766:	55                   	push   %ebp
  802767:	89 e5                	mov    %esp,%ebp
  802769:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80276c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802773:	00 
  802774:	8b 45 10             	mov    0x10(%ebp),%eax
  802777:	89 44 24 08          	mov    %eax,0x8(%esp)
  80277b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80277e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802782:	8b 45 08             	mov    0x8(%ebp),%eax
  802785:	8b 40 0c             	mov    0xc(%eax),%eax
  802788:	89 04 24             	mov    %eax,(%esp)
  80278b:	e8 ae 02 00 00       	call   802a3e <nsipc_send>
}
  802790:	c9                   	leave  
  802791:	c3                   	ret    

00802792 <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  802792:	55                   	push   %ebp
  802793:	89 e5                	mov    %esp,%ebp
  802795:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  802798:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80279f:	00 
  8027a0:	8b 45 10             	mov    0x10(%ebp),%eax
  8027a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8027a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8027b1:	8b 40 0c             	mov    0xc(%eax),%eax
  8027b4:	89 04 24             	mov    %eax,(%esp)
  8027b7:	e8 f5 02 00 00       	call   802ab1 <nsipc_recv>
}
  8027bc:	c9                   	leave  
  8027bd:	c3                   	ret    

008027be <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  8027be:	55                   	push   %ebp
  8027bf:	89 e5                	mov    %esp,%ebp
  8027c1:	56                   	push   %esi
  8027c2:	53                   	push   %ebx
  8027c3:	83 ec 20             	sub    $0x20,%esp
  8027c6:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  8027c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8027cb:	89 04 24             	mov    %eax,(%esp)
  8027ce:	e8 58 f6 ff ff       	call   801e2b <fd_alloc>
  8027d3:	89 c3                	mov    %eax,%ebx
  8027d5:	85 c0                	test   %eax,%eax
  8027d7:	78 21                	js     8027fa <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U)) < 0) {
  8027d9:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  8027e0:	00 
  8027e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8027e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027e8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8027ef:	e8 82 f0 ff ff       	call   801876 <sys_page_alloc>
  8027f4:	89 c3                	mov    %eax,%ebx
alloc_sockfd(int sockid)
{
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  8027f6:	85 c0                	test   %eax,%eax
  8027f8:	79 0a                	jns    802804 <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U)) < 0) {
		nsipc_close(sockid);
  8027fa:	89 34 24             	mov    %esi,(%esp)
  8027fd:	e8 00 02 00 00       	call   802a02 <nsipc_close>
		return r;
  802802:	eb 28                	jmp    80282c <alloc_sockfd+0x6e>
	}

	sfd->fd_dev_id = devsock.dev_id;
  802804:	8b 15 20 80 81 00    	mov    0x818020,%edx
  80280a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80280d:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80280f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802812:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  802819:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80281c:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80281f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802822:	89 04 24             	mov    %eax,(%esp)
  802825:	e8 d6 f5 ff ff       	call   801e00 <fd2num>
  80282a:	89 c3                	mov    %eax,%ebx
}
  80282c:	89 d8                	mov    %ebx,%eax
  80282e:	83 c4 20             	add    $0x20,%esp
  802831:	5b                   	pop    %ebx
  802832:	5e                   	pop    %esi
  802833:	5d                   	pop    %ebp
  802834:	c3                   	ret    

00802835 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  802835:	55                   	push   %ebp
  802836:	89 e5                	mov    %esp,%ebp
  802838:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80283b:	8b 45 10             	mov    0x10(%ebp),%eax
  80283e:	89 44 24 08          	mov    %eax,0x8(%esp)
  802842:	8b 45 0c             	mov    0xc(%ebp),%eax
  802845:	89 44 24 04          	mov    %eax,0x4(%esp)
  802849:	8b 45 08             	mov    0x8(%ebp),%eax
  80284c:	89 04 24             	mov    %eax,(%esp)
  80284f:	e8 62 01 00 00       	call   8029b6 <nsipc_socket>
  802854:	85 c0                	test   %eax,%eax
  802856:	78 05                	js     80285d <socket+0x28>
		return r;
	return alloc_sockfd(r);
  802858:	e8 61 ff ff ff       	call   8027be <alloc_sockfd>
}
  80285d:	c9                   	leave  
  80285e:	66 90                	xchg   %ax,%ax
  802860:	c3                   	ret    

00802861 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  802861:	55                   	push   %ebp
  802862:	89 e5                	mov    %esp,%ebp
  802864:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  802867:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80286a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80286e:	89 04 24             	mov    %eax,(%esp)
  802871:	e8 27 f6 ff ff       	call   801e9d <fd_lookup>
  802876:	85 c0                	test   %eax,%eax
  802878:	78 15                	js     80288f <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80287a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80287d:	8b 0a                	mov    (%edx),%ecx
  80287f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802884:	3b 0d 20 80 81 00    	cmp    0x818020,%ecx
  80288a:	75 03                	jne    80288f <fd2sockid+0x2e>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80288c:	8b 42 0c             	mov    0xc(%edx),%eax
}
  80288f:	c9                   	leave  
  802890:	c3                   	ret    

00802891 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  802891:	55                   	push   %ebp
  802892:	89 e5                	mov    %esp,%ebp
  802894:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802897:	8b 45 08             	mov    0x8(%ebp),%eax
  80289a:	e8 c2 ff ff ff       	call   802861 <fd2sockid>
  80289f:	85 c0                	test   %eax,%eax
  8028a1:	78 0f                	js     8028b2 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  8028a3:	8b 55 0c             	mov    0xc(%ebp),%edx
  8028a6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028aa:	89 04 24             	mov    %eax,(%esp)
  8028ad:	e8 2e 01 00 00       	call   8029e0 <nsipc_listen>
}
  8028b2:	c9                   	leave  
  8028b3:	c3                   	ret    

008028b4 <connect>:
	return nsipc_close(fd->fd_sock.sockid);
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8028b4:	55                   	push   %ebp
  8028b5:	89 e5                	mov    %esp,%ebp
  8028b7:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8028ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8028bd:	e8 9f ff ff ff       	call   802861 <fd2sockid>
  8028c2:	85 c0                	test   %eax,%eax
  8028c4:	78 16                	js     8028dc <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  8028c6:	8b 55 10             	mov    0x10(%ebp),%edx
  8028c9:	89 54 24 08          	mov    %edx,0x8(%esp)
  8028cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  8028d0:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028d4:	89 04 24             	mov    %eax,(%esp)
  8028d7:	e8 55 02 00 00       	call   802b31 <nsipc_connect>
}
  8028dc:	c9                   	leave  
  8028dd:	c3                   	ret    

008028de <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  8028de:	55                   	push   %ebp
  8028df:	89 e5                	mov    %esp,%ebp
  8028e1:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8028e4:	8b 45 08             	mov    0x8(%ebp),%eax
  8028e7:	e8 75 ff ff ff       	call   802861 <fd2sockid>
  8028ec:	85 c0                	test   %eax,%eax
  8028ee:	78 0f                	js     8028ff <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  8028f0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8028f3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028f7:	89 04 24             	mov    %eax,(%esp)
  8028fa:	e8 1d 01 00 00       	call   802a1c <nsipc_shutdown>
}
  8028ff:	c9                   	leave  
  802900:	c3                   	ret    

00802901 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802901:	55                   	push   %ebp
  802902:	89 e5                	mov    %esp,%ebp
  802904:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802907:	8b 45 08             	mov    0x8(%ebp),%eax
  80290a:	e8 52 ff ff ff       	call   802861 <fd2sockid>
  80290f:	85 c0                	test   %eax,%eax
  802911:	78 16                	js     802929 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  802913:	8b 55 10             	mov    0x10(%ebp),%edx
  802916:	89 54 24 08          	mov    %edx,0x8(%esp)
  80291a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80291d:	89 54 24 04          	mov    %edx,0x4(%esp)
  802921:	89 04 24             	mov    %eax,(%esp)
  802924:	e8 47 02 00 00       	call   802b70 <nsipc_bind>
}
  802929:	c9                   	leave  
  80292a:	c3                   	ret    

0080292b <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80292b:	55                   	push   %ebp
  80292c:	89 e5                	mov    %esp,%ebp
  80292e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802931:	8b 45 08             	mov    0x8(%ebp),%eax
  802934:	e8 28 ff ff ff       	call   802861 <fd2sockid>
  802939:	85 c0                	test   %eax,%eax
  80293b:	78 1f                	js     80295c <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80293d:	8b 55 10             	mov    0x10(%ebp),%edx
  802940:	89 54 24 08          	mov    %edx,0x8(%esp)
  802944:	8b 55 0c             	mov    0xc(%ebp),%edx
  802947:	89 54 24 04          	mov    %edx,0x4(%esp)
  80294b:	89 04 24             	mov    %eax,(%esp)
  80294e:	e8 5c 02 00 00       	call   802baf <nsipc_accept>
  802953:	85 c0                	test   %eax,%eax
  802955:	78 05                	js     80295c <accept+0x31>
		return r;
	return alloc_sockfd(r);
  802957:	e8 62 fe ff ff       	call   8027be <alloc_sockfd>
}
  80295c:	c9                   	leave  
  80295d:	8d 76 00             	lea    0x0(%esi),%esi
  802960:	c3                   	ret    
	...

00802970 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  802970:	55                   	push   %ebp
  802971:	89 e5                	mov    %esp,%ebp
  802973:	83 ec 18             	sub    $0x18,%esp
	if (debug)
		cprintf("[%08x] nsipc %d\n", env->env_id, type);

	ipc_send(envs[2].env_id, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  802976:	8b 15 44 01 c0 ee    	mov    0xeec00144,%edx
  80297c:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802983:	00 
  802984:	c7 44 24 08 00 70 81 	movl   $0x817000,0x8(%esp)
  80298b:	00 
  80298c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802990:	89 14 24             	mov    %edx,(%esp)
  802993:	e8 98 f3 ff ff       	call   801d30 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  802998:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80299f:	00 
  8029a0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8029a7:	00 
  8029a8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8029af:	e8 de f3 ff ff       	call   801d92 <ipc_recv>
}
  8029b4:	c9                   	leave  
  8029b5:	c3                   	ret    

008029b6 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  8029b6:	55                   	push   %ebp
  8029b7:	89 e5                	mov    %esp,%ebp
  8029b9:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8029bc:	8b 45 08             	mov    0x8(%ebp),%eax
  8029bf:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.socket.req_type = type;
  8029c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8029c7:	a3 04 70 81 00       	mov    %eax,0x817004
	nsipcbuf.socket.req_protocol = protocol;
  8029cc:	8b 45 10             	mov    0x10(%ebp),%eax
  8029cf:	a3 08 70 81 00       	mov    %eax,0x817008
	return nsipc(NSREQ_SOCKET);
  8029d4:	b8 09 00 00 00       	mov    $0x9,%eax
  8029d9:	e8 92 ff ff ff       	call   802970 <nsipc>
}
  8029de:	c9                   	leave  
  8029df:	c3                   	ret    

008029e0 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  8029e0:	55                   	push   %ebp
  8029e1:	89 e5                	mov    %esp,%ebp
  8029e3:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8029e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8029e9:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.listen.req_backlog = backlog;
  8029ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  8029f1:	a3 04 70 81 00       	mov    %eax,0x817004
	return nsipc(NSREQ_LISTEN);
  8029f6:	b8 06 00 00 00       	mov    $0x6,%eax
  8029fb:	e8 70 ff ff ff       	call   802970 <nsipc>
}
  802a00:	c9                   	leave  
  802a01:	c3                   	ret    

00802a02 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802a02:	55                   	push   %ebp
  802a03:	89 e5                	mov    %esp,%ebp
  802a05:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802a08:	8b 45 08             	mov    0x8(%ebp),%eax
  802a0b:	a3 00 70 81 00       	mov    %eax,0x817000
	return nsipc(NSREQ_CLOSE);
  802a10:	b8 04 00 00 00       	mov    $0x4,%eax
  802a15:	e8 56 ff ff ff       	call   802970 <nsipc>
}
  802a1a:	c9                   	leave  
  802a1b:	c3                   	ret    

00802a1c <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802a1c:	55                   	push   %ebp
  802a1d:	89 e5                	mov    %esp,%ebp
  802a1f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802a22:	8b 45 08             	mov    0x8(%ebp),%eax
  802a25:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.shutdown.req_how = how;
  802a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a2d:	a3 04 70 81 00       	mov    %eax,0x817004
	return nsipc(NSREQ_SHUTDOWN);
  802a32:	b8 03 00 00 00       	mov    $0x3,%eax
  802a37:	e8 34 ff ff ff       	call   802970 <nsipc>
}
  802a3c:	c9                   	leave  
  802a3d:	c3                   	ret    

00802a3e <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802a3e:	55                   	push   %ebp
  802a3f:	89 e5                	mov    %esp,%ebp
  802a41:	53                   	push   %ebx
  802a42:	83 ec 14             	sub    $0x14,%esp
  802a45:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802a48:	8b 45 08             	mov    0x8(%ebp),%eax
  802a4b:	a3 00 70 81 00       	mov    %eax,0x817000
	assert(size < 1600);
  802a50:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802a56:	7e 24                	jle    802a7c <nsipc_send+0x3e>
  802a58:	c7 44 24 0c bf 2b 81 	movl   $0x812bbf,0xc(%esp)
  802a5f:	00 
  802a60:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  802a67:	00 
  802a68:	c7 44 24 04 66 00 00 	movl   $0x66,0x4(%esp)
  802a6f:	00 
  802a70:	c7 04 24 e0 2b 81 00 	movl   $0x812be0,(%esp)
  802a77:	e8 00 df ff ff       	call   80097c <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802a7c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802a80:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a83:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a87:	c7 04 24 0c 70 81 00 	movl   $0x81700c,(%esp)
  802a8e:	e8 42 e8 ff ff       	call   8012d5 <memmove>
	nsipcbuf.send.req_size = size;
  802a93:	89 1d 04 70 81 00    	mov    %ebx,0x817004
	nsipcbuf.send.req_flags = flags;
  802a99:	8b 45 14             	mov    0x14(%ebp),%eax
  802a9c:	a3 08 70 81 00       	mov    %eax,0x817008
	return nsipc(NSREQ_SEND);
  802aa1:	b8 08 00 00 00       	mov    $0x8,%eax
  802aa6:	e8 c5 fe ff ff       	call   802970 <nsipc>
}
  802aab:	83 c4 14             	add    $0x14,%esp
  802aae:	5b                   	pop    %ebx
  802aaf:	5d                   	pop    %ebp
  802ab0:	c3                   	ret    

00802ab1 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  802ab1:	55                   	push   %ebp
  802ab2:	89 e5                	mov    %esp,%ebp
  802ab4:	56                   	push   %esi
  802ab5:	53                   	push   %ebx
  802ab6:	83 ec 10             	sub    $0x10,%esp
  802ab9:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  802abc:	8b 45 08             	mov    0x8(%ebp),%eax
  802abf:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.recv.req_len = len;
  802ac4:	89 35 04 70 81 00    	mov    %esi,0x817004
	nsipcbuf.recv.req_flags = flags;
  802aca:	8b 45 14             	mov    0x14(%ebp),%eax
  802acd:	a3 08 70 81 00       	mov    %eax,0x817008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  802ad2:	b8 07 00 00 00       	mov    $0x7,%eax
  802ad7:	e8 94 fe ff ff       	call   802970 <nsipc>
  802adc:	89 c3                	mov    %eax,%ebx
  802ade:	85 c0                	test   %eax,%eax
  802ae0:	78 46                	js     802b28 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  802ae2:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  802ae7:	7f 04                	jg     802aed <nsipc_recv+0x3c>
  802ae9:	39 c6                	cmp    %eax,%esi
  802aeb:	7d 24                	jge    802b11 <nsipc_recv+0x60>
  802aed:	c7 44 24 0c ec 2b 81 	movl   $0x812bec,0xc(%esp)
  802af4:	00 
  802af5:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  802afc:	00 
  802afd:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
  802b04:	00 
  802b05:	c7 04 24 e0 2b 81 00 	movl   $0x812be0,(%esp)
  802b0c:	e8 6b de ff ff       	call   80097c <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  802b11:	89 44 24 08          	mov    %eax,0x8(%esp)
  802b15:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  802b1c:	00 
  802b1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b20:	89 04 24             	mov    %eax,(%esp)
  802b23:	e8 ad e7 ff ff       	call   8012d5 <memmove>
	}

	return r;
}
  802b28:	89 d8                	mov    %ebx,%eax
  802b2a:	83 c4 10             	add    $0x10,%esp
  802b2d:	5b                   	pop    %ebx
  802b2e:	5e                   	pop    %esi
  802b2f:	5d                   	pop    %ebp
  802b30:	c3                   	ret    

00802b31 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802b31:	55                   	push   %ebp
  802b32:	89 e5                	mov    %esp,%ebp
  802b34:	53                   	push   %ebx
  802b35:	83 ec 14             	sub    $0x14,%esp
  802b38:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  802b3b:	8b 45 08             	mov    0x8(%ebp),%eax
  802b3e:	a3 00 70 81 00       	mov    %eax,0x817000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  802b43:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802b47:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b4a:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b4e:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  802b55:	e8 7b e7 ff ff       	call   8012d5 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  802b5a:	89 1d 14 70 81 00    	mov    %ebx,0x817014
	return nsipc(NSREQ_CONNECT);
  802b60:	b8 05 00 00 00       	mov    $0x5,%eax
  802b65:	e8 06 fe ff ff       	call   802970 <nsipc>
}
  802b6a:	83 c4 14             	add    $0x14,%esp
  802b6d:	5b                   	pop    %ebx
  802b6e:	5d                   	pop    %ebp
  802b6f:	c3                   	ret    

00802b70 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802b70:	55                   	push   %ebp
  802b71:	89 e5                	mov    %esp,%ebp
  802b73:	53                   	push   %ebx
  802b74:	83 ec 14             	sub    $0x14,%esp
  802b77:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  802b7a:	8b 45 08             	mov    0x8(%ebp),%eax
  802b7d:	a3 00 70 81 00       	mov    %eax,0x817000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  802b82:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802b86:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b89:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b8d:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  802b94:	e8 3c e7 ff ff       	call   8012d5 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  802b99:	89 1d 14 70 81 00    	mov    %ebx,0x817014
	return nsipc(NSREQ_BIND);
  802b9f:	b8 02 00 00 00       	mov    $0x2,%eax
  802ba4:	e8 c7 fd ff ff       	call   802970 <nsipc>
}
  802ba9:	83 c4 14             	add    $0x14,%esp
  802bac:	5b                   	pop    %ebx
  802bad:	5d                   	pop    %ebp
  802bae:	c3                   	ret    

00802baf <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802baf:	55                   	push   %ebp
  802bb0:	89 e5                	mov    %esp,%ebp
  802bb2:	83 ec 18             	sub    $0x18,%esp
  802bb5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802bb8:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int r;
	
	nsipcbuf.accept.req_s = s;
  802bbb:	8b 45 08             	mov    0x8(%ebp),%eax
  802bbe:	a3 00 70 81 00       	mov    %eax,0x817000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  802bc3:	b8 01 00 00 00       	mov    $0x1,%eax
  802bc8:	e8 a3 fd ff ff       	call   802970 <nsipc>
  802bcd:	89 c3                	mov    %eax,%ebx
  802bcf:	85 c0                	test   %eax,%eax
  802bd1:	78 25                	js     802bf8 <nsipc_accept+0x49>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  802bd3:	be 10 70 81 00       	mov    $0x817010,%esi
  802bd8:	8b 06                	mov    (%esi),%eax
  802bda:	89 44 24 08          	mov    %eax,0x8(%esp)
  802bde:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  802be5:	00 
  802be6:	8b 45 0c             	mov    0xc(%ebp),%eax
  802be9:	89 04 24             	mov    %eax,(%esp)
  802bec:	e8 e4 e6 ff ff       	call   8012d5 <memmove>
		*addrlen = ret->ret_addrlen;
  802bf1:	8b 16                	mov    (%esi),%edx
  802bf3:	8b 45 10             	mov    0x10(%ebp),%eax
  802bf6:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  802bf8:	89 d8                	mov    %ebx,%eax
  802bfa:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802bfd:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802c00:	89 ec                	mov    %ebp,%esp
  802c02:	5d                   	pop    %ebp
  802c03:	c3                   	ret    
	...

00802c10 <free>:
	return v;
}

void
free(void *v)
{
  802c10:	55                   	push   %ebp
  802c11:	89 e5                	mov    %esp,%ebp
  802c13:	56                   	push   %esi
  802c14:	53                   	push   %ebx
  802c15:	83 ec 10             	sub    $0x10,%esp
  802c18:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802c1b:	85 db                	test   %ebx,%ebx
  802c1d:	0f 84 b9 00 00 00    	je     802cdc <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802c23:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802c29:	76 08                	jbe    802c33 <free+0x23>
  802c2b:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802c31:	76 24                	jbe    802c57 <free+0x47>
  802c33:	c7 44 24 0c 04 2c 81 	movl   $0x812c04,0xc(%esp)
  802c3a:	00 
  802c3b:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  802c42:	00 
  802c43:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  802c4a:	00 
  802c4b:	c7 04 24 32 2c 81 00 	movl   $0x812c32,(%esp)
  802c52:	e8 25 dd ff ff       	call   80097c <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802c57:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[VPN(c)] & PTE_CONTINUED) {
  802c5d:	be 00 00 40 ef       	mov    $0xef400000,%esi
  802c62:	eb 4a                	jmp    802cae <free+0x9e>
		sys_page_unmap(0, c);
  802c64:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802c68:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802c6f:	e8 46 eb ff ff       	call   8017ba <sys_page_unmap>
		c += PGSIZE;
  802c74:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  802c7a:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802c80:	76 08                	jbe    802c8a <free+0x7a>
  802c82:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802c88:	76 24                	jbe    802cae <free+0x9e>
  802c8a:	c7 44 24 0c 3f 2c 81 	movl   $0x812c3f,0xc(%esp)
  802c91:	00 
  802c92:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  802c99:	00 
  802c9a:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  802ca1:	00 
  802ca2:	c7 04 24 32 2c 81 00 	movl   $0x812c32,(%esp)
  802ca9:	e8 ce dc ff ff       	call   80097c <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[VPN(c)] & PTE_CONTINUED) {
  802cae:	89 d8                	mov    %ebx,%eax
  802cb0:	c1 e8 0c             	shr    $0xc,%eax
  802cb3:	8b 04 86             	mov    (%esi,%eax,4),%eax
  802cb6:	f6 c4 04             	test   $0x4,%ah
  802cb9:	75 a9                	jne    802c64 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  802cbb:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  802cc1:	8b 02                	mov    (%edx),%eax
  802cc3:	83 e8 01             	sub    $0x1,%eax
  802cc6:	89 02                	mov    %eax,(%edx)
  802cc8:	85 c0                	test   %eax,%eax
  802cca:	75 10                	jne    802cdc <free+0xcc>
		sys_page_unmap(0, c);	
  802ccc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802cd0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802cd7:	e8 de ea ff ff       	call   8017ba <sys_page_unmap>
}
  802cdc:	83 c4 10             	add    $0x10,%esp
  802cdf:	5b                   	pop    %ebx
  802ce0:	5e                   	pop    %esi
  802ce1:	5d                   	pop    %ebp
  802ce2:	c3                   	ret    

00802ce3 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  802ce3:	55                   	push   %ebp
  802ce4:	89 e5                	mov    %esp,%ebp
  802ce6:	57                   	push   %edi
  802ce7:	56                   	push   %esi
  802ce8:	53                   	push   %ebx
  802ce9:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  802cec:	83 3d 14 84 81 00 00 	cmpl   $0x0,0x818414
  802cf3:	75 0a                	jne    802cff <malloc+0x1c>
		mptr = mbegin;
  802cf5:	c7 05 14 84 81 00 00 	movl   $0x8000000,0x818414
  802cfc:	00 00 08 

	n = ROUNDUP(n, 4);
  802cff:	8b 45 08             	mov    0x8(%ebp),%eax
  802d02:	83 c0 03             	add    $0x3,%eax
  802d05:	83 e0 fc             	and    $0xfffffffc,%eax
  802d08:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (n >= MAXMALLOC)
  802d0b:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  802d10:	0f 87 97 01 00 00    	ja     802ead <malloc+0x1ca>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  802d16:	a1 14 84 81 00       	mov    0x818414,%eax
  802d1b:	89 c2                	mov    %eax,%edx
  802d1d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  802d22:	74 4d                	je     802d71 <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802d24:	89 c3                	mov    %eax,%ebx
  802d26:	c1 eb 0c             	shr    $0xc,%ebx
  802d29:	8b 75 d8             	mov    -0x28(%ebp),%esi
  802d2c:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  802d30:	c1 e9 0c             	shr    $0xc,%ecx
  802d33:	39 cb                	cmp    %ecx,%ebx
  802d35:	75 1e                	jne    802d55 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802d37:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  802d3d:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  802d43:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  802d47:	8d 14 30             	lea    (%eax,%esi,1),%edx
  802d4a:	89 15 14 84 81 00    	mov    %edx,0x818414
			return v;
  802d50:	e9 5d 01 00 00       	jmp    802eb2 <malloc+0x1cf>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802d55:	89 04 24             	mov    %eax,(%esp)
  802d58:	e8 b3 fe ff ff       	call   802c10 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802d5d:	a1 14 84 81 00       	mov    0x818414,%eax
  802d62:	05 00 10 00 00       	add    $0x1000,%eax
  802d67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802d6c:	a3 14 84 81 00       	mov    %eax,0x818414
  802d71:	8b 3d 14 84 81 00    	mov    0x818414,%edi
  802d77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802d7e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  802d81:	83 c0 04             	add    $0x4,%eax
  802d84:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802d87:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  802d8c:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802d91:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  802d94:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  802d97:	8d 0c 0f             	lea    (%edi,%ecx,1),%ecx
  802d9a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802d9d:	39 cf                	cmp    %ecx,%edi
  802d9f:	0f 83 d7 00 00 00    	jae    802e7c <malloc+0x199>
		if (va >= (uintptr_t) mend
  802da5:	89 f8                	mov    %edi,%eax
  802da7:	81 ff ff ff ff 0f    	cmp    $0xfffffff,%edi
  802dad:	76 09                	jbe    802db8 <malloc+0xd5>
  802daf:	eb 38                	jmp    802de9 <malloc+0x106>
  802db1:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  802db6:	77 31                	ja     802de9 <malloc+0x106>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802db8:	89 c2                	mov    %eax,%edx
  802dba:	c1 ea 16             	shr    $0x16,%edx
  802dbd:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802dc0:	f6 c2 01             	test   $0x1,%dl
  802dc3:	74 0d                	je     802dd2 <malloc+0xef>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802dc5:	89 c2                	mov    %eax,%edx
  802dc7:	c1 ea 0c             	shr    $0xc,%edx
  802dca:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802dcd:	f6 c2 01             	test   $0x1,%dl
  802dd0:	75 17                	jne    802de9 <malloc+0x106>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802dd2:	05 00 10 00 00       	add    $0x1000,%eax
  802dd7:	39 c8                	cmp    %ecx,%eax
  802dd9:	72 d6                	jb     802db1 <malloc+0xce>
  802ddb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802dde:	89 35 14 84 81 00    	mov    %esi,0x818414
  802de4:	e9 9b 00 00 00       	jmp    802e84 <malloc+0x1a1>
  802de9:	81 c7 00 10 00 00    	add    $0x1000,%edi
  802def:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  802df5:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  802dfb:	75 9d                	jne    802d9a <malloc+0xb7>
			mptr = mbegin;
			if (++nwrap == 2)
  802dfd:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  802e01:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  802e05:	74 07                	je     802e0e <malloc+0x12b>
  802e07:	bf 00 00 00 08       	mov    $0x8000000,%edi
  802e0c:	eb 83                	jmp    802d91 <malloc+0xae>
  802e0e:	c7 05 14 84 81 00 00 	movl   $0x8000000,0x818414
  802e15:	00 00 08 
  802e18:	b8 00 00 00 00       	mov    $0x0,%eax
  802e1d:	e9 90 00 00 00       	jmp    802eb2 <malloc+0x1cf>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802e22:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  802e28:	39 fe                	cmp    %edi,%esi
  802e2a:	19 c0                	sbb    %eax,%eax
  802e2c:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802e31:	83 c8 07             	or     $0x7,%eax
  802e34:	89 44 24 08          	mov    %eax,0x8(%esp)
  802e38:	03 15 14 84 81 00    	add    0x818414,%edx
  802e3e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802e42:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802e49:	e8 28 ea ff ff       	call   801876 <sys_page_alloc>
  802e4e:	85 c0                	test   %eax,%eax
  802e50:	78 04                	js     802e56 <malloc+0x173>
  802e52:	89 f3                	mov    %esi,%ebx
  802e54:	eb 36                	jmp    802e8c <malloc+0x1a9>
			for (; i >= 0; i -= PGSIZE)
  802e56:	85 db                	test   %ebx,%ebx
  802e58:	78 53                	js     802ead <malloc+0x1ca>
				sys_page_unmap(0, mptr + i);
  802e5a:	89 d8                	mov    %ebx,%eax
  802e5c:	03 05 14 84 81 00    	add    0x818414,%eax
  802e62:	89 44 24 04          	mov    %eax,0x4(%esp)
  802e66:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802e6d:	e8 48 e9 ff ff       	call   8017ba <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  802e72:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  802e78:	79 e0                	jns    802e5a <malloc+0x177>
  802e7a:	eb 31                	jmp    802ead <malloc+0x1ca>
  802e7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802e7f:	a3 14 84 81 00       	mov    %eax,0x818414
  802e84:	bb 00 00 00 00       	mov    $0x0,%ebx
  802e89:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  802e8c:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802e8e:	39 fb                	cmp    %edi,%ebx
  802e90:	72 90                	jb     802e22 <malloc+0x13f>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802e92:	a1 14 84 81 00       	mov    0x818414,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802e97:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  802e9e:	00 
	v = mptr;
	mptr += n;
  802e9f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  802ea2:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  802ea5:	89 15 14 84 81 00    	mov    %edx,0x818414
	return v;
  802eab:	eb 05                	jmp    802eb2 <malloc+0x1cf>
  802ead:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802eb2:	83 c4 3c             	add    $0x3c,%esp
  802eb5:	5b                   	pop    %ebx
  802eb6:	5e                   	pop    %esi
  802eb7:	5f                   	pop    %edi
  802eb8:	5d                   	pop    %ebp
  802eb9:	c3                   	ret    
  802eba:	00 00                	add    %al,(%eax)
  802ebc:	00 00                	add    %al,(%eax)
	...

00802ec0 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  802ec0:	55                   	push   %ebp
  802ec1:	89 e5                	mov    %esp,%ebp
  802ec3:	83 ec 18             	sub    $0x18,%esp
  802ec6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802ec9:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802ecc:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  802ecf:	8b 45 08             	mov    0x8(%ebp),%eax
  802ed2:	89 04 24             	mov    %eax,(%esp)
  802ed5:	e8 36 ef ff ff       	call   801e10 <fd2data>
  802eda:	89 c3                	mov    %eax,%ebx
	strcpy(stat->st_name, "<pipe>");
  802edc:	c7 44 24 04 57 2c 81 	movl   $0x812c57,0x4(%esp)
  802ee3:	00 
  802ee4:	89 34 24             	mov    %esi,(%esp)
  802ee7:	e8 2e e2 ff ff       	call   80111a <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  802eec:	8b 43 04             	mov    0x4(%ebx),%eax
  802eef:	2b 03                	sub    (%ebx),%eax
  802ef1:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	stat->st_isdir = 0;
  802ef7:	c7 86 84 00 00 00 00 	movl   $0x0,0x84(%esi)
  802efe:	00 00 00 
	stat->st_dev = &devpipe;
  802f01:	c7 86 88 00 00 00 3c 	movl   $0x81803c,0x88(%esi)
  802f08:	80 81 00 
	return 0;
}
  802f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  802f10:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802f13:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802f16:	89 ec                	mov    %ebp,%esp
  802f18:	5d                   	pop    %ebp
  802f19:	c3                   	ret    

00802f1a <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  802f1a:	55                   	push   %ebp
  802f1b:	89 e5                	mov    %esp,%ebp
  802f1d:	53                   	push   %ebx
  802f1e:	83 ec 14             	sub    $0x14,%esp
  802f21:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  802f24:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802f28:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f2f:	e8 86 e8 ff ff       	call   8017ba <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  802f34:	89 1c 24             	mov    %ebx,(%esp)
  802f37:	e8 d4 ee ff ff       	call   801e10 <fd2data>
  802f3c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802f40:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f47:	e8 6e e8 ff ff       	call   8017ba <sys_page_unmap>
}
  802f4c:	83 c4 14             	add    $0x14,%esp
  802f4f:	5b                   	pop    %ebx
  802f50:	5d                   	pop    %ebp
  802f51:	c3                   	ret    

00802f52 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  802f52:	55                   	push   %ebp
  802f53:	89 e5                	mov    %esp,%ebp
  802f55:	57                   	push   %edi
  802f56:	56                   	push   %esi
  802f57:	53                   	push   %ebx
  802f58:	83 ec 2c             	sub    $0x2c,%esp
  802f5b:	89 c7                	mov    %eax,%edi
  802f5d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = env->env_runs;
  802f60:	a1 f4 e5 b3 00       	mov    0xb3e5f4,%eax
  802f65:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  802f68:	89 3c 24             	mov    %edi,(%esp)
  802f6b:	e8 7c 05 00 00       	call   8034ec <pageref>
  802f70:	89 c6                	mov    %eax,%esi
  802f72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802f75:	89 04 24             	mov    %eax,(%esp)
  802f78:	e8 6f 05 00 00       	call   8034ec <pageref>
  802f7d:	39 c6                	cmp    %eax,%esi
  802f7f:	0f 94 c0             	sete   %al
  802f82:	0f b6 c0             	movzbl %al,%eax
		nn = env->env_runs;
  802f85:	8b 15 f4 e5 b3 00    	mov    0xb3e5f4,%edx
  802f8b:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  802f8e:	39 cb                	cmp    %ecx,%ebx
  802f90:	75 08                	jne    802f9a <_pipeisclosed+0x48>
			return ret;
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, env->env_runs, ret);
	}
}
  802f92:	83 c4 2c             	add    $0x2c,%esp
  802f95:	5b                   	pop    %ebx
  802f96:	5e                   	pop    %esi
  802f97:	5f                   	pop    %edi
  802f98:	5d                   	pop    %ebp
  802f99:	c3                   	ret    
		n = env->env_runs;
		ret = pageref(fd) == pageref(p);
		nn = env->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
  802f9a:	83 f8 01             	cmp    $0x1,%eax
  802f9d:	75 c1                	jne    802f60 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, env->env_runs, ret);
  802f9f:	8b 52 58             	mov    0x58(%edx),%edx
  802fa2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802fa6:	89 54 24 08          	mov    %edx,0x8(%esp)
  802faa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802fae:	c7 04 24 5e 2c 81 00 	movl   $0x812c5e,(%esp)
  802fb5:	e8 87 da ff ff       	call   800a41 <cprintf>
  802fba:	eb a4                	jmp    802f60 <_pipeisclosed+0xe>

00802fbc <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  802fbc:	55                   	push   %ebp
  802fbd:	89 e5                	mov    %esp,%ebp
  802fbf:	57                   	push   %edi
  802fc0:	56                   	push   %esi
  802fc1:	53                   	push   %ebx
  802fc2:	83 ec 1c             	sub    $0x1c,%esp
  802fc5:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  802fc8:	89 34 24             	mov    %esi,(%esp)
  802fcb:	e8 40 ee ff ff       	call   801e10 <fd2data>
  802fd0:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  802fd2:	bf 00 00 00 00       	mov    $0x0,%edi
  802fd7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  802fdb:	75 54                	jne    803031 <devpipe_write+0x75>
  802fdd:	eb 60                	jmp    80303f <devpipe_write+0x83>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  802fdf:	89 da                	mov    %ebx,%edx
  802fe1:	89 f0                	mov    %esi,%eax
  802fe3:	e8 6a ff ff ff       	call   802f52 <_pipeisclosed>
  802fe8:	85 c0                	test   %eax,%eax
  802fea:	74 07                	je     802ff3 <devpipe_write+0x37>
  802fec:	b8 00 00 00 00       	mov    $0x0,%eax
  802ff1:	eb 53                	jmp    803046 <devpipe_write+0x8a>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  802ff3:	90                   	nop
  802ff4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  802ff8:	e8 d8 e8 ff ff       	call   8018d5 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  802ffd:	8b 43 04             	mov    0x4(%ebx),%eax
  803000:	8b 13                	mov    (%ebx),%edx
  803002:	83 c2 20             	add    $0x20,%edx
  803005:	39 d0                	cmp    %edx,%eax
  803007:	73 d6                	jae    802fdf <devpipe_write+0x23>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  803009:	89 c2                	mov    %eax,%edx
  80300b:	c1 fa 1f             	sar    $0x1f,%edx
  80300e:	c1 ea 1b             	shr    $0x1b,%edx
  803011:	01 d0                	add    %edx,%eax
  803013:	83 e0 1f             	and    $0x1f,%eax
  803016:	29 d0                	sub    %edx,%eax
  803018:	89 c2                	mov    %eax,%edx
  80301a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80301d:	0f b6 04 39          	movzbl (%ecx,%edi,1),%eax
  803021:	88 44 13 08          	mov    %al,0x8(%ebx,%edx,1)
		p->p_wpos++;
  803025:	83 43 04 01          	addl   $0x1,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  803029:	83 c7 01             	add    $0x1,%edi
  80302c:	39 7d 10             	cmp    %edi,0x10(%ebp)
  80302f:	76 13                	jbe    803044 <devpipe_write+0x88>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  803031:	8b 43 04             	mov    0x4(%ebx),%eax
  803034:	8b 13                	mov    (%ebx),%edx
  803036:	83 c2 20             	add    $0x20,%edx
  803039:	39 d0                	cmp    %edx,%eax
  80303b:	73 a2                	jae    802fdf <devpipe_write+0x23>
  80303d:	eb ca                	jmp    803009 <devpipe_write+0x4d>
  80303f:	bf 00 00 00 00       	mov    $0x0,%edi
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}
	
	return i;
  803044:	89 f8                	mov    %edi,%eax
}
  803046:	83 c4 1c             	add    $0x1c,%esp
  803049:	5b                   	pop    %ebx
  80304a:	5e                   	pop    %esi
  80304b:	5f                   	pop    %edi
  80304c:	5d                   	pop    %ebp
  80304d:	c3                   	ret    

0080304e <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  80304e:	55                   	push   %ebp
  80304f:	89 e5                	mov    %esp,%ebp
  803051:	83 ec 28             	sub    $0x28,%esp
  803054:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803057:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80305a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80305d:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  803060:	89 3c 24             	mov    %edi,(%esp)
  803063:	e8 a8 ed ff ff       	call   801e10 <fd2data>
  803068:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  80306a:	be 00 00 00 00       	mov    $0x0,%esi
  80306f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803073:	75 4c                	jne    8030c1 <devpipe_read+0x73>
  803075:	eb 5b                	jmp    8030d2 <devpipe_read+0x84>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
				return i;
  803077:	89 f0                	mov    %esi,%eax
  803079:	eb 5e                	jmp    8030d9 <devpipe_read+0x8b>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  80307b:	89 da                	mov    %ebx,%edx
  80307d:	89 f8                	mov    %edi,%eax
  80307f:	90                   	nop
  803080:	e8 cd fe ff ff       	call   802f52 <_pipeisclosed>
  803085:	85 c0                	test   %eax,%eax
  803087:	74 07                	je     803090 <devpipe_read+0x42>
  803089:	b8 00 00 00 00       	mov    $0x0,%eax
  80308e:	eb 49                	jmp    8030d9 <devpipe_read+0x8b>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  803090:	e8 40 e8 ff ff       	call   8018d5 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  803095:	8b 03                	mov    (%ebx),%eax
  803097:	3b 43 04             	cmp    0x4(%ebx),%eax
  80309a:	74 df                	je     80307b <devpipe_read+0x2d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  80309c:	89 c2                	mov    %eax,%edx
  80309e:	c1 fa 1f             	sar    $0x1f,%edx
  8030a1:	c1 ea 1b             	shr    $0x1b,%edx
  8030a4:	01 d0                	add    %edx,%eax
  8030a6:	83 e0 1f             	and    $0x1f,%eax
  8030a9:	29 d0                	sub    %edx,%eax
  8030ab:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  8030b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8030b3:	88 04 32             	mov    %al,(%edx,%esi,1)
		p->p_rpos++;
  8030b6:	83 03 01             	addl   $0x1,(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8030b9:	83 c6 01             	add    $0x1,%esi
  8030bc:	39 75 10             	cmp    %esi,0x10(%ebp)
  8030bf:	76 16                	jbe    8030d7 <devpipe_read+0x89>
		while (p->p_rpos == p->p_wpos) {
  8030c1:	8b 03                	mov    (%ebx),%eax
  8030c3:	3b 43 04             	cmp    0x4(%ebx),%eax
  8030c6:	75 d4                	jne    80309c <devpipe_read+0x4e>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  8030c8:	85 f6                	test   %esi,%esi
  8030ca:	75 ab                	jne    803077 <devpipe_read+0x29>
  8030cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8030d0:	eb a9                	jmp    80307b <devpipe_read+0x2d>
  8030d2:	be 00 00 00 00       	mov    $0x0,%esi
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8030d7:	89 f0                	mov    %esi,%eax
}
  8030d9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8030dc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8030df:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8030e2:	89 ec                	mov    %ebp,%esp
  8030e4:	5d                   	pop    %ebp
  8030e5:	c3                   	ret    

008030e6 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  8030e6:	55                   	push   %ebp
  8030e7:	89 e5                	mov    %esp,%ebp
  8030e9:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8030ec:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8030ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  8030f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8030f6:	89 04 24             	mov    %eax,(%esp)
  8030f9:	e8 9f ed ff ff       	call   801e9d <fd_lookup>
  8030fe:	85 c0                	test   %eax,%eax
  803100:	78 15                	js     803117 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  803102:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803105:	89 04 24             	mov    %eax,(%esp)
  803108:	e8 03 ed ff ff       	call   801e10 <fd2data>
	return _pipeisclosed(fd, p);
  80310d:	89 c2                	mov    %eax,%edx
  80310f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803112:	e8 3b fe ff ff       	call   802f52 <_pipeisclosed>
}
  803117:	c9                   	leave  
  803118:	c3                   	ret    

00803119 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  803119:	55                   	push   %ebp
  80311a:	89 e5                	mov    %esp,%ebp
  80311c:	83 ec 48             	sub    $0x48,%esp
  80311f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803122:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803125:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803128:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  80312b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80312e:	89 04 24             	mov    %eax,(%esp)
  803131:	e8 f5 ec ff ff       	call   801e2b <fd_alloc>
  803136:	89 c3                	mov    %eax,%ebx
  803138:	85 c0                	test   %eax,%eax
  80313a:	0f 88 42 01 00 00    	js     803282 <pipe+0x169>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  803140:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803147:	00 
  803148:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80314b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80314f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803156:	e8 1b e7 ff ff       	call   801876 <sys_page_alloc>
  80315b:	89 c3                	mov    %eax,%ebx
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  80315d:	85 c0                	test   %eax,%eax
  80315f:	0f 88 1d 01 00 00    	js     803282 <pipe+0x169>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  803165:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803168:	89 04 24             	mov    %eax,(%esp)
  80316b:	e8 bb ec ff ff       	call   801e2b <fd_alloc>
  803170:	89 c3                	mov    %eax,%ebx
  803172:	85 c0                	test   %eax,%eax
  803174:	0f 88 f5 00 00 00    	js     80326f <pipe+0x156>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80317a:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803181:	00 
  803182:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803185:	89 44 24 04          	mov    %eax,0x4(%esp)
  803189:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803190:	e8 e1 e6 ff ff       	call   801876 <sys_page_alloc>
  803195:	89 c3                	mov    %eax,%ebx
	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  803197:	85 c0                	test   %eax,%eax
  803199:	0f 88 d0 00 00 00    	js     80326f <pipe+0x156>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  80319f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8031a2:	89 04 24             	mov    %eax,(%esp)
  8031a5:	e8 66 ec ff ff       	call   801e10 <fd2data>
  8031aa:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8031ac:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8031b3:	00 
  8031b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8031b8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031bf:	e8 b2 e6 ff ff       	call   801876 <sys_page_alloc>
  8031c4:	89 c3                	mov    %eax,%ebx
  8031c6:	85 c0                	test   %eax,%eax
  8031c8:	0f 88 8e 00 00 00    	js     80325c <pipe+0x143>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8031ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8031d1:	89 04 24             	mov    %eax,(%esp)
  8031d4:	e8 37 ec ff ff       	call   801e10 <fd2data>
  8031d9:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  8031e0:	00 
  8031e1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8031e5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8031ec:	00 
  8031ed:	89 74 24 04          	mov    %esi,0x4(%esp)
  8031f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031f8:	e8 1b e6 ff ff       	call   801818 <sys_page_map>
  8031fd:	89 c3                	mov    %eax,%ebx
  8031ff:	85 c0                	test   %eax,%eax
  803201:	78 49                	js     80324c <pipe+0x133>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  803203:	b8 3c 80 81 00       	mov    $0x81803c,%eax
  803208:	8b 08                	mov    (%eax),%ecx
  80320a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80320d:	89 0a                	mov    %ecx,(%edx)
	fd0->fd_omode = O_RDONLY;
  80320f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803212:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

	fd1->fd_dev_id = devpipe.dev_id;
  803219:	8b 10                	mov    (%eax),%edx
  80321b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80321e:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  803220:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803223:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", env->env_id, vpt[VPN(va)]);

	pfd[0] = fd2num(fd0);
  80322a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80322d:	89 04 24             	mov    %eax,(%esp)
  803230:	e8 cb eb ff ff       	call   801e00 <fd2num>
  803235:	89 07                	mov    %eax,(%edi)
	pfd[1] = fd2num(fd1);
  803237:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80323a:	89 04 24             	mov    %eax,(%esp)
  80323d:	e8 be eb ff ff       	call   801e00 <fd2num>
  803242:	89 47 04             	mov    %eax,0x4(%edi)
  803245:	bb 00 00 00 00       	mov    $0x0,%ebx
	return 0;
  80324a:	eb 36                	jmp    803282 <pipe+0x169>

    err3:
	sys_page_unmap(0, va);
  80324c:	89 74 24 04          	mov    %esi,0x4(%esp)
  803250:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803257:	e8 5e e5 ff ff       	call   8017ba <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  80325c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80325f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803263:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80326a:	e8 4b e5 ff ff       	call   8017ba <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  80326f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803272:	89 44 24 04          	mov    %eax,0x4(%esp)
  803276:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80327d:	e8 38 e5 ff ff       	call   8017ba <sys_page_unmap>
    err:
	return r;
}
  803282:	89 d8                	mov    %ebx,%eax
  803284:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803287:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80328a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80328d:	89 ec                	mov    %ebp,%esp
  80328f:	5d                   	pop    %ebp
  803290:	c3                   	ret    
	...

008032a0 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  8032a0:	55                   	push   %ebp
  8032a1:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  8032a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8032a8:	5d                   	pop    %ebp
  8032a9:	c3                   	ret    

008032aa <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  8032aa:	55                   	push   %ebp
  8032ab:	89 e5                	mov    %esp,%ebp
  8032ad:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  8032b0:	c7 44 24 04 76 2c 81 	movl   $0x812c76,0x4(%esp)
  8032b7:	00 
  8032b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8032bb:	89 04 24             	mov    %eax,(%esp)
  8032be:	e8 57 de ff ff       	call   80111a <strcpy>
	return 0;
}
  8032c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8032c8:	c9                   	leave  
  8032c9:	c3                   	ret    

008032ca <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8032ca:	55                   	push   %ebp
  8032cb:	89 e5                	mov    %esp,%ebp
  8032cd:	57                   	push   %edi
  8032ce:	56                   	push   %esi
  8032cf:	53                   	push   %ebx
  8032d0:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8032d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8032db:	be 00 00 00 00       	mov    $0x0,%esi
  8032e0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8032e4:	74 3f                	je     803325 <devcons_write+0x5b>
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8032e6:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  8032ec:	8b 55 10             	mov    0x10(%ebp),%edx
  8032ef:	29 c2                	sub    %eax,%edx
  8032f1:	89 d3                	mov    %edx,%ebx
		if (m > sizeof(buf) - 1)
  8032f3:	83 fa 7f             	cmp    $0x7f,%edx
  8032f6:	76 05                	jbe    8032fd <devcons_write+0x33>
  8032f8:	bb 7f 00 00 00       	mov    $0x7f,%ebx
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8032fd:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  803301:	03 45 0c             	add    0xc(%ebp),%eax
  803304:	89 44 24 04          	mov    %eax,0x4(%esp)
  803308:	89 3c 24             	mov    %edi,(%esp)
  80330b:	e8 c5 df ff ff       	call   8012d5 <memmove>
		sys_cputs(buf, m);
  803310:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803314:	89 3c 24             	mov    %edi,(%esp)
  803317:	e8 f4 e1 ff ff       	call   801510 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  80331c:	01 de                	add    %ebx,%esi
  80331e:	89 f0                	mov    %esi,%eax
  803320:	3b 75 10             	cmp    0x10(%ebp),%esi
  803323:	72 c7                	jb     8032ec <devcons_write+0x22>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  803325:	89 f0                	mov    %esi,%eax
  803327:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  80332d:	5b                   	pop    %ebx
  80332e:	5e                   	pop    %esi
  80332f:	5f                   	pop    %edi
  803330:	5d                   	pop    %ebp
  803331:	c3                   	ret    

00803332 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  803332:	55                   	push   %ebp
  803333:	89 e5                	mov    %esp,%ebp
  803335:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  803338:	8b 45 08             	mov    0x8(%ebp),%eax
  80333b:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  80333e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  803345:	00 
  803346:	8d 45 f7             	lea    -0x9(%ebp),%eax
  803349:	89 04 24             	mov    %eax,(%esp)
  80334c:	e8 bf e1 ff ff       	call   801510 <sys_cputs>
}
  803351:	c9                   	leave  
  803352:	c3                   	ret    

00803353 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  803353:	55                   	push   %ebp
  803354:	89 e5                	mov    %esp,%ebp
  803356:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
  803359:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80335d:	75 07                	jne    803366 <devcons_read+0x13>
  80335f:	eb 28                	jmp    803389 <devcons_read+0x36>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  803361:	e8 6f e5 ff ff       	call   8018d5 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  803366:	66 90                	xchg   %ax,%ax
  803368:	e8 6f e1 ff ff       	call   8014dc <sys_cgetc>
  80336d:	85 c0                	test   %eax,%eax
  80336f:	90                   	nop
  803370:	74 ef                	je     803361 <devcons_read+0xe>
  803372:	89 c2                	mov    %eax,%edx
		sys_yield();
	if (c < 0)
  803374:	85 c0                	test   %eax,%eax
  803376:	78 16                	js     80338e <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  803378:	83 f8 04             	cmp    $0x4,%eax
  80337b:	74 0c                	je     803389 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  80337d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803380:	88 10                	mov    %dl,(%eax)
  803382:	b8 01 00 00 00       	mov    $0x1,%eax
	return 1;
  803387:	eb 05                	jmp    80338e <devcons_read+0x3b>
  803389:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80338e:	c9                   	leave  
  80338f:	c3                   	ret    

00803390 <opencons>:
	return fd->fd_dev_id == devcons.dev_id;
}

int
opencons(void)
{
  803390:	55                   	push   %ebp
  803391:	89 e5                	mov    %esp,%ebp
  803393:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  803396:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803399:	89 04 24             	mov    %eax,(%esp)
  80339c:	e8 8a ea ff ff       	call   801e2b <fd_alloc>
  8033a1:	85 c0                	test   %eax,%eax
  8033a3:	78 3f                	js     8033e4 <opencons+0x54>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8033a5:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8033ac:	00 
  8033ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8033b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8033bb:	e8 b6 e4 ff ff       	call   801876 <sys_page_alloc>
  8033c0:	85 c0                	test   %eax,%eax
  8033c2:	78 20                	js     8033e4 <opencons+0x54>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  8033c4:	8b 15 58 80 81 00    	mov    0x818058,%edx
  8033ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8033cd:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8033cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8033d2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8033d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8033dc:	89 04 24             	mov    %eax,(%esp)
  8033df:	e8 1c ea ff ff       	call   801e00 <fd2num>
}
  8033e4:	c9                   	leave  
  8033e5:	c3                   	ret    

008033e6 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8033e6:	55                   	push   %ebp
  8033e7:	89 e5                	mov    %esp,%ebp
  8033e9:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8033ec:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8033ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8033f6:	89 04 24             	mov    %eax,(%esp)
  8033f9:	e8 9f ea ff ff       	call   801e9d <fd_lookup>
  8033fe:	85 c0                	test   %eax,%eax
  803400:	78 11                	js     803413 <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  803402:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803405:	8b 00                	mov    (%eax),%eax
  803407:	3b 05 58 80 81 00    	cmp    0x818058,%eax
  80340d:	0f 94 c0             	sete   %al
  803410:	0f b6 c0             	movzbl %al,%eax
}
  803413:	c9                   	leave  
  803414:	c3                   	ret    

00803415 <getchar>:
	sys_cputs(&c, 1);
}

int
getchar(void)
{
  803415:	55                   	push   %ebp
  803416:	89 e5                	mov    %esp,%ebp
  803418:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  80341b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803422:	00 
  803423:	8d 45 f7             	lea    -0x9(%ebp),%eax
  803426:	89 44 24 04          	mov    %eax,0x4(%esp)
  80342a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803431:	e8 c8 ec ff ff       	call   8020fe <read>
	if (r < 0)
  803436:	85 c0                	test   %eax,%eax
  803438:	78 0f                	js     803449 <getchar+0x34>
		return r;
	if (r < 1)
  80343a:	85 c0                	test   %eax,%eax
  80343c:	7f 07                	jg     803445 <getchar+0x30>
  80343e:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  803443:	eb 04                	jmp    803449 <getchar+0x34>
		return -E_EOF;
	return c;
  803445:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  803449:	c9                   	leave  
  80344a:	c3                   	ret    
	...

0080344c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  80344c:	55                   	push   %ebp
  80344d:	89 e5                	mov    %esp,%ebp
  80344f:	53                   	push   %ebx
  803450:	83 ec 14             	sub    $0x14,%esp
  803453:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
    // cprintf("\nhere outside loading creating page\n");

	if (_pgfault_handler == 0) {
  803456:	83 3d fc e5 b3 00 00 	cmpl   $0x0,0xb3e5fc
  80345d:	75 58                	jne    8034b7 <set_pgfault_handler+0x6b>
		// First time through!
		// LAB 4: Your code here.
           //cprintf("\nhere inside loading creating page\n");    
          if(sys_page_alloc(sys_getenvid(),(void *)UXSTACKTOP-PGSIZE,PTE_P|PTE_U|PTE_W)<0)
  80345f:	e8 a5 e4 ff ff       	call   801909 <sys_getenvid>
  803464:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80346b:	00 
  80346c:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  803473:	ee 
  803474:	89 04 24             	mov    %eax,(%esp)
  803477:	e8 fa e3 ff ff       	call   801876 <sys_page_alloc>
  80347c:	85 c0                	test   %eax,%eax
  80347e:	79 1c                	jns    80349c <set_pgfault_handler+0x50>
                          panic("Cant allocate Page");                    
  803480:	c7 44 24 08 8c 2a 81 	movl   $0x812a8c,0x8(%esp)
  803487:	00 
  803488:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80348f:	00 
  803490:	c7 04 24 82 2c 81 00 	movl   $0x812c82,(%esp)
  803497:	e8 e0 d4 ff ff       	call   80097c <_panic>
                _pgfault_handler=handler;
  80349c:	89 1d fc e5 b3 00    	mov    %ebx,0xb3e5fc
//entry point _pgfault_handler not pointed to by the kernel bcz after the execution is complete control needs to be returned back to execute the rest...so upcall is there         
             sys_env_set_pgfault_upcall(sys_getenvid(),_pgfault_upcall);
  8034a2:	e8 62 e4 ff ff       	call   801909 <sys_getenvid>
  8034a7:	c7 44 24 04 c4 34 80 	movl   $0x8034c4,0x4(%esp)
  8034ae:	00 
  8034af:	89 04 24             	mov    %eax,(%esp)
  8034b2:	e8 e9 e1 ff ff       	call   8016a0 <sys_env_set_pgfault_upcall>

	// Save handler pointer for assembly to call.
 //     if(sys_page_alloc(0,(void *)UXSTACKTOP-PGSIZE,PTE_P|PTE_U|PTE_W)<0)
   //                       panic("Cant allocate Page");

	_pgfault_handler = handler;
  8034b7:	89 1d fc e5 b3 00    	mov    %ebx,0xb3e5fc
}
  8034bd:	83 c4 14             	add    $0x14,%esp
  8034c0:	5b                   	pop    %ebx
  8034c1:	5d                   	pop    %ebp
  8034c2:	c3                   	ret    
	...

008034c4 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8034c4:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8034c5:	a1 fc e5 b3 00       	mov    0xb3e5fc,%eax
	call *%eax
  8034ca:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8034cc:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
           addl $8,%esp
  8034cf:	83 c4 08             	add    $0x8,%esp

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
            movl  32(%esp),%ebx
  8034d2:	8b 5c 24 20          	mov    0x20(%esp),%ebx
            movl  40(%esp),%eax
  8034d6:	8b 44 24 28          	mov    0x28(%esp),%eax
            subl  $4,%eax
  8034da:	83 e8 04             	sub    $0x4,%eax
            movl  %eax,40(%esp)
  8034dd:	89 44 24 28          	mov    %eax,0x28(%esp)
            movl  %ebx,(%eax)
  8034e1:	89 18                	mov    %ebx,(%eax)
            popal
  8034e3:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
            
            add $4,%esp            
  8034e4:	83 c4 04             	add    $0x4,%esp
            popfl
  8034e7:	9d                   	popf   
             
           popl %esp
  8034e8:	5c                   	pop    %esp
	// LAB 4: Your code here.
           

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
           ret
  8034e9:	c3                   	ret    
	...

008034ec <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  8034ec:	55                   	push   %ebp
  8034ed:	89 e5                	mov    %esp,%ebp
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  8034ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8034f2:	89 c2                	mov    %eax,%edx
  8034f4:	c1 ea 16             	shr    $0x16,%edx
  8034f7:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8034fe:	f6 c2 01             	test   $0x1,%dl
  803501:	74 26                	je     803529 <pageref+0x3d>
		return 0;
	pte = vpt[VPN(v)];
  803503:	c1 e8 0c             	shr    $0xc,%eax
  803506:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  80350d:	a8 01                	test   $0x1,%al
  80350f:	74 18                	je     803529 <pageref+0x3d>
		return 0;
	return pages[PPN(pte)].pp_ref;
  803511:	c1 e8 0c             	shr    $0xc,%eax
  803514:	8d 14 40             	lea    (%eax,%eax,2),%edx
  803517:	c1 e2 02             	shl    $0x2,%edx
  80351a:	b8 00 00 00 ef       	mov    $0xef000000,%eax
  80351f:	0f b7 44 02 08       	movzwl 0x8(%edx,%eax,1),%eax
  803524:	0f b7 c0             	movzwl %ax,%eax
  803527:	eb 05                	jmp    80352e <pageref+0x42>
  803529:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80352e:	5d                   	pop    %ebp
  80352f:	c3                   	ret    

00803530 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  803530:	55                   	push   %ebp
  803531:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  803533:	83 f8 1f             	cmp    $0x1f,%eax
  803536:	76 11                	jbe    803549 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  803538:	c7 05 a0 e5 b3 00 09 	movl   $0x9,0xb3e5a0
  80353f:	00 00 00 
  803542:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  803547:	eb 1e                	jmp    803567 <get_socket+0x37>
  }

  sock = &sockets[s];
  803549:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80354c:	8d 04 85 20 84 81 00 	lea    0x818420(,%eax,4),%eax

  if (!sock->conn) {
  803553:	83 38 00             	cmpl   $0x0,(%eax)
  803556:	75 0f                	jne    803567 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  803558:	c7 05 a0 e5 b3 00 09 	movl   $0x9,0xb3e5a0
  80355f:	00 00 00 
  803562:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  803567:	5d                   	pop    %ebp
  803568:	c3                   	ret    

00803569 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  803569:	55                   	push   %ebp
  80356a:	89 e5                	mov    %esp,%ebp
  80356c:	56                   	push   %esi
  80356d:	53                   	push   %ebx
  80356e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  803571:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  803574:	8b 45 08             	mov    0x8(%ebp),%eax
  803577:	e8 b4 ff ff ff       	call   803530 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80357c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803581:	85 c0                	test   %eax,%eax
  803583:	0f 84 a6 00 00 00    	je     80362f <lwip_ioctl+0xc6>
    return -1;

  switch (cmd) {
  803589:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80358f:	74 59                	je     8035ea <lwip_ioctl+0x81>
  803591:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  803597:	0f 85 7c 00 00 00    	jne    803619 <lwip_ioctl+0xb0>
  case FIONREAD:
    if (!argp) {
  80359d:	85 f6                	test   %esi,%esi
  80359f:	90                   	nop
  8035a0:	75 13                	jne    8035b5 <lwip_ioctl+0x4c>
      sock_set_errno(sock, EINVAL);
  8035a2:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  8035a9:	c7 05 a0 e5 b3 00 16 	movl   $0x16,0xb3e5a0
  8035b0:	00 00 00 
      return -1;
  8035b3:	eb 7a                	jmp    80362f <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  8035b5:	8b 10                	mov    (%eax),%edx
  8035b7:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  8035bb:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8035be:	8b 48 04             	mov    0x4(%eax),%ecx
  8035c1:	85 c9                	test   %ecx,%ecx
  8035c3:	74 0d                	je     8035d2 <lwip_ioctl+0x69>
      buflen = netbuf_len(sock->lastdata);
  8035c5:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  8035c7:	66 03 51 08          	add    0x8(%ecx),%dx
  8035cb:	66 2b 50 08          	sub    0x8(%eax),%dx
  8035cf:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8035d2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8035d9:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  8035e0:	00 00 00 
  8035e3:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  8035e8:	eb 45                	jmp    80362f <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8035ea:	85 f6                	test   %esi,%esi
  8035ec:	74 0d                	je     8035fb <lwip_ioctl+0x92>
  8035ee:	83 3e 00             	cmpl   $0x0,(%esi)
  8035f1:	74 08                	je     8035fb <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  8035f3:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8035f9:	eb 06                	jmp    803601 <lwip_ioctl+0x98>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  8035fb:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  803601:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803608:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  80360f:	00 00 00 
  803612:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803617:	eb 16                	jmp    80362f <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  803619:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  803620:	c7 05 a0 e5 b3 00 26 	movl   $0x26,0xb3e5a0
  803627:	00 00 00 
  80362a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  80362f:	89 d0                	mov    %edx,%eax
  803631:	5b                   	pop    %ebx
  803632:	5e                   	pop    %esi
  803633:	5d                   	pop    %ebp
  803634:	c3                   	ret    

00803635 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  803635:	55                   	push   %ebp
  803636:	89 e5                	mov    %esp,%ebp
  803638:	83 ec 48             	sub    $0x48,%esp
  80363b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80363e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803641:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803644:	8b 75 0c             	mov    0xc(%ebp),%esi
  803647:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  80364a:	8b 45 08             	mov    0x8(%ebp),%eax
  80364d:	e8 de fe ff ff       	call   803530 <get_socket>
  803652:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  803654:	85 c0                	test   %eax,%eax
  803656:	0f 84 5a 01 00 00    	je     8037b6 <lwip_setsockopt+0x181>
    return -1;

  if (NULL == optval) {
  80365c:	85 ff                	test   %edi,%edi
  80365e:	75 1b                	jne    80367b <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  803660:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  803667:	c7 05 a0 e5 b3 00 0e 	movl   $0xe,0xb3e5a0
  80366e:	00 00 00 
  803671:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803676:	e9 47 01 00 00       	jmp    8037c2 <lwip_setsockopt+0x18d>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80367b:	83 fe 06             	cmp    $0x6,%esi
  80367e:	0f 84 8e 00 00 00    	je     803712 <lwip_setsockopt+0xdd>
  803684:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80368a:	74 11                	je     80369d <lwip_setsockopt+0x68>
  80368c:	85 f6                	test   %esi,%esi
  80368e:	66 90                	xchg   %ax,%ax
  803690:	74 66                	je     8036f8 <lwip_setsockopt+0xc3>
  803692:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803698:	e9 a8 00 00 00       	jmp    803745 <lwip_setsockopt+0x110>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80369d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8036a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8036a8:	74 1c                	je     8036c6 <lwip_setsockopt+0x91>
  8036aa:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8036b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8036b8:	74 1b                	je     8036d5 <lwip_setsockopt+0xa0>
  8036ba:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8036be:	66 90                	xchg   %ax,%ax
  8036c0:	0f 85 7f 00 00 00    	jne    803745 <lwip_setsockopt+0x110>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8036c6:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8036ca:	0f 86 ff 00 00 00    	jbe    8037cf <lwip_setsockopt+0x19a>
  8036d0:	e9 88 00 00 00       	jmp    80375d <lwip_setsockopt+0x128>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  8036d5:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8036d9:	19 c0                	sbb    %eax,%eax
  8036db:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8036de:	8b 13                	mov    (%ebx),%edx
  8036e0:	83 3a 20             	cmpl   $0x20,(%edx)
  8036e3:	0f 85 f0 00 00 00    	jne    8037d9 <lwip_setsockopt+0x1a4>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8036e9:	8b 52 08             	mov    0x8(%edx),%edx
  8036ec:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8036f0:	0f 85 e3 00 00 00    	jne    8037d9 <lwip_setsockopt+0x1a4>
  8036f6:	eb 52                	jmp    80374a <lwip_setsockopt+0x115>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8036f8:	8b 45 10             	mov    0x10(%ebp),%eax
  8036fb:	83 e8 01             	sub    $0x1,%eax
  8036fe:	83 f8 01             	cmp    $0x1,%eax
  803701:	77 42                	ja     803745 <lwip_setsockopt+0x110>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  803703:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803707:	0f 86 c2 00 00 00    	jbe    8037cf <lwip_setsockopt+0x19a>
  80370d:	8d 76 00             	lea    0x0(%esi),%esi
  803710:	eb 4b                	jmp    80375d <lwip_setsockopt+0x128>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  803712:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803716:	66 90                	xchg   %ax,%ax
  803718:	0f 86 b1 00 00 00    	jbe    8037cf <lwip_setsockopt+0x19a>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80371e:	8b 00                	mov    (%eax),%eax
  803720:	83 38 10             	cmpl   $0x10,(%eax)
  803723:	0f 85 94 00 00 00    	jne    8037bd <lwip_setsockopt+0x188>
  803729:	8b 55 10             	mov    0x10(%ebp),%edx
  80372c:	83 ea 01             	sub    $0x1,%edx
  80372f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803734:	83 fa 01             	cmp    $0x1,%edx
  803737:	77 15                	ja     80374e <lwip_setsockopt+0x119>
  803739:	8b 55 10             	mov    0x10(%ebp),%edx
  80373c:	8b 04 95 b8 2d 81 00 	mov    0x812db8(,%edx,4),%eax
  803743:	eb 05                	jmp    80374a <lwip_setsockopt+0x115>
  803745:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  80374a:	85 c0                	test   %eax,%eax
  80374c:	74 0f                	je     80375d <lwip_setsockopt+0x128>
    sock_set_errno(sock, err);
  80374e:	89 43 10             	mov    %eax,0x10(%ebx)
  803751:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  803756:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  80375b:	eb 65                	jmp    8037c2 <lwip_setsockopt+0x18d>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  80375d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  803760:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  803763:	8b 45 10             	mov    0x10(%ebp),%eax
  803766:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  803769:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  80376c:	8d 45 18             	lea    0x18(%ebp),%eax
  80376f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  803772:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  803776:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80377d:	00 
  80377e:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803781:	89 44 24 04          	mov    %eax,0x4(%esp)
  803785:	c7 04 24 d2 39 80 00 	movl   $0x8039d2,(%esp)
  80378c:	e8 05 1b 00 00       	call   805296 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803791:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803798:	00 
  803799:	8b 03                	mov    (%ebx),%eax
  80379b:	8b 40 10             	mov    0x10(%eax),%eax
  80379e:	89 04 24             	mov    %eax,(%esp)
  8037a1:	e8 10 a1 00 00       	call   80d8b6 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8037a6:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8037aa:	89 43 10             	mov    %eax,0x10(%ebx)
  8037ad:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  return err ? -1 : 0;
  8037b2:	85 c0                	test   %eax,%eax
  8037b4:	74 07                	je     8037bd <lwip_setsockopt+0x188>
  8037b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8037bb:	eb 05                	jmp    8037c2 <lwip_setsockopt+0x18d>
  8037bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8037c2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8037c5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8037c8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8037cb:	89 ec                	mov    %ebp,%esp
  8037cd:	5d                   	pop    %ebp
  8037ce:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  8037cf:	b8 16 00 00 00       	mov    $0x16,%eax
  8037d4:	e9 75 ff ff ff       	jmp    80374e <lwip_setsockopt+0x119>
  8037d9:	b8 61 00 00 00       	mov    $0x61,%eax
  8037de:	e9 6b ff ff ff       	jmp    80374e <lwip_setsockopt+0x119>

008037e3 <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  8037e3:	55                   	push   %ebp
  8037e4:	89 e5                	mov    %esp,%ebp
  8037e6:	57                   	push   %edi
  8037e7:	56                   	push   %esi
  8037e8:	53                   	push   %ebx
  8037e9:	83 ec 3c             	sub    $0x3c,%esp
  8037ec:	8b 75 0c             	mov    0xc(%ebp),%esi
  8037ef:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  8037f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8037f5:	e8 36 fd ff ff       	call   803530 <get_socket>
  8037fa:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8037fc:	85 c0                	test   %eax,%eax
  8037fe:	0f 84 a6 01 00 00    	je     8039aa <lwip_getsockopt+0x1c7>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  803804:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803808:	74 04                	je     80380e <lwip_getsockopt+0x2b>
  80380a:	85 ff                	test   %edi,%edi
  80380c:	75 1b                	jne    803829 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  80380e:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  803815:	c7 05 a0 e5 b3 00 0e 	movl   $0xe,0xb3e5a0
  80381c:	00 00 00 
  80381f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803824:	e9 8d 01 00 00       	jmp    8039b6 <lwip_getsockopt+0x1d3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  803829:	83 fe 06             	cmp    $0x6,%esi
  80382c:	0f 84 c6 00 00 00    	je     8038f8 <lwip_getsockopt+0x115>
  803832:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  803838:	74 13                	je     80384d <lwip_getsockopt+0x6a>
  80383a:	85 f6                	test   %esi,%esi
  80383c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803840:	0f 84 99 00 00 00    	je     8038df <lwip_getsockopt+0xfc>
  803846:	66 90                	xchg   %ax,%ax
  803848:	e9 e5 00 00 00       	jmp    803932 <lwip_getsockopt+0x14f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80384d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803851:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803858:	74 50                	je     8038aa <lwip_getsockopt+0xc7>
  80385a:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  80385e:	66 90                	xchg   %ax,%ax
  803860:	7f 18                	jg     80387a <lwip_getsockopt+0x97>
  803862:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  803866:	74 42                	je     8038aa <lwip_getsockopt+0xc7>
  803868:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  80386c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803870:	0f 85 bc 00 00 00    	jne    803932 <lwip_getsockopt+0x14f>
  803876:	66 90                	xchg   %ax,%ax
  803878:	eb 30                	jmp    8038aa <lwip_getsockopt+0xc7>
  80387a:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  803881:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803888:	0f 8c a4 00 00 00    	jl     803932 <lwip_getsockopt+0x14f>
  80388e:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  803895:	8d 76 00             	lea    0x0(%esi),%esi
  803898:	7e 10                	jle    8038aa <lwip_getsockopt+0xc7>
  80389a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8038a1:	0f 85 8b 00 00 00    	jne    803932 <lwip_getsockopt+0x14f>
  8038a7:	90                   	nop
  8038a8:	eb 13                	jmp    8038bd <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  8038aa:	83 3f 03             	cmpl   $0x3,(%edi)
  8038ad:	8d 76 00             	lea    0x0(%esi),%esi
  8038b0:	0f 86 08 01 00 00    	jbe    8039be <lwip_getsockopt+0x1db>
  8038b6:	66 90                	xchg   %ax,%ax
  8038b8:	e9 90 00 00 00       	jmp    80394d <lwip_getsockopt+0x16a>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  8038bd:	83 3f 04             	cmpl   $0x4,(%edi)
  8038c0:	19 c0                	sbb    %eax,%eax
  8038c2:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8038c5:	8b 13                	mov    (%ebx),%edx
  8038c7:	83 3a 20             	cmpl   $0x20,(%edx)
  8038ca:	0f 85 f8 00 00 00    	jne    8039c8 <lwip_getsockopt+0x1e5>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8038d0:	8b 52 08             	mov    0x8(%edx),%edx
  8038d3:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8038d7:	0f 85 eb 00 00 00    	jne    8039c8 <lwip_getsockopt+0x1e5>
  8038dd:	eb 58                	jmp    803937 <lwip_getsockopt+0x154>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8038df:	8b 45 10             	mov    0x10(%ebp),%eax
  8038e2:	83 e8 01             	sub    $0x1,%eax
  8038e5:	83 f8 01             	cmp    $0x1,%eax
  8038e8:	77 48                	ja     803932 <lwip_getsockopt+0x14f>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8038ea:	83 3f 03             	cmpl   $0x3,(%edi)
  8038ed:	8d 76 00             	lea    0x0(%esi),%esi
  8038f0:	0f 86 c8 00 00 00    	jbe    8039be <lwip_getsockopt+0x1db>
  8038f6:	eb 55                	jmp    80394d <lwip_getsockopt+0x16a>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8038f8:	83 3f 03             	cmpl   $0x3,(%edi)
  8038fb:	90                   	nop
  8038fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803900:	0f 86 b8 00 00 00    	jbe    8039be <lwip_getsockopt+0x1db>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  803906:	8b 00                	mov    (%eax),%eax
  803908:	83 38 10             	cmpl   $0x10,(%eax)
  80390b:	90                   	nop
  80390c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803910:	0f 85 9b 00 00 00    	jne    8039b1 <lwip_getsockopt+0x1ce>
  803916:	8b 55 10             	mov    0x10(%ebp),%edx
  803919:	83 ea 01             	sub    $0x1,%edx
  80391c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803921:	83 fa 01             	cmp    $0x1,%edx
  803924:	77 15                	ja     80393b <lwip_getsockopt+0x158>
  803926:	8b 55 10             	mov    0x10(%ebp),%edx
  803929:	0f b6 82 c3 2d 81 00 	movzbl 0x812dc3(%edx),%eax
  803930:	eb 05                	jmp    803937 <lwip_getsockopt+0x154>
  803932:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  803937:	84 c0                	test   %al,%al
  803939:	74 12                	je     80394d <lwip_getsockopt+0x16a>
    sock_set_errno(sock, err);
  80393b:	0f be c0             	movsbl %al,%eax
  80393e:	89 43 10             	mov    %eax,0x10(%ebx)
  803941:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  803946:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  80394b:	eb 69                	jmp    8039b6 <lwip_getsockopt+0x1d3>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  80394d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  803950:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  803953:	8b 45 10             	mov    0x10(%ebp),%eax
  803956:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  803959:	8b 55 14             	mov    0x14(%ebp),%edx
  80395c:	89 55 dc             	mov    %edx,-0x24(%ebp)
  data.optlen = optlen;
  80395f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  803962:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  803966:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80396d:	00 
  80396e:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803971:	89 44 24 04          	mov    %eax,0x4(%esp)
  803975:	c7 04 24 e8 3a 80 00 	movl   $0x803ae8,(%esp)
  80397c:	e8 15 19 00 00       	call   805296 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803981:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803988:	00 
  803989:	8b 03                	mov    (%ebx),%eax
  80398b:	8b 40 10             	mov    0x10(%eax),%eax
  80398e:	89 04 24             	mov    %eax,(%esp)
  803991:	e8 20 9f 00 00       	call   80d8b6 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  803996:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  80399a:	0f be d0             	movsbl %al,%edx
  80399d:	89 53 10             	mov    %edx,0x10(%ebx)
  8039a0:	89 15 a0 e5 b3 00    	mov    %edx,0xb3e5a0
  return err ? -1 : 0;
  8039a6:	84 c0                	test   %al,%al
  8039a8:	74 07                	je     8039b1 <lwip_getsockopt+0x1ce>
  8039aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8039af:	eb 05                	jmp    8039b6 <lwip_getsockopt+0x1d3>
  8039b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8039b6:	83 c4 3c             	add    $0x3c,%esp
  8039b9:	5b                   	pop    %ebx
  8039ba:	5e                   	pop    %esi
  8039bb:	5f                   	pop    %edi
  8039bc:	5d                   	pop    %ebp
  8039bd:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  8039be:	b8 16 00 00 00       	mov    $0x16,%eax
  8039c3:	e9 73 ff ff ff       	jmp    80393b <lwip_getsockopt+0x158>
  8039c8:	b8 61 00 00 00       	mov    $0x61,%eax
  8039cd:	e9 69 ff ff ff       	jmp    80393b <lwip_getsockopt+0x158>

008039d2 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  8039d2:	55                   	push   %ebp
  8039d3:	89 e5                	mov    %esp,%ebp
  8039d5:	53                   	push   %ebx
  8039d6:	83 ec 14             	sub    $0x14,%esp
  8039d9:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8039dc:	85 c0                	test   %eax,%eax
  8039de:	75 1c                	jne    8039fc <lwip_setsockopt_internal+0x2a>
  8039e0:	c7 44 24 08 90 2c 81 	movl   $0x812c90,0x8(%esp)
  8039e7:	00 
  8039e8:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  8039ef:	00 
  8039f0:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  8039f7:	e8 80 cf ff ff       	call   80097c <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8039fc:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8039fe:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803a01:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803a04:	8b 40 08             	mov    0x8(%eax),%eax
  803a07:	83 f8 06             	cmp    $0x6,%eax
  803a0a:	0f 84 8a 00 00 00    	je     803a9a <lwip_setsockopt_internal+0xc8>
  803a10:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803a15:	74 0e                	je     803a25 <lwip_setsockopt_internal+0x53>
  803a17:	85 c0                	test   %eax,%eax
  803a19:	74 5d                	je     803a78 <lwip_setsockopt_internal+0xa6>
  803a1b:	90                   	nop
  803a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803a20:	e9 b0 00 00 00       	jmp    803ad5 <lwip_setsockopt_internal+0x103>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803a25:	83 f9 20             	cmp    $0x20,%ecx
  803a28:	74 11                	je     803a3b <lwip_setsockopt_internal+0x69>
  803a2a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803a30:	74 2b                	je     803a5d <lwip_setsockopt_internal+0x8b>
  803a32:	83 f9 08             	cmp    $0x8,%ecx
  803a35:	0f 85 9a 00 00 00    	jne    803ad5 <lwip_setsockopt_internal+0x103>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  803a3b:	83 3b 00             	cmpl   $0x0,(%ebx)
  803a3e:	66 90                	xchg   %ax,%ax
  803a40:	74 0e                	je     803a50 <lwip_setsockopt_internal+0x7e>
        sock->conn->pcb.ip->so_options |= optname;
  803a42:	8b 02                	mov    (%edx),%eax
  803a44:	8b 40 08             	mov    0x8(%eax),%eax
  803a47:	66 09 48 08          	or     %cx,0x8(%eax)
  803a4b:	e9 85 00 00 00       	jmp    803ad5 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  803a50:	8b 02                	mov    (%edx),%eax
  803a52:	8b 40 08             	mov    0x8(%eax),%eax
  803a55:	f7 d1                	not    %ecx
  803a57:	66 21 48 08          	and    %cx,0x8(%eax)
  803a5b:	eb 78                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  803a5d:	83 3b 00             	cmpl   $0x0,(%ebx)
  803a60:	74 0b                	je     803a6d <lwip_setsockopt_internal+0x9b>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  803a62:	8b 02                	mov    (%edx),%eax
  803a64:	8b 40 08             	mov    0x8(%eax),%eax
  803a67:	80 48 10 01          	orb    $0x1,0x10(%eax)
  803a6b:	eb 68                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  803a6d:	8b 02                	mov    (%edx),%eax
  803a6f:	8b 40 08             	mov    0x8(%eax),%eax
  803a72:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  803a76:	eb 5d                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803a78:	83 f9 01             	cmp    $0x1,%ecx
  803a7b:	74 11                	je     803a8e <lwip_setsockopt_internal+0xbc>
  803a7d:	83 f9 02             	cmp    $0x2,%ecx
  803a80:	75 53                	jne    803ad5 <lwip_setsockopt_internal+0x103>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  803a82:	8b 02                	mov    (%edx),%eax
  803a84:	8b 40 08             	mov    0x8(%eax),%eax
  803a87:	8b 0b                	mov    (%ebx),%ecx
  803a89:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  803a8c:	eb 47                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803a8e:	8b 02                	mov    (%edx),%eax
  803a90:	8b 40 08             	mov    0x8(%eax),%eax
  803a93:	8b 0b                	mov    (%ebx),%ecx
  803a95:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  803a98:	eb 3b                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803a9a:	83 f9 01             	cmp    $0x1,%ecx
  803a9d:	74 0b                	je     803aaa <lwip_setsockopt_internal+0xd8>
  803a9f:	83 f9 02             	cmp    $0x2,%ecx
  803aa2:	75 31                	jne    803ad5 <lwip_setsockopt_internal+0x103>
  803aa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803aa8:	eb 1e                	jmp    803ac8 <lwip_setsockopt_internal+0xf6>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803aaa:	83 3b 00             	cmpl   $0x0,(%ebx)
  803aad:	8d 76 00             	lea    0x0(%esi),%esi
  803ab0:	74 0b                	je     803abd <lwip_setsockopt_internal+0xeb>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  803ab2:	8b 02                	mov    (%edx),%eax
  803ab4:	8b 40 08             	mov    0x8(%eax),%eax
  803ab7:	80 48 20 40          	orb    $0x40,0x20(%eax)
  803abb:	eb 18                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  803abd:	8b 02                	mov    (%edx),%eax
  803abf:	8b 40 08             	mov    0x8(%eax),%eax
  803ac2:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  803ac6:	eb 0d                	jmp    803ad5 <lwip_setsockopt_internal+0x103>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  803ac8:	8b 02                	mov    (%edx),%eax
  803aca:	8b 40 08             	mov    0x8(%eax),%eax
  803acd:	8b 0b                	mov    (%ebx),%ecx
  803acf:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803ad5:	8b 02                	mov    (%edx),%eax
  803ad7:	8b 40 10             	mov    0x10(%eax),%eax
  803ada:	89 04 24             	mov    %eax,(%esp)
  803add:	e8 c5 a0 00 00       	call   80dba7 <sys_sem_signal>
}
  803ae2:	83 c4 14             	add    $0x14,%esp
  803ae5:	5b                   	pop    %ebx
  803ae6:	5d                   	pop    %ebp
  803ae7:	c3                   	ret    

00803ae8 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  803ae8:	55                   	push   %ebp
  803ae9:	89 e5                	mov    %esp,%ebp
  803aeb:	53                   	push   %ebx
  803aec:	83 ec 14             	sub    $0x14,%esp
  803aef:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  803af2:	85 c0                	test   %eax,%eax
  803af4:	75 1c                	jne    803b12 <lwip_getsockopt_internal+0x2a>
  803af6:	c7 44 24 08 90 2c 81 	movl   $0x812c90,0x8(%esp)
  803afd:	00 
  803afe:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803b05:	00 
  803b06:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  803b0d:	e8 6a ce ff ff       	call   80097c <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  803b12:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  803b14:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803b17:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803b1a:	8b 40 08             	mov    0x8(%eax),%eax
  803b1d:	83 f8 06             	cmp    $0x6,%eax
  803b20:	0f 84 2f 01 00 00    	je     803c55 <lwip_getsockopt_internal+0x16d>
  803b26:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803b2b:	74 10                	je     803b3d <lwip_getsockopt_internal+0x55>
  803b2d:	85 c0                	test   %eax,%eax
  803b2f:	0f 84 fc 00 00 00    	je     803c31 <lwip_getsockopt_internal+0x149>
  803b35:	8d 76 00             	lea    0x0(%esi),%esi
  803b38:	e9 42 01 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803b3d:	83 f9 20             	cmp    $0x20,%ecx
  803b40:	74 48                	je     803b8a <lwip_getsockopt_internal+0xa2>
  803b42:	83 f9 20             	cmp    $0x20,%ecx
  803b45:	8d 76 00             	lea    0x0(%esi),%esi
  803b48:	7f 18                	jg     803b62 <lwip_getsockopt_internal+0x7a>
  803b4a:	83 f9 02             	cmp    $0x2,%ecx
  803b4d:	8d 76 00             	lea    0x0(%esi),%esi
  803b50:	74 38                	je     803b8a <lwip_getsockopt_internal+0xa2>
  803b52:	83 f9 08             	cmp    $0x8,%ecx
  803b55:	0f 85 24 01 00 00    	jne    803c7f <lwip_getsockopt_internal+0x197>
  803b5b:	90                   	nop
  803b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b60:	eb 28                	jmp    803b8a <lwip_getsockopt_internal+0xa2>
  803b62:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  803b68:	74 32                	je     803b9c <lwip_getsockopt_internal+0xb4>
  803b6a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803b70:	0f 84 ab 00 00 00    	je     803c21 <lwip_getsockopt_internal+0x139>
  803b76:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  803b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b80:	0f 85 f9 00 00 00    	jne    803c7f <lwip_getsockopt_internal+0x197>
  803b86:	66 90                	xchg   %ax,%ax
  803b88:	eb 62                	jmp    803bec <lwip_getsockopt_internal+0x104>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  803b8a:	8b 02                	mov    (%edx),%eax
  803b8c:	8b 40 08             	mov    0x8(%eax),%eax
  803b8f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803b93:	21 c1                	and    %eax,%ecx
  803b95:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  803b97:	e9 e3 00 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  803b9c:	8b 02                	mov    (%edx),%eax
  803b9e:	8b 08                	mov    (%eax),%ecx
  803ba0:	89 c8                	mov    %ecx,%eax
  803ba2:	25 f0 00 00 00       	and    $0xf0,%eax
  803ba7:	83 f8 20             	cmp    $0x20,%eax
  803baa:	74 29                	je     803bd5 <lwip_getsockopt_internal+0xed>
  803bac:	83 f8 40             	cmp    $0x40,%eax
  803baf:	74 09                	je     803bba <lwip_getsockopt_internal+0xd2>
  803bb1:	83 f8 10             	cmp    $0x10,%eax
  803bb4:	75 2f                	jne    803be5 <lwip_getsockopt_internal+0xfd>
  803bb6:	66 90                	xchg   %ax,%ax
  803bb8:	eb 0b                	jmp    803bc5 <lwip_getsockopt_internal+0xdd>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  803bba:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  803bc0:	e9 ba 00 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  803bc5:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
        break;
  803bcb:	90                   	nop
  803bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803bd0:	e9 aa 00 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  803bd5:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  803bdb:	90                   	nop
  803bdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803be0:	e9 9a 00 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  803be5:	89 0b                	mov    %ecx,(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG,
  803be7:	e9 93 00 00 00       	jmp    803c7f <lwip_getsockopt_internal+0x197>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  803bec:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  803bf0:	75 21                	jne    803c13 <lwip_getsockopt_internal+0x12b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  803bf2:	8b 02                	mov    (%edx),%eax
  803bf4:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  803bf8:	f7 d9                	neg    %ecx
  803bfa:	b8 05 00 00 00       	mov    $0x5,%eax
  803bff:	83 f9 0e             	cmp    $0xe,%ecx
  803c02:	77 07                	ja     803c0b <lwip_getsockopt_internal+0x123>
  803c04:	8b 04 8d 80 2d 81 00 	mov    0x812d80(,%ecx,4),%eax
  803c0b:	89 42 10             	mov    %eax,0x10(%edx)
  803c0e:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
      } 
      *(int *)optval = sock->err;
  803c13:	8b 42 10             	mov    0x10(%edx),%eax
  803c16:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  803c18:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  803c1f:	eb 5e                	jmp    803c7f <lwip_getsockopt_internal+0x197>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  803c21:	8b 02                	mov    (%edx),%eax
  803c23:	8b 40 08             	mov    0x8(%eax),%eax
  803c26:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  803c2a:	83 e0 01             	and    $0x1,%eax
  803c2d:	89 03                	mov    %eax,(%ebx)
  803c2f:	eb 4e                	jmp    803c7f <lwip_getsockopt_internal+0x197>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803c31:	83 f9 01             	cmp    $0x1,%ecx
  803c34:	74 12                	je     803c48 <lwip_getsockopt_internal+0x160>
  803c36:	83 f9 02             	cmp    $0x2,%ecx
  803c39:	75 44                	jne    803c7f <lwip_getsockopt_internal+0x197>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  803c3b:	8b 02                	mov    (%edx),%eax
  803c3d:	8b 40 08             	mov    0x8(%eax),%eax
  803c40:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803c44:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  803c46:	eb 37                	jmp    803c7f <lwip_getsockopt_internal+0x197>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803c48:	8b 02                	mov    (%edx),%eax
  803c4a:	8b 40 08             	mov    0x8(%eax),%eax
  803c4d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803c51:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  803c53:	eb 2a                	jmp    803c7f <lwip_getsockopt_internal+0x197>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803c55:	83 f9 01             	cmp    $0x1,%ecx
  803c58:	74 08                	je     803c62 <lwip_getsockopt_internal+0x17a>
  803c5a:	83 f9 02             	cmp    $0x2,%ecx
  803c5d:	75 20                	jne    803c7f <lwip_getsockopt_internal+0x197>
  803c5f:	90                   	nop
  803c60:	eb 10                	jmp    803c72 <lwip_getsockopt_internal+0x18a>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803c62:	8b 02                	mov    (%edx),%eax
  803c64:	8b 40 08             	mov    0x8(%eax),%eax
  803c67:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  803c6b:	83 e0 40             	and    $0x40,%eax
  803c6e:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  803c70:	eb 0d                	jmp    803c7f <lwip_getsockopt_internal+0x197>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803c72:	8b 02                	mov    (%edx),%eax
  803c74:	8b 40 08             	mov    0x8(%eax),%eax
  803c77:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  803c7d:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803c7f:	8b 02                	mov    (%edx),%eax
  803c81:	8b 40 10             	mov    0x10(%eax),%eax
  803c84:	89 04 24             	mov    %eax,(%esp)
  803c87:	e8 1b 9f 00 00       	call   80dba7 <sys_sem_signal>
}
  803c8c:	83 c4 14             	add    $0x14,%esp
  803c8f:	5b                   	pop    %ebx
  803c90:	5d                   	pop    %ebp
  803c91:	c3                   	ret    

00803c92 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803c92:	55                   	push   %ebp
  803c93:	89 e5                	mov    %esp,%ebp
  803c95:	57                   	push   %edi
  803c96:	56                   	push   %esi
  803c97:	53                   	push   %ebx
  803c98:	83 ec 3c             	sub    $0x3c,%esp
  803c9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  803c9e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  803ca1:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803ca4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cab:	00 
  803cac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cb3:	00 
  803cb4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803cb7:	89 04 24             	mov    %eax,(%esp)
  803cba:	e8 b7 d5 ff ff       	call   801276 <memset>
  FD_ZERO(&lwriteset);
  803cbf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cc6:	00 
  803cc7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cce:	00 
  803ccf:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803cd2:	89 04 24             	mov    %eax,(%esp)
  803cd5:	e8 9c d5 ff ff       	call   801276 <memset>
  FD_ZERO(&lexceptset);
  803cda:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803ce1:	00 
  803ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803ce9:	00 
  803cea:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803ced:	89 04 24             	mov    %eax,(%esp)
  803cf0:	e8 81 d5 ff ff       	call   801276 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803cf5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  803cfc:	bb 00 00 00 00       	mov    $0x0,%ebx
  803d01:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  803d05:	0f 8e 84 00 00 00    	jle    803d8f <lwip_selscan+0xfd>
    if (FD_ISSET(i, readset)) {
  803d0b:	89 de                	mov    %ebx,%esi
  803d0d:	c1 fe 1f             	sar    $0x1f,%esi
  803d10:	c1 ee 1d             	shr    $0x1d,%esi
  803d13:	01 de                	add    %ebx,%esi
  803d15:	c1 fe 03             	sar    $0x3,%esi
  803d18:	89 df                	mov    %ebx,%edi
  803d1a:	83 e7 07             	and    $0x7,%edi
  803d1d:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803d20:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803d24:	0f a3 f8             	bt     %edi,%eax
  803d27:	73 2a                	jae    803d53 <lwip_selscan+0xc1>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  803d29:	89 d8                	mov    %ebx,%eax
  803d2b:	e8 00 f8 ff ff       	call   803530 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  803d30:	85 c0                	test   %eax,%eax
  803d32:	74 1f                	je     803d53 <lwip_selscan+0xc1>
  803d34:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803d38:	75 08                	jne    803d42 <lwip_selscan+0xb0>
  803d3a:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803d3f:	90                   	nop
  803d40:	74 11                	je     803d53 <lwip_selscan+0xc1>
        FD_SET(i, &lreadset);
  803d42:	b8 01 00 00 00       	mov    $0x1,%eax
  803d47:	89 f9                	mov    %edi,%ecx
  803d49:	d3 e0                	shl    %cl,%eax
  803d4b:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803d4f:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  803d53:	8b 55 cc             	mov    -0x34(%ebp),%edx
  803d56:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803d5a:	0f a3 f8             	bt     %edi,%eax
  803d5d:	73 24                	jae    803d83 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803d5f:	89 d8                	mov    %ebx,%eax
  803d61:	e8 ca f7 ff ff       	call   803530 <get_socket>
      if (p_sock && p_sock->sendevent) {
  803d66:	85 c0                	test   %eax,%eax
  803d68:	74 19                	je     803d83 <lwip_selscan+0xf1>
  803d6a:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803d6f:	90                   	nop
  803d70:	74 11                	je     803d83 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  803d72:	b8 01 00 00 00       	mov    $0x1,%eax
  803d77:	89 f9                	mov    %edi,%ecx
  803d79:	d3 e0                	shl    %cl,%eax
  803d7b:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803d7f:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803d83:	83 c3 01             	add    $0x1,%ebx
  803d86:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
  803d89:	0f 8f 7c ff ff ff    	jg     803d0b <lwip_selscan+0x79>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803d8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803d92:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803d95:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  803d97:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803d9a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  803d9d:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803d9f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803da6:	00 
  803da7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803dae:	00 
  803daf:	8b 45 08             	mov    0x8(%ebp),%eax
  803db2:	89 04 24             	mov    %eax,(%esp)
  803db5:	e8 bc d4 ff ff       	call   801276 <memset>
  
  return nready;
}
  803dba:	8b 45 c8             	mov    -0x38(%ebp),%eax
  803dbd:	83 c4 3c             	add    $0x3c,%esp
  803dc0:	5b                   	pop    %ebx
  803dc1:	5e                   	pop    %esi
  803dc2:	5f                   	pop    %edi
  803dc3:	5d                   	pop    %ebp
  803dc4:	c3                   	ret    

00803dc5 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  803dc5:	55                   	push   %ebp
  803dc6:	89 e5                	mov    %esp,%ebp
  803dc8:	83 ec 58             	sub    $0x58,%esp
  803dcb:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803dce:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803dd1:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803dd4:	89 d7                	mov    %edx,%edi
  803dd6:	89 ce                	mov    %ecx,%esi
  803dd8:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  803ddc:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  803ddf:	e8 4c f7 ff ff       	call   803530 <get_socket>
  803de4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  803de6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803deb:	85 db                	test   %ebx,%ebx
  803ded:	0f 84 8f 00 00 00    	je     803e82 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  803df3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  803dfa:	00 
  803dfb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e02:	00 
  803e03:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803e06:	89 04 24             	mov    %eax,(%esp)
  803e09:	e8 68 d4 ff ff       	call   801276 <memset>
  sin.sin_len = sizeof(sin);
  803e0e:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  803e12:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  803e16:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  803e1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803e1e:	8d 45 da             	lea    -0x26(%ebp),%eax
  803e21:	89 44 24 08          	mov    %eax,0x8(%esp)
  803e25:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  803e28:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e2c:	8b 03                	mov    (%ebx),%eax
  803e2e:	89 04 24             	mov    %eax,(%esp)
  803e31:	e8 0d aa 00 00       	call   80e843 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  803e36:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  803e3a:	89 04 24             	mov    %eax,(%esp)
  803e3d:	e8 92 6e 00 00       	call   80acd4 <htons>
  803e42:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  803e46:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  803e49:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  803e4c:	83 3e 10             	cmpl   $0x10,(%esi)
  803e4f:	76 06                	jbe    803e57 <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  803e51:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  803e57:	8b 06                	mov    (%esi),%eax
  803e59:	89 44 24 08          	mov    %eax,0x8(%esp)
  803e5d:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803e60:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e64:	89 3c 24             	mov    %edi,(%esp)
  803e67:	e8 e5 d4 ff ff       	call   801351 <memcpy>
  sock_set_errno(sock, 0);
  803e6c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803e73:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  803e7a:	00 00 00 
  803e7d:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803e82:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803e85:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803e88:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803e8b:	89 ec                	mov    %ebp,%esp
  803e8d:	5d                   	pop    %ebp
  803e8e:	c3                   	ret    

00803e8f <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803e8f:	55                   	push   %ebp
  803e90:	89 e5                	mov    %esp,%ebp
  803e92:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803e95:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803e9c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803e9f:	8b 55 0c             	mov    0xc(%ebp),%edx
  803ea2:	8b 45 08             	mov    0x8(%ebp),%eax
  803ea5:	e8 1b ff ff ff       	call   803dc5 <lwip_getaddrname>
}
  803eaa:	c9                   	leave  
  803eab:	c3                   	ret    

00803eac <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  803eac:	55                   	push   %ebp
  803ead:	89 e5                	mov    %esp,%ebp
  803eaf:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  803eb2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803eb9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803ebc:	8b 55 0c             	mov    0xc(%ebp),%edx
  803ebf:	8b 45 08             	mov    0x8(%ebp),%eax
  803ec2:	e8 fe fe ff ff       	call   803dc5 <lwip_getaddrname>
}
  803ec7:	c9                   	leave  
  803ec8:	c3                   	ret    

00803ec9 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  803ec9:	55                   	push   %ebp
  803eca:	89 e5                	mov    %esp,%ebp
  803ecc:	56                   	push   %esi
  803ecd:	53                   	push   %ebx
  803ece:	83 ec 10             	sub    $0x10,%esp
  803ed1:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803ed3:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803ed8:	89 04 24             	mov    %eax,(%esp)
  803edb:	e8 da 46 00 00       	call   8085ba <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  803ee0:	b8 34 84 81 00       	mov    $0x818434,%eax
  803ee5:	bb 01 00 00 00       	mov    $0x1,%ebx
  803eea:	83 3d 20 84 81 00 00 	cmpl   $0x0,0x818420
  803ef1:	75 04                	jne    803ef7 <alloc_socket+0x2e>
  803ef3:	b3 00                	mov    $0x0,%bl
  803ef5:	eb 05                	jmp    803efc <alloc_socket+0x33>
  803ef7:	83 38 00             	cmpl   $0x0,(%eax)
  803efa:	75 4b                	jne    803f47 <alloc_socket+0x7e>
      sockets[i].conn       = newconn;
  803efc:	ba 20 84 81 00       	mov    $0x818420,%edx
  803f01:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  803f04:	c1 e0 02             	shl    $0x2,%eax
  803f07:	89 34 10             	mov    %esi,(%eax,%edx,1)
      sockets[i].lastdata   = NULL;
  803f0a:	c7 44 10 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,1)
  803f11:	00 
      sockets[i].lastoffset = 0;
  803f12:	66 c7 44 10 08 00 00 	movw   $0x0,0x8(%eax,%edx,1)
      sockets[i].rcvevent   = 0;
  803f19:	66 c7 44 10 0a 00 00 	movw   $0x0,0xa(%eax,%edx,1)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  803f20:	66 c7 44 10 0c 01 00 	movw   $0x1,0xc(%eax,%edx,1)
      sockets[i].flags      = 0;
  803f27:	66 c7 44 10 0e 00 00 	movw   $0x0,0xe(%eax,%edx,1)
      sockets[i].err        = 0;
  803f2e:	c7 80 30 84 81 00 00 	movl   $0x0,0x818430(%eax)
  803f35:	00 00 00 
      sys_sem_signal(socksem);
  803f38:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803f3d:	89 04 24             	mov    %eax,(%esp)
  803f40:	e8 62 9c 00 00       	call   80dba7 <sys_sem_signal>
      return i;
  803f45:	eb 1d                	jmp    803f64 <alloc_socket+0x9b>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803f47:	83 c3 01             	add    $0x1,%ebx
  803f4a:	83 c0 14             	add    $0x14,%eax
  803f4d:	83 fb 20             	cmp    $0x20,%ebx
  803f50:	75 a5                	jne    803ef7 <alloc_socket+0x2e>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803f52:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803f57:	89 04 24             	mov    %eax,(%esp)
  803f5a:	e8 48 9c 00 00       	call   80dba7 <sys_sem_signal>
  803f5f:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803f64:	89 d8                	mov    %ebx,%eax
  803f66:	83 c4 10             	add    $0x10,%esp
  803f69:	5b                   	pop    %ebx
  803f6a:	5e                   	pop    %esi
  803f6b:	5d                   	pop    %ebp
  803f6c:	c3                   	ret    

00803f6d <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  803f6d:	55                   	push   %ebp
  803f6e:	89 e5                	mov    %esp,%ebp
  803f70:	57                   	push   %edi
  803f71:	56                   	push   %esi
  803f72:	53                   	push   %ebx
  803f73:	83 ec 2c             	sub    $0x2c,%esp
  803f76:	8b 75 08             	mov    0x8(%ebp),%esi
  803f79:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  803f7c:	85 f6                	test   %esi,%esi
  803f7e:	0f 84 75 01 00 00    	je     8040f9 <event_callback+0x18c>
    s = conn->socket;
  803f84:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  803f87:	85 db                	test   %ebx,%ebx
  803f89:	79 3d                	jns    803fc8 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  803f8b:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803f90:	89 04 24             	mov    %eax,(%esp)
  803f93:	e8 22 46 00 00       	call   8085ba <sys_sem_wait>
      if (conn->socket < 0) {
  803f98:	8b 46 1c             	mov    0x1c(%esi),%eax
  803f9b:	85 c0                	test   %eax,%eax
  803f9d:	79 1c                	jns    803fbb <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  803f9f:	85 ff                	test   %edi,%edi
  803fa1:	75 06                	jne    803fa9 <event_callback+0x3c>
          conn->socket--;
  803fa3:	83 e8 01             	sub    $0x1,%eax
  803fa6:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  803fa9:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803fae:	89 04 24             	mov    %eax,(%esp)
  803fb1:	e8 f1 9b 00 00       	call   80dba7 <sys_sem_signal>
        return;
  803fb6:	e9 3e 01 00 00       	jmp    8040f9 <event_callback+0x18c>
      }
      sys_sem_signal(socksem);
  803fbb:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  803fc0:	89 04 24             	mov    %eax,(%esp)
  803fc3:	e8 df 9b 00 00       	call   80dba7 <sys_sem_signal>
    }

    sock = get_socket(s);
  803fc8:	89 d8                	mov    %ebx,%eax
  803fca:	e8 61 f5 ff ff       	call   803530 <get_socket>
  803fcf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  803fd2:	85 c0                	test   %eax,%eax
  803fd4:	0f 84 1f 01 00 00    	je     8040f9 <event_callback+0x18c>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  803fda:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  803fdf:	89 04 24             	mov    %eax,(%esp)
  803fe2:	e8 d3 45 00 00       	call   8085ba <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  803fe7:	83 ff 01             	cmp    $0x1,%edi
  803fea:	74 20                	je     80400c <event_callback+0x9f>
  803fec:	83 ff 01             	cmp    $0x1,%edi
  803fef:	72 11                	jb     804002 <event_callback+0x95>
  803ff1:	83 ff 02             	cmp    $0x2,%edi
  803ff4:	74 20                	je     804016 <event_callback+0xa9>
  803ff6:	83 ff 03             	cmp    $0x3,%edi
  803ff9:	75 31                	jne    80402c <event_callback+0xbf>
  803ffb:	90                   	nop
  803ffc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  804000:	eb 1f                	jmp    804021 <event_callback+0xb4>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  804002:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804005:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  80400a:	eb 3c                	jmp    804048 <event_callback+0xdb>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  80400c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80400f:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  804014:	eb 32                	jmp    804048 <event_callback+0xdb>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  804016:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804019:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  80401f:	eb 27                	jmp    804048 <event_callback+0xdb>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  804021:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804024:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  80402a:	eb 1c                	jmp    804048 <event_callback+0xdb>
    default:
      LWIP_ASSERT("unknown event", 0);
  80402c:	c7 44 24 08 b3 2c 81 	movl   $0x812cb3,0x8(%esp)
  804033:	00 
  804034:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  80403b:	00 
  80403c:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  804043:	e8 34 c9 ff ff       	call   80097c <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  804048:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  80404d:	89 04 24             	mov    %eax,(%esp)
  804050:	e8 52 9b 00 00       	call   80dba7 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  804055:	89 de                	mov    %ebx,%esi
  804057:	c1 fe 1f             	sar    $0x1f,%esi
  80405a:	c1 ee 1d             	shr    $0x1d,%esi
  80405d:	01 de                	add    %ebx,%esi
  80405f:	c1 fe 03             	sar    $0x3,%esi
  804062:	89 d9                	mov    %ebx,%ecx
  804064:	83 e1 07             	and    $0x7,%ecx
  804067:	b8 01 00 00 00       	mov    $0x1,%eax
  80406c:	89 c7                	mov    %eax,%edi
  80406e:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  804070:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  804075:	89 04 24             	mov    %eax,(%esp)
  804078:	e8 3d 45 00 00       	call   8085ba <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  80407d:	8b 1d a0 86 81 00    	mov    0x8186a0,%ebx
  804083:	85 db                	test   %ebx,%ebx
  804085:	74 65                	je     8040ec <event_callback+0x17f>
      if (scb->sem_signalled == 0) {
  804087:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80408b:	75 32                	jne    8040bf <event_callback+0x152>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  80408d:	8b 43 04             	mov    0x4(%ebx),%eax
  804090:	85 c0                	test   %eax,%eax
  804092:	74 12                	je     8040a6 <event_callback+0x139>
  804094:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  804098:	85 f8                	test   %edi,%eax
  80409a:	74 0a                	je     8040a6 <event_callback+0x139>
          if (sock->rcvevent)
  80409c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80409f:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8040a4:	75 21                	jne    8040c7 <event_callback+0x15a>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  8040a6:	8b 43 08             	mov    0x8(%ebx),%eax
  8040a9:	85 c0                	test   %eax,%eax
  8040ab:	74 12                	je     8040bf <event_callback+0x152>
  8040ad:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  8040b1:	85 f8                	test   %edi,%eax
  8040b3:	74 0a                	je     8040bf <event_callback+0x152>
          if (sock->sendevent)
  8040b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8040b8:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8040bd:	75 08                	jne    8040c7 <event_callback+0x15a>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  8040bf:	8b 1b                	mov    (%ebx),%ebx
  8040c1:	85 db                	test   %ebx,%ebx
  8040c3:	75 c2                	jne    804087 <event_callback+0x11a>
  8040c5:	eb 25                	jmp    8040ec <event_callback+0x17f>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  8040c7:	85 db                	test   %ebx,%ebx
  8040c9:	74 21                	je     8040ec <event_callback+0x17f>
      scb->sem_signalled = 1;
  8040cb:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  8040d2:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  8040d7:	89 04 24             	mov    %eax,(%esp)
  8040da:	e8 c8 9a 00 00       	call   80dba7 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  8040df:	8b 43 14             	mov    0x14(%ebx),%eax
  8040e2:	89 04 24             	mov    %eax,(%esp)
  8040e5:	e8 bd 9a 00 00       	call   80dba7 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8040ea:	eb 84                	jmp    804070 <event_callback+0x103>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8040ec:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  8040f1:	89 04 24             	mov    %eax,(%esp)
  8040f4:	e8 ae 9a 00 00       	call   80dba7 <sys_sem_signal>
      break;
    }
  }
}
  8040f9:	83 c4 2c             	add    $0x2c,%esp
  8040fc:	5b                   	pop    %ebx
  8040fd:	5e                   	pop    %esi
  8040fe:	5f                   	pop    %edi
  8040ff:	5d                   	pop    %ebp
  804100:	c3                   	ret    

00804101 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  804101:	55                   	push   %ebp
  804102:	89 e5                	mov    %esp,%ebp
  804104:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  804107:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80410e:	e8 f2 98 00 00       	call   80da05 <sys_sem_new>
  804113:	a3 a4 86 81 00       	mov    %eax,0x8186a4
  selectsem = sys_sem_new(1);
  804118:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80411f:	e8 e1 98 00 00       	call   80da05 <sys_sem_new>
  804124:	a3 a8 86 81 00       	mov    %eax,0x8186a8
}
  804129:	c9                   	leave  
  80412a:	c3                   	ret    

0080412b <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  80412b:	55                   	push   %ebp
  80412c:	89 e5                	mov    %esp,%ebp
  80412e:	57                   	push   %edi
  80412f:	56                   	push   %esi
  804130:	53                   	push   %ebx
  804131:	83 ec 5c             	sub    $0x5c,%esp
  804134:	8b 7d 0c             	mov    0xc(%ebp),%edi
  804137:	8b 75 10             	mov    0x10(%ebp),%esi
  80413a:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  80413d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  804144:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  804147:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80414a:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  80414d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  804154:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  804159:	89 04 24             	mov    %eax,(%esp)
  80415c:	e8 59 44 00 00       	call   8085ba <sys_sem_wait>

  if (readset)
  804161:	85 ff                	test   %edi,%edi
  804163:	74 07                	je     80416c <lwip_select+0x41>
    lreadset = *readset;
  804165:	8b 07                	mov    (%edi),%eax
  804167:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80416a:	eb 1b                	jmp    804187 <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  80416c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804173:	00 
  804174:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80417b:	00 
  80417c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80417f:	89 04 24             	mov    %eax,(%esp)
  804182:	e8 ef d0 ff ff       	call   801276 <memset>
  if (writeset)
  804187:	85 f6                	test   %esi,%esi
  804189:	74 07                	je     804192 <lwip_select+0x67>
    lwriteset = *writeset;
  80418b:	8b 06                	mov    (%esi),%eax
  80418d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  804190:	eb 1b                	jmp    8041ad <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  804192:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804199:	00 
  80419a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8041a1:	00 
  8041a2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8041a5:	89 04 24             	mov    %eax,(%esp)
  8041a8:	e8 c9 d0 ff ff       	call   801276 <memset>
  if (exceptset)
  8041ad:	85 db                	test   %ebx,%ebx
  8041af:	74 07                	je     8041b8 <lwip_select+0x8d>
    lexceptset = *exceptset;
  8041b1:	8b 03                	mov    (%ebx),%eax
  8041b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8041b6:	eb 1b                	jmp    8041d3 <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  8041b8:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8041bf:	00 
  8041c0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8041c7:	00 
  8041c8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8041cb:	89 04 24             	mov    %eax,(%esp)
  8041ce:	e8 a3 d0 ff ff       	call   801276 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8041d3:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8041d6:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8041d9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8041dc:	89 04 24             	mov    %eax,(%esp)
  8041df:	8b 45 08             	mov    0x8(%ebp),%eax
  8041e2:	e8 ab fa ff ff       	call   803c92 <lwip_selscan>
  8041e7:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8041ea:	85 c0                	test   %eax,%eax
  8041ec:	0f 85 29 02 00 00    	jne    80441b <lwip_select+0x2f0>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8041f2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8041f6:	0f 84 86 00 00 00    	je     804282 <lwip_select+0x157>
  8041fc:	8b 45 18             	mov    0x18(%ebp),%eax
  8041ff:	83 38 00             	cmpl   $0x0,(%eax)
  804202:	0f 85 50 02 00 00    	jne    804458 <lwip_select+0x32d>
  804208:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80420c:	0f 85 46 02 00 00    	jne    804458 <lwip_select+0x32d>
      sys_sem_signal(selectsem);
  804212:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  804217:	89 04 24             	mov    %eax,(%esp)
  80421a:	e8 88 99 00 00       	call   80dba7 <sys_sem_signal>
      if (readset)
  80421f:	85 ff                	test   %edi,%edi
  804221:	74 18                	je     80423b <lwip_select+0x110>
        FD_ZERO(readset);
  804223:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80422a:	00 
  80422b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804232:	00 
  804233:	89 3c 24             	mov    %edi,(%esp)
  804236:	e8 3b d0 ff ff       	call   801276 <memset>
      if (writeset)
  80423b:	85 f6                	test   %esi,%esi
  80423d:	74 18                	je     804257 <lwip_select+0x12c>
        FD_ZERO(writeset);
  80423f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804246:	00 
  804247:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80424e:	00 
  80424f:	89 34 24             	mov    %esi,(%esp)
  804252:	e8 1f d0 ff ff       	call   801276 <memset>
      if (exceptset)
  804257:	85 db                	test   %ebx,%ebx
  804259:	74 18                	je     804273 <lwip_select+0x148>
        FD_ZERO(exceptset);
  80425b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804262:	00 
  804263:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80426a:	00 
  80426b:	89 1c 24             	mov    %ebx,(%esp)
  80426e:	e8 03 d0 ff ff       	call   801276 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  804273:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  80427a:	00 00 00 
  
      return 0;
  80427d:	e9 cb 01 00 00       	jmp    80444d <lwip_select+0x322>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  804282:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804289:	e8 77 97 00 00       	call   80da05 <sys_sem_new>
  80428e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  804291:	a1 a0 86 81 00       	mov    0x8186a0,%eax
  804296:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  804299:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  80429c:	a3 a0 86 81 00       	mov    %eax,0x8186a0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8042a1:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  8042a6:	89 04 24             	mov    %eax,(%esp)
  8042a9:	e8 f9 98 00 00       	call   80dba7 <sys_sem_signal>
  8042ae:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8042b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8042b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8042ba:	89 04 24             	mov    %eax,(%esp)
  8042bd:	e8 87 43 00 00       	call   808649 <sys_sem_wait_timeout>
  8042c2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8042c5:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  8042ca:	89 04 24             	mov    %eax,(%esp)
  8042cd:	e8 e8 42 00 00       	call   8085ba <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8042d2:	a1 a0 86 81 00       	mov    0x8186a0,%eax
  8042d7:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8042da:	39 d0                	cmp    %edx,%eax
  8042dc:	75 1f                	jne    8042fd <lwip_select+0x1d2>
      select_cb_list = select_cb.next;
  8042de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8042e1:	a3 a0 86 81 00       	mov    %eax,0x8186a0
  8042e6:	eb 27                	jmp    80430f <lwip_select+0x1e4>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8042e8:	8b 10                	mov    (%eax),%edx
  8042ea:	39 ca                	cmp    %ecx,%edx
  8042ec:	74 08                	je     8042f6 <lwip_select+0x1cb>
  8042ee:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8042f0:	85 c0                	test   %eax,%eax
  8042f2:	75 f4                	jne    8042e8 <lwip_select+0x1bd>
  8042f4:	eb 19                	jmp    80430f <lwip_select+0x1e4>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  8042f6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8042f9:	89 10                	mov    %edx,(%eax)
          break;
  8042fb:	eb 12                	jmp    80430f <lwip_select+0x1e4>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8042fd:	85 c0                	test   %eax,%eax
  8042ff:	90                   	nop
  804300:	74 0d                	je     80430f <lwip_select+0x1e4>
        if (p_selcb->next == &select_cb) {
  804302:	8b 10                	mov    (%eax),%edx
  804304:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  804307:	39 ca                	cmp    %ecx,%edx
  804309:	74 eb                	je     8042f6 <lwip_select+0x1cb>
  80430b:	89 d0                	mov    %edx,%eax
  80430d:	eb e1                	jmp    8042f0 <lwip_select+0x1c5>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  80430f:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  804314:	89 04 24             	mov    %eax,(%esp)
  804317:	e8 8b 98 00 00       	call   80dba7 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  80431c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80431f:	89 04 24             	mov    %eax,(%esp)
  804322:	e8 3c 92 00 00       	call   80d563 <sys_sem_free>
    if (i == 0)  {
  804327:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  80432b:	75 63                	jne    804390 <lwip_select+0x265>
      /* Timeout */
      if (readset)
  80432d:	85 ff                	test   %edi,%edi
  80432f:	74 18                	je     804349 <lwip_select+0x21e>
        FD_ZERO(readset);
  804331:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804338:	00 
  804339:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804340:	00 
  804341:	89 3c 24             	mov    %edi,(%esp)
  804344:	e8 2d cf ff ff       	call   801276 <memset>
      if (writeset)
  804349:	85 f6                	test   %esi,%esi
  80434b:	74 18                	je     804365 <lwip_select+0x23a>
        FD_ZERO(writeset);
  80434d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804354:	00 
  804355:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80435c:	00 
  80435d:	89 34 24             	mov    %esi,(%esp)
  804360:	e8 11 cf ff ff       	call   801276 <memset>
      if (exceptset)
  804365:	85 db                	test   %ebx,%ebx
  804367:	74 18                	je     804381 <lwip_select+0x256>
        FD_ZERO(exceptset);
  804369:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804370:	00 
  804371:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804378:	00 
  804379:	89 1c 24             	mov    %ebx,(%esp)
  80437c:	e8 f5 ce ff ff       	call   801276 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  804381:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804388:	00 00 00 
  
      return 0;
  80438b:	e9 bd 00 00 00       	jmp    80444d <lwip_select+0x322>
    }
    
    if (readset)
  804390:	85 ff                	test   %edi,%edi
  804392:	74 07                	je     80439b <lwip_select+0x270>
      lreadset = *readset;
  804394:	8b 07                	mov    (%edi),%eax
  804396:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804399:	eb 1b                	jmp    8043b6 <lwip_select+0x28b>
    else
      FD_ZERO(&lreadset);
  80439b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043a2:	00 
  8043a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043aa:	00 
  8043ab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8043ae:	89 04 24             	mov    %eax,(%esp)
  8043b1:	e8 c0 ce ff ff       	call   801276 <memset>
    if (writeset)
  8043b6:	85 f6                	test   %esi,%esi
  8043b8:	74 07                	je     8043c1 <lwip_select+0x296>
      lwriteset = *writeset;
  8043ba:	8b 06                	mov    (%esi),%eax
  8043bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8043bf:	eb 1b                	jmp    8043dc <lwip_select+0x2b1>
    else
      FD_ZERO(&lwriteset);
  8043c1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043c8:	00 
  8043c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043d0:	00 
  8043d1:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8043d4:	89 04 24             	mov    %eax,(%esp)
  8043d7:	e8 9a ce ff ff       	call   801276 <memset>
    if (exceptset)
  8043dc:	85 db                	test   %ebx,%ebx
  8043de:	74 07                	je     8043e7 <lwip_select+0x2bc>
      lexceptset = *exceptset;
  8043e0:	8b 03                	mov    (%ebx),%eax
  8043e2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8043e5:	eb 1b                	jmp    804402 <lwip_select+0x2d7>
    else
      FD_ZERO(&lexceptset);
  8043e7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043ee:	00 
  8043ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043f6:	00 
  8043f7:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8043fa:	89 04 24             	mov    %eax,(%esp)
  8043fd:	e8 74 ce ff ff       	call   801276 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  804402:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  804405:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  804408:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80440b:	89 04 24             	mov    %eax,(%esp)
  80440e:	8b 45 08             	mov    0x8(%ebp),%eax
  804411:	e8 7c f8 ff ff       	call   803c92 <lwip_selscan>
  804416:	89 45 b0             	mov    %eax,-0x50(%ebp)
  804419:	eb 0d                	jmp    804428 <lwip_select+0x2fd>
  } else
    sys_sem_signal(selectsem);
  80441b:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  804420:	89 04 24             	mov    %eax,(%esp)
  804423:	e8 7f 97 00 00       	call   80dba7 <sys_sem_signal>
  
  if (readset)
  804428:	85 ff                	test   %edi,%edi
  80442a:	74 05                	je     804431 <lwip_select+0x306>
    *readset = lreadset;
  80442c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80442f:	89 07                	mov    %eax,(%edi)
  if (writeset)
  804431:	85 f6                	test   %esi,%esi
  804433:	74 05                	je     80443a <lwip_select+0x30f>
    *writeset = lwriteset;
  804435:	8b 45 e0             	mov    -0x20(%ebp),%eax
  804438:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  80443a:	85 db                	test   %ebx,%ebx
  80443c:	74 05                	je     804443 <lwip_select+0x318>
    *exceptset = lexceptset;
  80443e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  804441:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  804443:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  80444a:	00 00 00 
  
  return nready;
}
  80444d:	8b 45 b0             	mov    -0x50(%ebp),%eax
  804450:	83 c4 5c             	add    $0x5c,%esp
  804453:	5b                   	pop    %ebx
  804454:	5e                   	pop    %esi
  804455:	5f                   	pop    %edi
  804456:	5d                   	pop    %ebp
  804457:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  804458:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80445f:	e8 a1 95 00 00       	call   80da05 <sys_sem_new>
  804464:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  804467:	a1 a0 86 81 00       	mov    0x8186a0,%eax
  80446c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80446f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  804472:	a3 a0 86 81 00       	mov    %eax,0x8186a0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  804477:	a1 a8 86 81 00       	mov    0x8186a8,%eax
  80447c:	89 04 24             	mov    %eax,(%esp)
  80447f:	e8 23 97 00 00       	call   80dba7 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  804484:	8b 45 18             	mov    0x18(%ebp),%eax
  804487:	8b 48 04             	mov    0x4(%eax),%ecx
  80448a:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  804490:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  804495:	89 c8                	mov    %ecx,%eax
  804497:	f7 ea                	imul   %edx
  804499:	c1 fa 06             	sar    $0x6,%edx
  80449c:	c1 f9 1f             	sar    $0x1f,%ecx
  80449f:	29 ca                	sub    %ecx,%edx
  8044a1:	8b 45 18             	mov    0x18(%ebp),%eax
  8044a4:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  8044aa:	01 ca                	add    %ecx,%edx
  8044ac:	0f 85 01 fe ff ff    	jne    8042b3 <lwip_select+0x188>
  8044b2:	ba 01 00 00 00       	mov    $0x1,%edx
  8044b7:	e9 f7 fd ff ff       	jmp    8042b3 <lwip_select+0x188>

008044bc <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  8044bc:	55                   	push   %ebp
  8044bd:	89 e5                	mov    %esp,%ebp
  8044bf:	56                   	push   %esi
  8044c0:	53                   	push   %ebx
  8044c1:	83 ec 10             	sub    $0x10,%esp
  8044c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8044c7:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8044ca:	83 f8 02             	cmp    $0x2,%eax
  8044cd:	74 32                	je     804501 <lwip_socket+0x45>
  8044cf:	83 f8 03             	cmp    $0x3,%eax
  8044d2:	74 0e                	je     8044e2 <lwip_socket+0x26>
  8044d4:	83 f8 01             	cmp    $0x1,%eax
  8044d7:	75 73                	jne    80454c <lwip_socket+0x90>
  8044d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8044e0:	eb 4a                	jmp    80452c <lwip_socket+0x70>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8044e2:	c7 44 24 08 6d 3f 80 	movl   $0x803f6d,0x8(%esp)
  8044e9:	00 
  8044ea:	0f b6 d2             	movzbl %dl,%edx
  8044ed:	89 54 24 04          	mov    %edx,0x4(%esp)
  8044f1:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8044f8:	e8 5b a6 00 00       	call   80eb58 <netconn_new_with_proto_and_callback>
  8044fd:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8044ff:	eb 5c                	jmp    80455d <lwip_socket+0xa1>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  804501:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  804507:	0f 94 c0             	sete   %al
  80450a:	0f b6 c0             	movzbl %al,%eax
  80450d:	83 c0 20             	add    $0x20,%eax
  804510:	c7 44 24 08 6d 3f 80 	movl   $0x803f6d,0x8(%esp)
  804517:	00 
  804518:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80451f:	00 
  804520:	89 04 24             	mov    %eax,(%esp)
  804523:	e8 30 a6 00 00       	call   80eb58 <netconn_new_with_proto_and_callback>
  804528:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80452a:	eb 31                	jmp    80455d <lwip_socket+0xa1>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80452c:	c7 44 24 08 6d 3f 80 	movl   $0x803f6d,0x8(%esp)
  804533:	00 
  804534:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80453b:	00 
  80453c:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  804543:	e8 10 a6 00 00       	call   80eb58 <netconn_new_with_proto_and_callback>
  804548:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80454a:	eb 11                	jmp    80455d <lwip_socket+0xa1>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  80454c:	c7 05 a0 e5 b3 00 16 	movl   $0x16,0xb3e5a0
  804553:	00 00 00 
  804556:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  80455b:	eb 44                	jmp    8045a1 <lwip_socket+0xe5>
  }

  if (!conn) {
  80455d:	85 f6                	test   %esi,%esi
  80455f:	75 11                	jne    804572 <lwip_socket+0xb6>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  804561:	c7 05 a0 e5 b3 00 69 	movl   $0x69,0xb3e5a0
  804568:	00 00 00 
  80456b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  804570:	eb 2f                	jmp    8045a1 <lwip_socket+0xe5>
  }

  i = alloc_socket(conn);
  804572:	89 f0                	mov    %esi,%eax
  804574:	e8 50 f9 ff ff       	call   803ec9 <alloc_socket>
  804579:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  80457b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80457e:	75 14                	jne    804594 <lwip_socket+0xd8>
    netconn_delete(conn);
  804580:	89 34 24             	mov    %esi,(%esp)
  804583:	e8 93 a5 00 00       	call   80eb1b <netconn_delete>
    set_errno(ENFILE);
  804588:	c7 05 a0 e5 b3 00 17 	movl   $0x17,0xb3e5a0
  80458f:	00 00 00 
    return -1;
  804592:	eb 0d                	jmp    8045a1 <lwip_socket+0xe5>
  }
  conn->socket = i;
  804594:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804597:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  80459e:	00 00 00 
  return i;
}
  8045a1:	89 d8                	mov    %ebx,%eax
  8045a3:	83 c4 10             	add    $0x10,%esp
  8045a6:	5b                   	pop    %ebx
  8045a7:	5e                   	pop    %esi
  8045a8:	5d                   	pop    %ebp
  8045a9:	c3                   	ret    

008045aa <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8045aa:	55                   	push   %ebp
  8045ab:	89 e5                	mov    %esp,%ebp
  8045ad:	83 ec 38             	sub    $0x38,%esp
  8045b0:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8045b3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8045b6:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8045b9:	8b 7d 08             	mov    0x8(%ebp),%edi
  8045bc:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8045bf:	89 f8                	mov    %edi,%eax
  8045c1:	e8 6a ef ff ff       	call   803530 <get_socket>
  8045c6:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8045c8:	85 c0                	test   %eax,%eax
  8045ca:	0f 84 80 00 00 00    	je     804650 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8045d0:	8b 00                	mov    (%eax),%eax
  8045d2:	83 38 10             	cmpl   $0x10,(%eax)
  8045d5:	74 2e                	je     804605 <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8045d7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8045de:	00 
  8045df:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8045e6:	00 
  8045e7:	8b 45 14             	mov    0x14(%ebp),%eax
  8045ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8045ee:	89 74 24 08          	mov    %esi,0x8(%esp)
  8045f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8045f5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8045f9:	89 3c 24             	mov    %edi,(%esp)
  8045fc:	e8 8c 00 00 00       	call   80468d <lwip_sendto>
  804601:	89 c6                	mov    %eax,%esi
  804603:	eb 50                	jmp    804655 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  804605:	8b 55 14             	mov    0x14(%ebp),%edx
  804608:	83 e2 10             	and    $0x10,%edx
  80460b:	83 fa 01             	cmp    $0x1,%edx
  80460e:	19 d2                	sbb    %edx,%edx
  804610:	83 e2 fe             	and    $0xfffffffe,%edx
  804613:	83 c2 03             	add    $0x3,%edx
  804616:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80461a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80461e:	8b 55 0c             	mov    0xc(%ebp),%edx
  804621:	89 54 24 04          	mov    %edx,0x4(%esp)
  804625:	89 04 24             	mov    %eax,(%esp)
  804628:	e8 d9 9f 00 00       	call   80e606 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  80462d:	0f be c8             	movsbl %al,%ecx
  804630:	f7 d9                	neg    %ecx
  804632:	ba 05 00 00 00       	mov    $0x5,%edx
  804637:	83 f9 0e             	cmp    $0xe,%ecx
  80463a:	77 07                	ja     804643 <lwip_send+0x99>
  80463c:	8b 14 8d 80 2d 81 00 	mov    0x812d80(,%ecx,4),%edx
  804643:	89 53 10             	mov    %edx,0x10(%ebx)
  804646:	89 15 a0 e5 b3 00    	mov    %edx,0xb3e5a0
  return (err==ERR_OK?size:-1);
  80464c:	84 c0                	test   %al,%al
  80464e:	74 05                	je     804655 <lwip_send+0xab>
  804650:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  804655:	89 f0                	mov    %esi,%eax
  804657:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80465a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80465d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  804660:	89 ec                	mov    %ebp,%esp
  804662:	5d                   	pop    %ebp
  804663:	c3                   	ret    

00804664 <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  804664:	55                   	push   %ebp
  804665:	89 e5                	mov    %esp,%ebp
  804667:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  80466a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804671:	00 
  804672:	8b 45 10             	mov    0x10(%ebp),%eax
  804675:	89 44 24 08          	mov    %eax,0x8(%esp)
  804679:	8b 45 0c             	mov    0xc(%ebp),%eax
  80467c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804680:	8b 45 08             	mov    0x8(%ebp),%eax
  804683:	89 04 24             	mov    %eax,(%esp)
  804686:	e8 1f ff ff ff       	call   8045aa <lwip_send>
}
  80468b:	c9                   	leave  
  80468c:	c3                   	ret    

0080468d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80468d:	55                   	push   %ebp
  80468e:	89 e5                	mov    %esp,%ebp
  804690:	57                   	push   %edi
  804691:	56                   	push   %esi
  804692:	53                   	push   %ebx
  804693:	83 ec 3c             	sub    $0x3c,%esp
  804696:	8b 7d 10             	mov    0x10(%ebp),%edi
  804699:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80469c:	8b 45 08             	mov    0x8(%ebp),%eax
  80469f:	e8 8c ee ff ff       	call   803530 <get_socket>
  8046a4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8046a6:	85 c0                	test   %eax,%eax
  8046a8:	0f 84 2e 01 00 00    	je     8047dc <lwip_sendto+0x14f>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  8046ae:	8b 00                	mov    (%eax),%eax
  8046b0:	83 38 10             	cmpl   $0x10,(%eax)
  8046b3:	75 24                	jne    8046d9 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8046b5:	8b 45 14             	mov    0x14(%ebp),%eax
  8046b8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8046bc:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8046c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8046c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8046c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8046ca:	89 04 24             	mov    %eax,(%esp)
  8046cd:	e8 d8 fe ff ff       	call   8045aa <lwip_send>
  8046d2:	89 c7                	mov    %eax,%edi
  8046d4:	e9 08 01 00 00       	jmp    8047e1 <lwip_sendto+0x154>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8046d9:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  8046df:	76 1c                	jbe    8046fd <lwip_sendto+0x70>
  8046e1:	c7 44 24 08 44 2d 81 	movl   $0x812d44,0x8(%esp)
  8046e8:	00 
  8046e9:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8046f0:	00 
  8046f1:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  8046f8:	e8 7f c2 ff ff       	call   80097c <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8046fd:	85 f6                	test   %esi,%esi
  8046ff:	0f 95 c0             	setne  %al
  804702:	75 06                	jne    80470a <lwip_sendto+0x7d>
  804704:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804708:	74 2a                	je     804734 <lwip_sendto+0xa7>
  80470a:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  80470e:	66 90                	xchg   %ax,%ax
  804710:	75 06                	jne    804718 <lwip_sendto+0x8b>
  804712:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  804716:	74 1c                	je     804734 <lwip_sendto+0xa7>
  804718:	c7 44 24 08 c1 2c 81 	movl   $0x812cc1,0x8(%esp)
  80471f:	00 
  804720:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  804727:	00 
  804728:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  80472f:	e8 48 c2 ff ff       	call   80097c <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  804734:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80473b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  804742:	84 c0                	test   %al,%al
  804744:	74 1e                	je     804764 <lwip_sendto+0xd7>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  804746:	8b 46 04             	mov    0x4(%esi),%eax
  804749:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80474c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  804750:	89 04 24             	mov    %eax,(%esp)
  804753:	e8 89 65 00 00       	call   80ace1 <ntohs>
    buf.addr         = &remote_addr;
  804758:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80475b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80475e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  804762:	eb 14                	jmp    804778 <lwip_sendto+0xeb>
  } else {
    remote_addr.addr = 0;
  804764:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80476b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  804772:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  804778:	0f b7 c7             	movzwl %di,%eax
  80477b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80477f:	8b 45 0c             	mov    0xc(%ebp),%eax
  804782:	89 44 24 04          	mov    %eax,0x4(%esp)
  804786:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804789:	89 04 24             	mov    %eax,(%esp)
  80478c:	e8 ac 0e 00 00       	call   80563d <netbuf_ref>
  804791:	0f be f0             	movsbl %al,%esi
  804794:	85 f6                	test   %esi,%esi
  804796:	75 14                	jne    8047ac <lwip_sendto+0x11f>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804798:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80479b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80479f:	8b 03                	mov    (%ebx),%eax
  8047a1:	89 04 24             	mov    %eax,(%esp)
  8047a4:	e8 da 9e 00 00       	call   80e683 <netconn_send>
  8047a9:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8047ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8047af:	85 c0                	test   %eax,%eax
  8047b1:	74 08                	je     8047bb <lwip_sendto+0x12e>
    pbuf_free(buf.p);
  8047b3:	89 04 24             	mov    %eax,(%esp)
  8047b6:	e8 1d 37 00 00       	call   807ed8 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8047bb:	89 f2                	mov    %esi,%edx
  8047bd:	f7 da                	neg    %edx
  8047bf:	b8 05 00 00 00       	mov    $0x5,%eax
  8047c4:	83 fa 0e             	cmp    $0xe,%edx
  8047c7:	77 07                	ja     8047d0 <lwip_sendto+0x143>
  8047c9:	8b 04 95 80 2d 81 00 	mov    0x812d80(,%edx,4),%eax
  8047d0:	89 43 10             	mov    %eax,0x10(%ebx)
  8047d3:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  return (err==ERR_OK?size:-1);
  8047d8:	85 f6                	test   %esi,%esi
  8047da:	74 05                	je     8047e1 <lwip_sendto+0x154>
  8047dc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  8047e1:	89 f8                	mov    %edi,%eax
  8047e3:	83 c4 3c             	add    $0x3c,%esp
  8047e6:	5b                   	pop    %ebx
  8047e7:	5e                   	pop    %esi
  8047e8:	5f                   	pop    %edi
  8047e9:	5d                   	pop    %ebp
  8047ea:	c3                   	ret    

008047eb <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8047eb:	55                   	push   %ebp
  8047ec:	89 e5                	mov    %esp,%ebp
  8047ee:	57                   	push   %edi
  8047ef:	56                   	push   %esi
  8047f0:	53                   	push   %ebx
  8047f1:	83 ec 5c             	sub    $0x5c,%esp
  8047f4:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8047f7:	8b 45 08             	mov    0x8(%ebp),%eax
  8047fa:	e8 31 ed ff ff       	call   803530 <get_socket>
  8047ff:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804801:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  804807:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80480c:	85 db                	test   %ebx,%ebx
  80480e:	0f 84 15 02 00 00    	je     804a29 <lwip_recvfrom+0x23e>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  804814:	89 f0                	mov    %esi,%eax
  804816:	83 e0 08             	and    $0x8,%eax
  804819:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80481c:	83 e6 01             	and    $0x1,%esi
  80481f:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  804822:	8b 73 04             	mov    0x4(%ebx),%esi
  804825:	85 f6                	test   %esi,%esi
  804827:	75 7d                	jne    8048a6 <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  804829:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  80482d:	75 06                	jne    804835 <lwip_recvfrom+0x4a>
  80482f:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  804833:	74 22                	je     804857 <lwip_recvfrom+0x6c>
  804835:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  80483a:	75 1b                	jne    804857 <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  80483c:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  804843:	c7 05 a0 e5 b3 00 0b 	movl   $0xb,0xb3e5a0
  80484a:	00 00 00 
  80484d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  804852:	e9 d2 01 00 00       	jmp    804a29 <lwip_recvfrom+0x23e>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  804857:	8b 03                	mov    (%ebx),%eax
  804859:	89 04 24             	mov    %eax,(%esp)
  80485c:	e8 08 a1 00 00       	call   80e969 <netconn_recv>
  804861:	89 c6                	mov    %eax,%esi
  804863:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  804866:	85 c0                	test   %eax,%eax
  804868:	75 3c                	jne    8048a6 <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80486a:	8b 13                	mov    (%ebx),%edx
  80486c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  804870:	74 0b                	je     80487d <lwip_recvfrom+0x92>
  804872:	b8 6e 00 00 00       	mov    $0x6e,%eax
  804877:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80487b:	74 17                	je     804894 <lwip_recvfrom+0xa9>
  80487d:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  804881:	f7 da                	neg    %edx
  804883:	b8 05 00 00 00       	mov    $0x5,%eax
  804888:	83 fa 0e             	cmp    $0xe,%edx
  80488b:	77 07                	ja     804894 <lwip_recvfrom+0xa9>
  80488d:	8b 04 95 80 2d 81 00 	mov    0x812d80(,%edx,4),%eax
  804894:	89 43 10             	mov    %eax,0x10(%ebx)
  804897:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  80489c:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  8048a1:	e9 83 01 00 00       	jmp    804a29 <lwip_recvfrom+0x23e>
      }
    }

    buflen = netbuf_len(buf);
  8048a6:	8b 06                	mov    (%esi),%eax
  8048a8:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8048ac:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  8048b0:	66 29 d1             	sub    %dx,%cx
  8048b3:	66 89 4d c0          	mov    %cx,-0x40(%ebp)

    if (len > buflen) {
  8048b7:	0f b7 c9             	movzwl %cx,%ecx
  8048ba:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8048bd:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
    buflen = netbuf_len(buf);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;

    if (len > buflen) {
  8048c1:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8048c4:	7e 04                	jle    8048ca <lwip_recvfrom+0xdf>
  8048c6:	0f b7 7d c0          	movzwl -0x40(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8048ca:	0f b7 cf             	movzwl %di,%ecx
  8048cd:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8048d0:	0f b7 d2             	movzwl %dx,%edx
  8048d3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8048d7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8048db:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  8048df:	03 55 0c             	add    0xc(%ebp),%edx
  8048e2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8048e6:	89 04 24             	mov    %eax,(%esp)
  8048e9:	e8 68 33 00 00       	call   807c56 <pbuf_copy_partial>

    off += copylen;
  8048ee:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8048f2:	8b 03                	mov    (%ebx),%eax
  8048f4:	89 04 24             	mov    %eax,(%esp)
  8048f7:	e8 94 9c 00 00       	call   80e590 <netconn_type>
  8048fc:	83 f8 10             	cmp    $0x10,%eax
  8048ff:	75 1f                	jne    804920 <lwip_recvfrom+0x135>
      len -= copylen;
  804901:	8b 45 c0             	mov    -0x40(%ebp),%eax
  804904:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  804907:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80490b:	7e 13                	jle    804920 <lwip_recvfrom+0x135>
  80490d:	8b 06                	mov    (%esi),%eax
  80490f:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  804913:	75 0b                	jne    804920 <lwip_recvfrom+0x135>
  804915:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  804919:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  80491e:	75 04                	jne    804924 <lwip_recvfrom+0x139>
  804920:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  804924:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  804928:	75 39                	jne    804963 <lwip_recvfrom+0x178>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80492a:	8b 03                	mov    (%ebx),%eax
  80492c:	83 38 10             	cmpl   $0x10,(%eax)
  80492f:	75 13                	jne    804944 <lwip_recvfrom+0x159>
  804931:	8b 45 bc             	mov    -0x44(%ebp),%eax
  804934:	2b 45 c0             	sub    -0x40(%ebp),%eax
  804937:	85 c0                	test   %eax,%eax
  804939:	7e 09                	jle    804944 <lwip_recvfrom+0x159>
        sock->lastdata = buf;
  80493b:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  80493e:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  804942:	eb 15                	jmp    804959 <lwip_recvfrom+0x16e>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  804944:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  80494b:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  804951:	89 34 24             	mov    %esi,(%esp)
  804954:	e8 a5 0c 00 00       	call   8055fe <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  804959:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  80495d:	0f 84 bf fe ff ff    	je     804822 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  804963:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  804967:	0f 84 a7 00 00 00    	je     804a14 <lwip_recvfrom+0x229>
  80496d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804971:	0f 84 9d 00 00 00    	je     804a14 <lwip_recvfrom+0x229>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  804977:	8b 03                	mov    (%ebx),%eax
  804979:	89 04 24             	mov    %eax,(%esp)
  80497c:	e8 0f 9c 00 00       	call   80e590 <netconn_type>
  804981:	83 f8 10             	cmp    $0x10,%eax
  804984:	75 22                	jne    8049a8 <lwip_recvfrom+0x1bd>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  804986:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  804989:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804990:	00 
  804991:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  804994:	89 44 24 08          	mov    %eax,0x8(%esp)
  804998:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80499c:	8b 03                	mov    (%ebx),%eax
  80499e:	89 04 24             	mov    %eax,(%esp)
  8049a1:	e8 9d 9e 00 00       	call   80e843 <netconn_getaddr>
  8049a6:	eb 0b                	jmp    8049b3 <lwip_recvfrom+0x1c8>
    } else {
      addr = netbuf_fromaddr(buf);
  8049a8:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  8049ab:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8049af:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  8049b3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8049ba:	00 
  8049bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8049c2:	00 
  8049c3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8049c6:	89 04 24             	mov    %eax,(%esp)
  8049c9:	e8 a8 c8 ff ff       	call   801276 <memset>
    sin.sin_len = sizeof(sin);
  8049ce:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8049d2:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8049d6:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8049da:	89 04 24             	mov    %eax,(%esp)
  8049dd:	e8 f2 62 00 00       	call   80acd4 <htons>
  8049e2:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8049e6:	8b 07                	mov    (%edi),%eax
  8049e8:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8049eb:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8049ee:	83 3a 10             	cmpl   $0x10,(%edx)
  8049f1:	76 06                	jbe    8049f9 <lwip_recvfrom+0x20e>
      *fromlen = sizeof(sin);
  8049f3:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  8049f9:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8049fc:	8b 01                	mov    (%ecx),%eax
  8049fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a02:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804a05:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a09:	8b 7d 18             	mov    0x18(%ebp),%edi
  804a0c:	89 3c 24             	mov    %edi,(%esp)
  804a0f:	e8 3d c9 ff ff       	call   801351 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  804a14:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804a1b:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804a22:	00 00 00 
  return off;
  804a25:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  804a29:	83 c4 5c             	add    $0x5c,%esp
  804a2c:	5b                   	pop    %ebx
  804a2d:	5e                   	pop    %esi
  804a2e:	5f                   	pop    %edi
  804a2f:	5d                   	pop    %ebp
  804a30:	c3                   	ret    

00804a31 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  804a31:	55                   	push   %ebp
  804a32:	89 e5                	mov    %esp,%ebp
  804a34:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  804a37:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804a3e:	00 
  804a3f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804a46:	00 
  804a47:	8b 45 14             	mov    0x14(%ebp),%eax
  804a4a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804a4e:	8b 45 10             	mov    0x10(%ebp),%eax
  804a51:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a55:	8b 45 0c             	mov    0xc(%ebp),%eax
  804a58:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a5c:	8b 45 08             	mov    0x8(%ebp),%eax
  804a5f:	89 04 24             	mov    %eax,(%esp)
  804a62:	e8 84 fd ff ff       	call   8047eb <lwip_recvfrom>
}
  804a67:	c9                   	leave  
  804a68:	c3                   	ret    

00804a69 <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  804a69:	55                   	push   %ebp
  804a6a:	89 e5                	mov    %esp,%ebp
  804a6c:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804a6f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804a76:	00 
  804a77:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804a7e:	00 
  804a7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804a86:	00 
  804a87:	8b 45 10             	mov    0x10(%ebp),%eax
  804a8a:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  804a91:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a95:	8b 45 08             	mov    0x8(%ebp),%eax
  804a98:	89 04 24             	mov    %eax,(%esp)
  804a9b:	e8 4b fd ff ff       	call   8047eb <lwip_recvfrom>
}
  804aa0:	c9                   	leave  
  804aa1:	c3                   	ret    

00804aa2 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804aa2:	55                   	push   %ebp
  804aa3:	89 e5                	mov    %esp,%ebp
  804aa5:	53                   	push   %ebx
  804aa6:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  804aa9:	8b 45 08             	mov    0x8(%ebp),%eax
  804aac:	e8 7f ea ff ff       	call   803530 <get_socket>
  804ab1:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804ab3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804ab8:	85 db                	test   %ebx,%ebx
  804aba:	74 5c                	je     804b18 <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804abc:	8b 03                	mov    (%ebx),%eax
  804abe:	89 04 24             	mov    %eax,(%esp)
  804ac1:	e8 55 a0 00 00       	call   80eb1b <netconn_delete>

  sys_sem_wait(socksem);
  804ac6:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  804acb:	89 04 24             	mov    %eax,(%esp)
  804ace:	e8 e7 3a 00 00       	call   8085ba <sys_sem_wait>
  if (sock->lastdata) {
  804ad3:	8b 43 04             	mov    0x4(%ebx),%eax
  804ad6:	85 c0                	test   %eax,%eax
  804ad8:	74 08                	je     804ae2 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  804ada:	89 04 24             	mov    %eax,(%esp)
  804add:	e8 1c 0b 00 00       	call   8055fe <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804ae2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  804ae9:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  804aef:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  804af5:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804afc:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804b03:	00 00 00 
  sys_sem_signal(socksem);
  804b06:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  804b0b:	89 04 24             	mov    %eax,(%esp)
  804b0e:	e8 94 90 00 00       	call   80dba7 <sys_sem_signal>
  804b13:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804b18:	83 c4 14             	add    $0x14,%esp
  804b1b:	5b                   	pop    %ebx
  804b1c:	5d                   	pop    %ebp
  804b1d:	c3                   	ret    

00804b1e <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  804b1e:	55                   	push   %ebp
  804b1f:	89 e5                	mov    %esp,%ebp
  804b21:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  804b24:	8b 45 08             	mov    0x8(%ebp),%eax
  804b27:	89 04 24             	mov    %eax,(%esp)
  804b2a:	e8 73 ff ff ff       	call   804aa2 <lwip_close>
}
  804b2f:	c9                   	leave  
  804b30:	c3                   	ret    

00804b31 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  804b31:	55                   	push   %ebp
  804b32:	89 e5                	mov    %esp,%ebp
  804b34:	56                   	push   %esi
  804b35:	53                   	push   %ebx
  804b36:	83 ec 10             	sub    $0x10,%esp
  804b39:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  804b3c:	8b 45 08             	mov    0x8(%ebp),%eax
  804b3f:	e8 ec e9 ff ff       	call   803530 <get_socket>
  804b44:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804b46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804b4b:	85 db                	test   %ebx,%ebx
  804b4d:	74 6a                	je     804bb9 <lwip_listen+0x88>
  804b4f:	89 f0                	mov    %esi,%eax
  804b51:	c1 f8 1f             	sar    $0x1f,%eax
  804b54:	f7 d0                	not    %eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  804b56:	21 c6                	and    %eax,%esi
  804b58:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  804b5e:	7e 05                	jle    804b65 <lwip_listen+0x34>
  804b60:	be ff 00 00 00       	mov    $0xff,%esi
  804b65:	81 e6 ff 00 00 00    	and    $0xff,%esi
  804b6b:	89 74 24 04          	mov    %esi,0x4(%esp)
  804b6f:	8b 03                	mov    (%ebx),%eax
  804b71:	89 04 24             	mov    %eax,(%esp)
  804b74:	e8 8a 9b 00 00       	call   80e703 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  804b79:	84 c0                	test   %al,%al
  804b7b:	74 26                	je     804ba3 <lwip_listen+0x72>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804b7d:	0f be c0             	movsbl %al,%eax
  804b80:	f7 d8                	neg    %eax
  804b82:	ba 05 00 00 00       	mov    $0x5,%edx
  804b87:	83 f8 0e             	cmp    $0xe,%eax
  804b8a:	77 07                	ja     804b93 <lwip_listen+0x62>
  804b8c:	8b 14 85 80 2d 81 00 	mov    0x812d80(,%eax,4),%edx
  804b93:	89 53 10             	mov    %edx,0x10(%ebx)
  804b96:	89 15 a0 e5 b3 00    	mov    %edx,0xb3e5a0
  804b9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804ba1:	eb 16                	jmp    804bb9 <lwip_listen+0x88>
  }

  sock_set_errno(sock, 0);
  804ba3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804baa:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804bb1:	00 00 00 
  804bb4:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804bb9:	83 c4 10             	add    $0x10,%esp
  804bbc:	5b                   	pop    %ebx
  804bbd:	5e                   	pop    %esi
  804bbe:	5d                   	pop    %ebp
  804bbf:	c3                   	ret    

00804bc0 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804bc0:	55                   	push   %ebp
  804bc1:	89 e5                	mov    %esp,%ebp
  804bc3:	53                   	push   %ebx
  804bc4:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  804bc7:	8b 45 08             	mov    0x8(%ebp),%eax
  804bca:	e8 61 e9 ff ff       	call   803530 <get_socket>
  804bcf:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804bd1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804bd6:	85 db                	test   %ebx,%ebx
  804bd8:	0f 84 95 00 00 00    	je     804c73 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804bde:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804be2:	75 09                	jne    804bed <lwip_connect+0x2d>
  804be4:	8b 45 0c             	mov    0xc(%ebp),%eax
  804be7:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804beb:	74 1c                	je     804c09 <lwip_connect+0x49>
  804bed:	c7 44 24 08 de 2c 81 	movl   $0x812cde,0x8(%esp)
  804bf4:	00 
  804bf5:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  804bfc:	00 
  804bfd:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  804c04:	e8 73 bd ff ff       	call   80097c <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804c09:	8b 50 04             	mov    0x4(%eax),%edx
  804c0c:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  804c0f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804c13:	89 04 24             	mov    %eax,(%esp)
  804c16:	e8 c6 60 00 00       	call   80ace1 <ntohs>
  804c1b:	0f b7 c0             	movzwl %ax,%eax
  804c1e:	89 44 24 08          	mov    %eax,0x8(%esp)
  804c22:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804c25:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c29:	8b 03                	mov    (%ebx),%eax
  804c2b:	89 04 24             	mov    %eax,(%esp)
  804c2e:	e8 62 9b 00 00       	call   80e795 <netconn_connect>
  }

  if (err != ERR_OK) {
  804c33:	84 c0                	test   %al,%al
  804c35:	74 26                	je     804c5d <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804c37:	0f be c0             	movsbl %al,%eax
  804c3a:	f7 d8                	neg    %eax
  804c3c:	ba 05 00 00 00       	mov    $0x5,%edx
  804c41:	83 f8 0e             	cmp    $0xe,%eax
  804c44:	77 07                	ja     804c4d <lwip_connect+0x8d>
  804c46:	8b 14 85 80 2d 81 00 	mov    0x812d80(,%eax,4),%edx
  804c4d:	89 53 10             	mov    %edx,0x10(%ebx)
  804c50:	89 15 a0 e5 b3 00    	mov    %edx,0xb3e5a0
  804c56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804c5b:	eb 16                	jmp    804c73 <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804c5d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804c64:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804c6b:	00 00 00 
  804c6e:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804c73:	83 c4 24             	add    $0x24,%esp
  804c76:	5b                   	pop    %ebx
  804c77:	5d                   	pop    %ebp
  804c78:	c3                   	ret    

00804c79 <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804c79:	55                   	push   %ebp
  804c7a:	89 e5                	mov    %esp,%ebp
  804c7c:	53                   	push   %ebx
  804c7d:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804c80:	8b 45 08             	mov    0x8(%ebp),%eax
  804c83:	e8 a8 e8 ff ff       	call   803530 <get_socket>
  804c88:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804c8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804c8f:	85 db                	test   %ebx,%ebx
  804c91:	0f 84 95 00 00 00    	je     804d2c <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804c97:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804c9b:	75 09                	jne    804ca6 <lwip_bind+0x2d>
  804c9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ca0:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804ca4:	74 1c                	je     804cc2 <lwip_bind+0x49>
  804ca6:	c7 44 24 08 fc 2c 81 	movl   $0x812cfc,0x8(%esp)
  804cad:	00 
  804cae:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  804cb5:	00 
  804cb6:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  804cbd:	e8 ba bc ff ff       	call   80097c <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804cc2:	8b 50 04             	mov    0x4(%eax),%edx
  804cc5:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  804cc8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804ccc:	89 04 24             	mov    %eax,(%esp)
  804ccf:	e8 0d 60 00 00       	call   80ace1 <ntohs>
  804cd4:	0f b7 c0             	movzwl %ax,%eax
  804cd7:	89 44 24 08          	mov    %eax,0x8(%esp)
  804cdb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804cde:	89 44 24 04          	mov    %eax,0x4(%esp)
  804ce2:	8b 03                	mov    (%ebx),%eax
  804ce4:	89 04 24             	mov    %eax,(%esp)
  804ce7:	e8 00 9b 00 00       	call   80e7ec <netconn_bind>

  if (err != ERR_OK) {
  804cec:	84 c0                	test   %al,%al
  804cee:	74 26                	je     804d16 <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804cf0:	0f be c0             	movsbl %al,%eax
  804cf3:	f7 d8                	neg    %eax
  804cf5:	ba 05 00 00 00       	mov    $0x5,%edx
  804cfa:	83 f8 0e             	cmp    $0xe,%eax
  804cfd:	77 07                	ja     804d06 <lwip_bind+0x8d>
  804cff:	8b 14 85 80 2d 81 00 	mov    0x812d80(,%eax,4),%edx
  804d06:	89 53 10             	mov    %edx,0x10(%ebx)
  804d09:	89 15 a0 e5 b3 00    	mov    %edx,0xb3e5a0
  804d0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804d14:	eb 16                	jmp    804d2c <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804d16:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804d1d:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804d24:	00 00 00 
  804d27:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804d2c:	83 c4 24             	add    $0x24,%esp
  804d2f:	5b                   	pop    %ebx
  804d30:	5d                   	pop    %ebp
  804d31:	c3                   	ret    

00804d32 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804d32:	55                   	push   %ebp
  804d33:	89 e5                	mov    %esp,%ebp
  804d35:	57                   	push   %edi
  804d36:	56                   	push   %esi
  804d37:	53                   	push   %ebx
  804d38:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  804d3b:	8b 45 08             	mov    0x8(%ebp),%eax
  804d3e:	e8 ed e7 ff ff       	call   803530 <get_socket>
  804d43:	89 c7                	mov    %eax,%edi
  if (!sock)
  804d45:	be ff ff ff ff       	mov    $0xffffffff,%esi
  804d4a:	85 c0                	test   %eax,%eax
  804d4c:	0f 84 ae 01 00 00    	je     804f00 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  804d52:	8b 00                	mov    (%eax),%eax
  804d54:	89 04 24             	mov    %eax,(%esp)
  804d57:	e8 83 9b 00 00       	call   80e8df <netconn_accept>
  804d5c:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  804d5e:	85 c0                	test   %eax,%eax
  804d60:	75 2b                	jne    804d8d <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804d62:	8b 07                	mov    (%edi),%eax
  804d64:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  804d68:	f7 da                	neg    %edx
  804d6a:	b8 05 00 00 00       	mov    $0x5,%eax
  804d6f:	83 fa 0e             	cmp    $0xe,%edx
  804d72:	77 07                	ja     804d7b <lwip_accept+0x49>
  804d74:	8b 04 95 80 2d 81 00 	mov    0x812d80(,%edx,4),%eax
  804d7b:	89 47 10             	mov    %eax,0x10(%edi)
  804d7e:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  804d83:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804d88:	e9 73 01 00 00       	jmp    804f00 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804d8d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804d94:	00 
  804d95:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  804d98:	89 44 24 08          	mov    %eax,0x8(%esp)
  804d9c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804d9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  804da3:	89 1c 24             	mov    %ebx,(%esp)
  804da6:	e8 98 9a 00 00       	call   80e843 <netconn_getaddr>
  804dab:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  804dad:	84 c0                	test   %al,%al
  804daf:	74 32                	je     804de3 <lwip_accept+0xb1>
    netconn_delete(newconn);
  804db1:	89 1c 24             	mov    %ebx,(%esp)
  804db4:	e8 62 9d 00 00       	call   80eb1b <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  804db9:	89 f0                	mov    %esi,%eax
  804dbb:	0f be f0             	movsbl %al,%esi
  804dbe:	f7 de                	neg    %esi
  804dc0:	b8 05 00 00 00       	mov    $0x5,%eax
  804dc5:	83 fe 0e             	cmp    $0xe,%esi
  804dc8:	77 07                	ja     804dd1 <lwip_accept+0x9f>
  804dca:	8b 04 b5 80 2d 81 00 	mov    0x812d80(,%esi,4),%eax
  804dd1:	89 47 10             	mov    %eax,0x10(%edi)
  804dd4:	a3 a0 e5 b3 00       	mov    %eax,0xb3e5a0
  804dd9:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804dde:	e9 1d 01 00 00       	jmp    804f00 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  804de3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804dea:	00 
  804deb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804df2:	00 
  804df3:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804df6:	89 04 24             	mov    %eax,(%esp)
  804df9:	e8 78 c4 ff ff       	call   801276 <memset>
  sin.sin_len = sizeof(sin);
  804dfe:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  804e02:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  804e06:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  804e0a:	89 04 24             	mov    %eax,(%esp)
  804e0d:	e8 c2 5e 00 00       	call   80acd4 <htons>
  804e12:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  804e16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804e19:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  804e1c:	8b 55 10             	mov    0x10(%ebp),%edx
  804e1f:	83 3a 10             	cmpl   $0x10,(%edx)
  804e22:	76 06                	jbe    804e2a <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  804e24:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  804e2a:	8b 55 10             	mov    0x10(%ebp),%edx
  804e2d:	8b 02                	mov    (%edx),%eax
  804e2f:	89 44 24 08          	mov    %eax,0x8(%esp)
  804e33:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804e36:	89 44 24 04          	mov    %eax,0x4(%esp)
  804e3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e3d:	89 04 24             	mov    %eax,(%esp)
  804e40:	e8 0c c5 ff ff       	call   801351 <memcpy>

  newsock = alloc_socket(newconn);
  804e45:	89 d8                	mov    %ebx,%eax
  804e47:	e8 7d f0 ff ff       	call   803ec9 <alloc_socket>
  804e4c:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  804e4e:	83 f8 ff             	cmp    $0xffffffff,%eax
  804e51:	75 1e                	jne    804e71 <lwip_accept+0x13f>
    netconn_delete(newconn);
  804e53:	89 1c 24             	mov    %ebx,(%esp)
  804e56:	e8 c0 9c 00 00       	call   80eb1b <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804e5b:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804e62:	c7 05 a0 e5 b3 00 17 	movl   $0x17,0xb3e5a0
  804e69:	00 00 00 
    return -1;
  804e6c:	e9 8f 00 00 00       	jmp    804f00 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804e71:	83 fe 1f             	cmp    $0x1f,%esi
  804e74:	76 1c                	jbe    804e92 <lwip_accept+0x160>
  804e76:	c7 44 24 08 17 2d 81 	movl   $0x812d17,0x8(%esp)
  804e7d:	00 
  804e7e:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  804e85:	00 
  804e86:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  804e8d:	e8 ea ba ff ff       	call   80097c <_panic>
  newconn->callback = event_callback;
  804e92:	c7 43 2c 6d 3f 80 00 	movl   $0x803f6d,0x2c(%ebx)
  nsock = &sockets[newsock];
  804e99:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804e9c:	8d 04 85 20 84 81 00 	lea    0x818420(,%eax,4),%eax
  804ea3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  804ea6:	85 c0                	test   %eax,%eax
  804ea8:	75 1c                	jne    804ec6 <lwip_accept+0x194>
  804eaa:	c7 44 24 08 2c 2d 81 	movl   $0x812d2c,0x8(%esp)
  804eb1:	00 
  804eb2:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  804eb9:	00 
  804eba:	c7 04 24 9c 2c 81 00 	movl   $0x812c9c,(%esp)
  804ec1:	e8 b6 ba ff ff       	call   80097c <_panic>

  sys_sem_wait(socksem);
  804ec6:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  804ecb:	89 04 24             	mov    %eax,(%esp)
  804ece:	e8 e7 36 00 00       	call   8085ba <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804ed3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  804ed6:	f7 d0                	not    %eax
  804ed8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804edb:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  804edf:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  804ee2:	a1 a4 86 81 00       	mov    0x8186a4,%eax
  804ee7:	89 04 24             	mov    %eax,(%esp)
  804eea:	e8 b8 8c 00 00       	call   80dba7 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  804eef:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  804ef6:	c7 05 a0 e5 b3 00 00 	movl   $0x0,0xb3e5a0
  804efd:	00 00 00 
  return newsock;
}
  804f00:	89 f0                	mov    %esi,%eax
  804f02:	83 c4 4c             	add    $0x4c,%esp
  804f05:	5b                   	pop    %ebx
  804f06:	5e                   	pop    %esi
  804f07:	5f                   	pop    %edi
  804f08:	5d                   	pop    %ebp
  804f09:	c3                   	ret    
  804f0a:	00 00                	add    %al,(%eax)
  804f0c:	00 00                	add    %al,(%eax)
	...

00804f10 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  804f10:	55                   	push   %ebp
  804f11:	89 e5                	mov    %esp,%ebp
  804f13:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  804f16:	8b 45 08             	mov    0x8(%ebp),%eax
  804f19:	89 04 24             	mov    %eax,(%esp)
  804f1c:	e8 b7 2f 00 00       	call   807ed8 <pbuf_free>
}
  804f21:	c9                   	leave  
  804f22:	c3                   	ret    

00804f23 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  804f23:	55                   	push   %ebp
  804f24:	89 e5                	mov    %esp,%ebp
  804f26:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  804f29:	e8 62 08 00 00       	call   805790 <lwip_init>

  tcpip_init_done = initfunc;
  804f2e:	8b 45 08             	mov    0x8(%ebp),%eax
  804f31:	a3 ac 86 81 00       	mov    %eax,0x8186ac
  tcpip_init_done_arg = arg;
  804f36:	8b 45 0c             	mov    0xc(%ebp),%eax
  804f39:	a3 b0 86 81 00       	mov    %eax,0x8186b0
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  804f3e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804f45:	e8 45 8b 00 00       	call   80da8f <sys_mbox_new>
  804f4a:	a3 74 80 81 00       	mov    %eax,0x818074
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  804f4f:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  804f56:	00 
  804f57:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804f5e:	00 
  804f5f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f66:	00 
  804f67:	c7 44 24 04 c6 4f 80 	movl   $0x804fc6,0x4(%esp)
  804f6e:	00 
  804f6f:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  804f76:	e8 7f 88 00 00       	call   80d7fa <sys_thread_new>
}
  804f7b:	c9                   	leave  
  804f7c:	c3                   	ret    

00804f7d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804f7d:	55                   	push   %ebp
  804f7e:	89 e5                	mov    %esp,%ebp
  804f80:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804f83:	83 3d b4 86 81 00 00 	cmpl   $0x0,0x8186b4
  804f8a:	75 38                	jne    804fc4 <tcp_timer_needed+0x47>
  804f8c:	83 3d 08 e6 b3 00 00 	cmpl   $0x0,0xb3e608
  804f93:	75 09                	jne    804f9e <tcp_timer_needed+0x21>
  804f95:	83 3d 1c e6 b3 00 00 	cmpl   $0x0,0xb3e61c
  804f9c:	74 26                	je     804fc4 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804f9e:	c7 05 b4 86 81 00 01 	movl   $0x1,0x8186b4
  804fa5:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804fa8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804faf:	00 
  804fb0:	c7 44 24 04 e1 53 80 	movl   $0x8053e1,0x4(%esp)
  804fb7:	00 
  804fb8:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804fbf:	e8 26 35 00 00       	call   8084ea <sys_timeout>
  }
}
  804fc4:	c9                   	leave  
  804fc5:	c3                   	ret    

00804fc6 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804fc6:	55                   	push   %ebp
  804fc7:	89 e5                	mov    %esp,%ebp
  804fc9:	53                   	push   %ebx
  804fca:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804fcd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804fd4:	00 
  804fd5:	c7 44 24 04 be 51 80 	movl   $0x8051be,0x4(%esp)
  804fdc:	00 
  804fdd:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804fe4:	e8 01 35 00 00       	call   8084ea <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804fe9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804ff0:	00 
  804ff1:	c7 44 24 04 95 51 80 	movl   $0x805195,0x4(%esp)
  804ff8:	00 
  804ff9:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  805000:	e8 e5 34 00 00       	call   8084ea <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  805005:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80500c:	00 
  80500d:	c7 44 24 04 6c 51 80 	movl   $0x80516c,0x4(%esp)
  805014:	00 
  805015:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80501c:	e8 c9 34 00 00       	call   8084ea <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  805021:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805028:	00 
  805029:	c7 44 24 04 43 51 80 	movl   $0x805143,0x4(%esp)
  805030:	00 
  805031:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  805038:	e8 ad 34 00 00       	call   8084ea <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80503d:	a1 ac 86 81 00       	mov    0x8186ac,%eax
  805042:	85 c0                	test   %eax,%eax
  805044:	74 0b                	je     805051 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  805046:	8b 15 b0 86 81 00    	mov    0x8186b0,%edx
  80504c:	89 14 24             	mov    %edx,(%esp)
  80504f:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  805051:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  805054:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805058:	a1 74 80 81 00       	mov    0x818074,%eax
  80505d:	89 04 24             	mov    %eax,(%esp)
  805060:	e8 77 36 00 00       	call   8086dc <sys_mbox_fetch>
    switch (msg->type) {
  805065:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805068:	8b 10                	mov    (%eax),%edx
  80506a:	83 fa 01             	cmp    $0x1,%edx
  80506d:	74 28                	je     805097 <tcpip_thread+0xd1>
  80506f:	83 fa 01             	cmp    $0x1,%edx
  805072:	72 16                	jb     80508a <tcpip_thread+0xc4>
  805074:	83 fa 02             	cmp    $0x2,%edx
  805077:	74 5f                	je     8050d8 <tcpip_thread+0x112>
  805079:	83 fa 03             	cmp    $0x3,%edx
  80507c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  805080:	75 d2                	jne    805054 <tcpip_thread+0x8e>
  805082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  805088:	eb 6f                	jmp    8050f9 <tcpip_thread+0x133>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80508a:	8b 40 08             	mov    0x8(%eax),%eax
  80508d:	8d 50 04             	lea    0x4(%eax),%edx
  805090:	89 14 24             	mov    %edx,(%esp)
  805093:	ff 10                	call   *(%eax)
      break;
  805095:	eb bd                	jmp    805054 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  805097:	8b 50 0c             	mov    0xc(%eax),%edx
  80509a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  80509e:	74 11                	je     8050b1 <tcpip_thread+0xeb>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8050a0:	89 54 24 04          	mov    %edx,0x4(%esp)
  8050a4:	8b 40 08             	mov    0x8(%eax),%eax
  8050a7:	89 04 24             	mov    %eax,(%esp)
  8050aa:	e8 78 83 00 00       	call   80d427 <ethernet_input>
  8050af:	eb 0f                	jmp    8050c0 <tcpip_thread+0xfa>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8050b1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8050b5:	8b 40 08             	mov    0x8(%eax),%eax
  8050b8:	89 04 24             	mov    %eax,(%esp)
  8050bb:	e8 d4 4a 00 00       	call   809b94 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8050c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050c7:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8050ce:	e8 6d 26 00 00       	call   807740 <memp_free>
      break;
  8050d3:	e9 7c ff ff ff       	jmp    805054 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8050d8:	8b 50 0c             	mov    0xc(%eax),%edx
  8050db:	89 14 24             	mov    %edx,(%esp)
  8050de:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8050e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8050e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050e8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8050ef:	e8 4c 26 00 00       	call   807740 <memp_free>
      break;
  8050f4:	e9 5b ff ff ff       	jmp    805054 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8050f9:	8b 50 08             	mov    0x8(%eax),%edx
  8050fc:	83 fa ff             	cmp    $0xffffffff,%edx
  8050ff:	74 18                	je     805119 <tcpip_thread+0x153>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  805101:	8b 48 10             	mov    0x10(%eax),%ecx
  805104:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  805108:	8b 40 0c             	mov    0xc(%eax),%eax
  80510b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80510f:	89 14 24             	mov    %edx,(%esp)
  805112:	e8 d3 33 00 00       	call   8084ea <sys_timeout>
  805117:	eb 12                	jmp    80512b <tcpip_thread+0x165>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  805119:	8b 50 10             	mov    0x10(%eax),%edx
  80511c:	89 54 24 04          	mov    %edx,0x4(%esp)
  805120:	8b 40 0c             	mov    0xc(%eax),%eax
  805123:	89 04 24             	mov    %eax,(%esp)
  805126:	e8 32 33 00 00       	call   80845d <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80512b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80512e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805132:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  805139:	e8 02 26 00 00       	call   807740 <memp_free>
  80513e:	e9 11 ff ff ff       	jmp    805054 <tcpip_thread+0x8e>

00805143 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  805143:	55                   	push   %ebp
  805144:	89 e5                	mov    %esp,%ebp
  805146:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  805149:	e8 f4 1e 00 00       	call   807042 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80514e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805155:	00 
  805156:	c7 44 24 04 43 51 80 	movl   $0x805143,0x4(%esp)
  80515d:	00 
  80515e:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  805165:	e8 80 33 00 00       	call   8084ea <sys_timeout>
}
  80516a:	c9                   	leave  
  80516b:	c3                   	ret    

0080516c <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  80516c:	55                   	push   %ebp
  80516d:	89 e5                	mov    %esp,%ebp
  80516f:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  805172:	e8 92 12 00 00       	call   806409 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  805177:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80517e:	00 
  80517f:	c7 44 24 04 6c 51 80 	movl   $0x80516c,0x4(%esp)
  805186:	00 
  805187:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80518e:	e8 57 33 00 00       	call   8084ea <sys_timeout>
}
  805193:	c9                   	leave  
  805194:	c3                   	ret    

00805195 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  805195:	55                   	push   %ebp
  805196:	89 e5                	mov    %esp,%ebp
  805198:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80519b:	e8 5c 7e 00 00       	call   80cffc <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8051a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051a7:	00 
  8051a8:	c7 44 24 04 95 51 80 	movl   $0x805195,0x4(%esp)
  8051af:	00 
  8051b0:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8051b7:	e8 2e 33 00 00       	call   8084ea <sys_timeout>
}
  8051bc:	c9                   	leave  
  8051bd:	c3                   	ret    

008051be <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8051be:	55                   	push   %ebp
  8051bf:	89 e5                	mov    %esp,%ebp
  8051c1:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  8051c4:	e8 ac 50 00 00       	call   80a275 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8051c9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051d0:	00 
  8051d1:	c7 44 24 04 be 51 80 	movl   $0x8051be,0x4(%esp)
  8051d8:	00 
  8051d9:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8051e0:	e8 05 33 00 00       	call   8084ea <sys_timeout>
}
  8051e5:	c9                   	leave  
  8051e6:	c3                   	ret    

008051e7 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8051e7:	55                   	push   %ebp
  8051e8:	89 e5                	mov    %esp,%ebp
  8051ea:	53                   	push   %ebx
  8051eb:	83 ec 34             	sub    $0x34,%esp
  8051ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8051f1:	8b 15 74 80 81 00    	mov    0x818074,%edx
  8051f7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8051fc:	83 fa ff             	cmp    $0xffffffff,%edx
  8051ff:	74 34                	je     805235 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  805201:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  805208:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  80520b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80520e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805212:	89 14 24             	mov    %edx,(%esp)
  805215:	e8 ec 8b 00 00       	call   80de06 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80521a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805221:	00 
  805222:	8b 43 04             	mov    0x4(%ebx),%eax
  805225:	8b 40 10             	mov    0x10(%eax),%eax
  805228:	89 04 24             	mov    %eax,(%esp)
  80522b:	e8 86 86 00 00       	call   80d8b6 <sys_arch_sem_wait>
  805230:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  805235:	83 c4 34             	add    $0x34,%esp
  805238:	5b                   	pop    %ebx
  805239:	5d                   	pop    %ebp
  80523a:	c3                   	ret    

0080523b <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80523b:	55                   	push   %ebp
  80523c:	89 e5                	mov    %esp,%ebp
  80523e:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  805241:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  805246:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  80524d:	74 45                	je     805294 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80524f:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  805256:	e8 29 25 00 00       	call   807784 <memp_malloc>
  80525b:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  80525d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805262:	85 d2                	test   %edx,%edx
  805264:	74 2e                	je     805294 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  805266:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  80526c:	8b 45 08             	mov    0x8(%ebp),%eax
  80526f:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  805272:	8b 45 0c             	mov    0xc(%ebp),%eax
  805275:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  805278:	8b 45 10             	mov    0x10(%ebp),%eax
  80527b:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  80527e:	89 54 24 04          	mov    %edx,0x4(%esp)
  805282:	a1 74 80 81 00       	mov    0x818074,%eax
  805287:	89 04 24             	mov    %eax,(%esp)
  80528a:	e8 77 8b 00 00       	call   80de06 <sys_mbox_post>
  80528f:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  805294:	c9                   	leave  
  805295:	c3                   	ret    

00805296 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  805296:	55                   	push   %ebp
  805297:	89 e5                	mov    %esp,%ebp
  805299:	83 ec 18             	sub    $0x18,%esp
  80529c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80529f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8052a2:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8052a6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8052ab:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  8052b2:	74 6f                	je     805323 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8052b4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8052bb:	e8 c4 24 00 00       	call   807784 <memp_malloc>
  8052c0:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  8052c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8052c7:	85 f6                	test   %esi,%esi
  8052c9:	74 58                	je     805323 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  8052cb:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  8052d1:	8b 45 08             	mov    0x8(%ebp),%eax
  8052d4:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  8052d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8052da:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  8052dd:	84 db                	test   %bl,%bl
  8052df:	74 18                	je     8052f9 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  8052e1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8052e5:	a1 74 80 81 00       	mov    0x818074,%eax
  8052ea:	89 04 24             	mov    %eax,(%esp)
  8052ed:	e8 14 8b 00 00       	call   80de06 <sys_mbox_post>
  8052f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8052f7:	eb 2a                	jmp    805323 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8052f9:	89 74 24 04          	mov    %esi,0x4(%esp)
  8052fd:	a1 74 80 81 00       	mov    0x818074,%eax
  805302:	89 04 24             	mov    %eax,(%esp)
  805305:	e8 2e 8a 00 00       	call   80dd38 <sys_mbox_trypost>
  80530a:	84 c0                	test   %al,%al
  80530c:	74 15                	je     805323 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80530e:	89 74 24 04          	mov    %esi,0x4(%esp)
  805312:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  805319:	e8 22 24 00 00       	call   807740 <memp_free>
  80531e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  805323:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805326:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805329:	89 ec                	mov    %ebp,%esp
  80532b:	5d                   	pop    %ebp
  80532c:	c3                   	ret    

0080532d <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  80532d:	55                   	push   %ebp
  80532e:	89 e5                	mov    %esp,%ebp
  805330:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  805333:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80533a:	00 
  80533b:	8b 45 08             	mov    0x8(%ebp),%eax
  80533e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805342:	c7 04 24 ce 74 80 00 	movl   $0x8074ce,(%esp)
  805349:	e8 48 ff ff ff       	call   805296 <tcpip_callback_with_block>
}
  80534e:	c9                   	leave  
  80534f:	c3                   	ret    

00805350 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  805350:	55                   	push   %ebp
  805351:	89 e5                	mov    %esp,%ebp
  805353:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  805356:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80535d:	00 
  80535e:	8b 45 08             	mov    0x8(%ebp),%eax
  805361:	89 44 24 04          	mov    %eax,0x4(%esp)
  805365:	c7 04 24 10 4f 80 00 	movl   $0x804f10,(%esp)
  80536c:	e8 25 ff ff ff       	call   805296 <tcpip_callback_with_block>
}
  805371:	c9                   	leave  
  805372:	c3                   	ret    

00805373 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  805373:	55                   	push   %ebp
  805374:	89 e5                	mov    %esp,%ebp
  805376:	53                   	push   %ebx
  805377:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80537a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80537f:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  805386:	74 53                	je     8053db <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  805388:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80538f:	e8 f0 23 00 00       	call   807784 <memp_malloc>
  805394:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  805396:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80539b:	85 db                	test   %ebx,%ebx
  80539d:	74 3c                	je     8053db <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80539f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  8053a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8053a8:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8053ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  8053ae:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8053b1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8053b5:	a1 74 80 81 00       	mov    0x818074,%eax
  8053ba:	89 04 24             	mov    %eax,(%esp)
  8053bd:	e8 76 89 00 00       	call   80dd38 <sys_mbox_trypost>
  8053c2:	84 c0                	test   %al,%al
  8053c4:	74 15                	je     8053db <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8053c6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8053ca:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8053d1:	e8 6a 23 00 00       	call   807740 <memp_free>
  8053d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8053db:	83 c4 14             	add    $0x14,%esp
  8053de:	5b                   	pop    %ebx
  8053df:	5d                   	pop    %ebp
  8053e0:	c3                   	ret    

008053e1 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8053e1:	55                   	push   %ebp
  8053e2:	89 e5                	mov    %esp,%ebp
  8053e4:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8053e7:	e8 2c 43 00 00       	call   809718 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8053ec:	83 3d 08 e6 b3 00 00 	cmpl   $0x0,0xb3e608
  8053f3:	75 09                	jne    8053fe <tcpip_tcp_timer+0x1d>
  8053f5:	83 3d 1c e6 b3 00 00 	cmpl   $0x0,0xb3e61c
  8053fc:	74 1e                	je     80541c <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8053fe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805405:	00 
  805406:	c7 44 24 04 e1 53 80 	movl   $0x8053e1,0x4(%esp)
  80540d:	00 
  80540e:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  805415:	e8 d0 30 00 00       	call   8084ea <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80541a:	eb 0a                	jmp    805426 <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80541c:	c7 05 b4 86 81 00 00 	movl   $0x0,0x8186b4
  805423:	00 00 00 
  }
}
  805426:	c9                   	leave  
  805427:	c3                   	ret    

00805428 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  805428:	55                   	push   %ebp
  805429:	89 e5                	mov    %esp,%ebp
  80542b:	83 ec 18             	sub    $0x18,%esp
  80542e:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  805431:	85 c0                	test   %eax,%eax
  805433:	75 1c                	jne    805451 <netbuf_first+0x29>
  805435:	c7 44 24 08 d3 2d 81 	movl   $0x812dd3,0x8(%esp)
  80543c:	00 
  80543d:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  805444:	00 
  805445:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  80544c:	e8 2b b5 ff ff       	call   80097c <_panic>
  buf->ptr = buf->p;
  805451:	8b 10                	mov    (%eax),%edx
  805453:	89 50 04             	mov    %edx,0x4(%eax)
}
  805456:	c9                   	leave  
  805457:	c3                   	ret    

00805458 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  805458:	55                   	push   %ebp
  805459:	89 e5                	mov    %esp,%ebp
  80545b:	83 ec 18             	sub    $0x18,%esp
  80545e:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  805461:	85 d2                	test   %edx,%edx
  805463:	75 1c                	jne    805481 <netbuf_next+0x29>
  805465:	c7 44 24 08 d3 2d 81 	movl   $0x812dd3,0x8(%esp)
  80546c:	00 
  80546d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  805474:	00 
  805475:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  80547c:	e8 fb b4 ff ff       	call   80097c <_panic>
  if (buf->ptr->next == NULL) {
  805481:	8b 42 04             	mov    0x4(%edx),%eax
  805484:	8b 08                	mov    (%eax),%ecx
  805486:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80548b:	85 c9                	test   %ecx,%ecx
  80548d:	74 09                	je     805498 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80548f:	89 4a 04             	mov    %ecx,0x4(%edx)
  805492:	83 39 00             	cmpl   $0x0,(%ecx)
  805495:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  805498:	c9                   	leave  
  805499:	c3                   	ret    

0080549a <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80549a:	55                   	push   %ebp
  80549b:	89 e5                	mov    %esp,%ebp
  80549d:	56                   	push   %esi
  80549e:	53                   	push   %ebx
  80549f:	83 ec 10             	sub    $0x10,%esp
  8054a2:	8b 55 08             	mov    0x8(%ebp),%edx
  8054a5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8054a8:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8054ab:	85 d2                	test   %edx,%edx
  8054ad:	75 1c                	jne    8054cb <netbuf_data+0x31>
  8054af:	c7 44 24 08 02 2e 81 	movl   $0x812e02,0x8(%esp)
  8054b6:	00 
  8054b7:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  8054be:	00 
  8054bf:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  8054c6:	e8 b1 b4 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8054cb:	85 db                	test   %ebx,%ebx
  8054cd:	75 1c                	jne    8054eb <netbuf_data+0x51>
  8054cf:	c7 44 24 08 1b 2e 81 	movl   $0x812e1b,0x8(%esp)
  8054d6:	00 
  8054d7:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  8054de:	00 
  8054df:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  8054e6:	e8 91 b4 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8054eb:	85 c9                	test   %ecx,%ecx
  8054ed:	75 1c                	jne    80550b <netbuf_data+0x71>
  8054ef:	c7 44 24 08 38 2e 81 	movl   $0x812e38,0x8(%esp)
  8054f6:	00 
  8054f7:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  8054fe:	00 
  8054ff:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  805506:	e8 71 b4 ff ff       	call   80097c <_panic>

  if (buf->ptr == NULL) {
  80550b:	8b 72 04             	mov    0x4(%edx),%esi
  80550e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  805513:	85 f6                	test   %esi,%esi
  805515:	74 14                	je     80552b <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  805517:	8b 46 04             	mov    0x4(%esi),%eax
  80551a:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  80551c:	8b 42 04             	mov    0x4(%edx),%eax
  80551f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  805523:	66 89 01             	mov    %ax,(%ecx)
  805526:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80552b:	83 c4 10             	add    $0x10,%esp
  80552e:	5b                   	pop    %ebx
  80552f:	5e                   	pop    %esi
  805530:	5d                   	pop    %ebp
  805531:	c3                   	ret    

00805532 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  805532:	55                   	push   %ebp
  805533:	89 e5                	mov    %esp,%ebp
  805535:	83 ec 18             	sub    $0x18,%esp
  805538:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80553b:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80553e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805541:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  805544:	85 db                	test   %ebx,%ebx
  805546:	75 1c                	jne    805564 <netbuf_chain+0x32>
  805548:	c7 44 24 08 51 2e 81 	movl   $0x812e51,0x8(%esp)
  80554f:	00 
  805550:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  805557:	00 
  805558:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  80555f:	e8 18 b4 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  805564:	85 f6                	test   %esi,%esi
  805566:	75 1c                	jne    805584 <netbuf_chain+0x52>
  805568:	c7 44 24 08 6a 2e 81 	movl   $0x812e6a,0x8(%esp)
  80556f:	00 
  805570:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  805577:	00 
  805578:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  80557f:	e8 f8 b3 ff ff       	call   80097c <_panic>
  pbuf_chain(head->p, tail->p);
  805584:	8b 06                	mov    (%esi),%eax
  805586:	89 44 24 04          	mov    %eax,0x4(%esp)
  80558a:	8b 03                	mov    (%ebx),%eax
  80558c:	89 04 24             	mov    %eax,(%esp)
  80558f:	e8 a8 25 00 00       	call   807b3c <pbuf_chain>
  head->ptr = head->p;
  805594:	8b 03                	mov    (%ebx),%eax
  805596:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  805599:	89 74 24 04          	mov    %esi,0x4(%esp)
  80559d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8055a4:	e8 97 21 00 00       	call   807740 <memp_free>
}
  8055a9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8055ac:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8055af:	89 ec                	mov    %ebp,%esp
  8055b1:	5d                   	pop    %ebp
  8055b2:	c3                   	ret    

008055b3 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8055b3:	55                   	push   %ebp
  8055b4:	89 e5                	mov    %esp,%ebp
  8055b6:	53                   	push   %ebx
  8055b7:	83 ec 14             	sub    $0x14,%esp
  8055ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8055bd:	85 db                	test   %ebx,%ebx
  8055bf:	75 1c                	jne    8055dd <netbuf_free+0x2a>
  8055c1:	c7 44 24 08 d3 2d 81 	movl   $0x812dd3,0x8(%esp)
  8055c8:	00 
  8055c9:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8055d0:	00 
  8055d1:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  8055d8:	e8 9f b3 ff ff       	call   80097c <_panic>
  if (buf->p != NULL) {
  8055dd:	8b 03                	mov    (%ebx),%eax
  8055df:	85 c0                	test   %eax,%eax
  8055e1:	74 08                	je     8055eb <netbuf_free+0x38>
    pbuf_free(buf->p);
  8055e3:	89 04 24             	mov    %eax,(%esp)
  8055e6:	e8 ed 28 00 00       	call   807ed8 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  8055eb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8055f2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8055f8:	83 c4 14             	add    $0x14,%esp
  8055fb:	5b                   	pop    %ebx
  8055fc:	5d                   	pop    %ebp
  8055fd:	c3                   	ret    

008055fe <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8055fe:	55                   	push   %ebp
  8055ff:	89 e5                	mov    %esp,%ebp
  805601:	53                   	push   %ebx
  805602:	83 ec 14             	sub    $0x14,%esp
  805605:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  805608:	85 db                	test   %ebx,%ebx
  80560a:	74 2b                	je     805637 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  80560c:	8b 03                	mov    (%ebx),%eax
  80560e:	85 c0                	test   %eax,%eax
  805610:	74 15                	je     805627 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  805612:	89 04 24             	mov    %eax,(%esp)
  805615:	e8 be 28 00 00       	call   807ed8 <pbuf_free>
      buf->p = buf->ptr = NULL;
  80561a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805621:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  805627:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80562b:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805632:	e8 09 21 00 00       	call   807740 <memp_free>
  }
}
  805637:	83 c4 14             	add    $0x14,%esp
  80563a:	5b                   	pop    %ebx
  80563b:	5d                   	pop    %ebp
  80563c:	c3                   	ret    

0080563d <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  80563d:	55                   	push   %ebp
  80563e:	89 e5                	mov    %esp,%ebp
  805640:	56                   	push   %esi
  805641:	53                   	push   %ebx
  805642:	83 ec 10             	sub    $0x10,%esp
  805645:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805648:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80564c:	85 db                	test   %ebx,%ebx
  80564e:	75 1c                	jne    80566c <netbuf_ref+0x2f>
  805650:	c7 44 24 08 85 2e 81 	movl   $0x812e85,0x8(%esp)
  805657:	00 
  805658:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80565f:	00 
  805660:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  805667:	e8 10 b3 ff ff       	call   80097c <_panic>
  if (buf->p != NULL) {
  80566c:	8b 03                	mov    (%ebx),%eax
  80566e:	85 c0                	test   %eax,%eax
  805670:	74 08                	je     80567a <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  805672:	89 04 24             	mov    %eax,(%esp)
  805675:	e8 5e 28 00 00       	call   807ed8 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80567a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805681:	00 
  805682:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805689:	00 
  80568a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805691:	e8 fd 2a 00 00       	call   808193 <pbuf_alloc>
  805696:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805698:	85 c0                	test   %eax,%eax
  80569a:	75 0e                	jne    8056aa <netbuf_ref+0x6d>
    buf->ptr = NULL;
  80569c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8056a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  8056a8:	eb 1a                	jmp    8056c4 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  8056aa:	8b 55 0c             	mov    0xc(%ebp),%edx
  8056ad:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  8056b0:	8b 03                	mov    (%ebx),%eax
  8056b2:	66 89 70 08          	mov    %si,0x8(%eax)
  8056b6:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8056ba:	8b 03                	mov    (%ebx),%eax
  8056bc:	89 43 04             	mov    %eax,0x4(%ebx)
  8056bf:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  8056c4:	83 c4 10             	add    $0x10,%esp
  8056c7:	5b                   	pop    %ebx
  8056c8:	5e                   	pop    %esi
  8056c9:	5d                   	pop    %ebp
  8056ca:	c3                   	ret    

008056cb <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  8056cb:	55                   	push   %ebp
  8056cc:	89 e5                	mov    %esp,%ebp
  8056ce:	56                   	push   %esi
  8056cf:	53                   	push   %ebx
  8056d0:	83 ec 10             	sub    $0x10,%esp
  8056d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8056d6:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8056da:	85 db                	test   %ebx,%ebx
  8056dc:	75 1c                	jne    8056fa <netbuf_alloc+0x2f>
  8056de:	c7 44 24 08 9d 2e 81 	movl   $0x812e9d,0x8(%esp)
  8056e5:	00 
  8056e6:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  8056ed:	00 
  8056ee:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  8056f5:	e8 82 b2 ff ff       	call   80097c <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8056fa:	8b 03                	mov    (%ebx),%eax
  8056fc:	85 c0                	test   %eax,%eax
  8056fe:	74 08                	je     805708 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  805700:	89 04 24             	mov    %eax,(%esp)
  805703:	e8 d0 27 00 00       	call   807ed8 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  805708:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80570f:	00 
  805710:	0f b7 c6             	movzwl %si,%eax
  805713:	89 44 24 04          	mov    %eax,0x4(%esp)
  805717:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80571e:	e8 70 2a 00 00       	call   808193 <pbuf_alloc>
  805723:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805725:	ba 00 00 00 00       	mov    $0x0,%edx
  80572a:	85 c0                	test   %eax,%eax
  80572c:	74 28                	je     805756 <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  80572e:	66 3b 70 0a          	cmp    0xa(%eax),%si
  805732:	76 1c                	jbe    805750 <netbuf_alloc+0x85>
  805734:	c7 44 24 08 b8 2e 81 	movl   $0x812eb8,0x8(%esp)
  80573b:	00 
  80573c:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  805743:	00 
  805744:	c7 04 24 ec 2d 81 00 	movl   $0x812dec,(%esp)
  80574b:	e8 2c b2 ff ff       	call   80097c <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  805750:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  805753:	8b 50 04             	mov    0x4(%eax),%edx
}
  805756:	89 d0                	mov    %edx,%eax
  805758:	83 c4 10             	add    $0x10,%esp
  80575b:	5b                   	pop    %ebx
  80575c:	5e                   	pop    %esi
  80575d:	5d                   	pop    %ebp
  80575e:	c3                   	ret    

0080575f <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80575f:	55                   	push   %ebp
  805760:	89 e5                	mov    %esp,%ebp
  805762:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  805765:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80576c:	e8 13 20 00 00       	call   807784 <memp_malloc>
  if (buf != NULL) {
  805771:	85 c0                	test   %eax,%eax
  805773:	74 14                	je     805789 <netbuf_new+0x2a>
    buf->p = NULL;
  805775:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80577b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  805782:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  805789:	c9                   	leave  
  80578a:	c3                   	ret    
  80578b:	00 00                	add    %al,(%eax)
  80578d:	00 00                	add    %al,(%eax)
	...

00805790 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805790:	55                   	push   %ebp
  805791:	89 e5                	mov    %esp,%ebp
  805793:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805796:	e8 35 7d 00 00       	call   80d4d0 <sys_init>
  mem_init();
  80579b:	e8 be 1e 00 00       	call   80765e <mem_init>
  memp_init();
  8057a0:	e8 17 1f 00 00       	call   8076bc <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8057a5:	e8 57 e9 ff ff       	call   804101 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8057aa:	c9                   	leave  
  8057ab:	c3                   	ret    
  8057ac:	00 00                	add    %al,(%eax)
	...

008057b0 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  8057b0:	55                   	push   %ebp
  8057b1:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  8057b3:	38 10                	cmp    %dl,(%eax)
  8057b5:	74 06                	je     8057bd <dhcp_set_state+0xd>
    dhcp->state = new_state;
  8057b7:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8057b9:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8057bd:	5d                   	pop    %ebp
  8057be:	c3                   	ret    

008057bf <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8057bf:	55                   	push   %ebp
  8057c0:	89 e5                	mov    %esp,%ebp
  8057c2:	57                   	push   %edi
  8057c3:	56                   	push   %esi
  8057c4:	53                   	push   %ebx
  8057c5:	83 ec 08             	sub    $0x8,%esp
  8057c8:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8057cb:	8b 70 14             	mov    0x14(%eax),%esi
  8057ce:	85 f6                	test   %esi,%esi
  8057d0:	0f 84 e6 00 00 00    	je     8058bc <dhcp_get_option_ptr+0xfd>
  8057d6:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  8057da:	66 85 ff             	test   %di,%di
  8057dd:	0f 84 d9 00 00 00    	je     8058bc <dhcp_get_option_ptr+0xfd>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8057e3:	0f b6 0e             	movzbl (%esi),%ecx
  8057e6:	80 f9 ff             	cmp    $0xff,%cl
  8057e9:	0f 84 cd 00 00 00    	je     8058bc <dhcp_get_option_ptr+0xfd>
  8057ef:	89 f3                	mov    %esi,%ebx
  8057f1:	ba 00 00 00 00       	mov    $0x0,%edx
  8057f6:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8057fa:	80 f9 34             	cmp    $0x34,%cl
  8057fd:	75 12                	jne    805811 <dhcp_get_option_ptr+0x52>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  8057ff:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  805802:	0f b7 c9             	movzwl %cx,%ecx
  805805:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  805809:	88 4d f2             	mov    %cl,-0xe(%ebp)
  80580c:	83 c2 03             	add    $0x3,%edx
  80580f:	eb 17                	jmp    805828 <dhcp_get_option_ptr+0x69>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  805811:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  805814:	0f 84 a7 00 00 00    	je     8058c1 <dhcp_get_option_ptr+0x102>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80581a:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80581d:	0f b7 c9             	movzwl %cx,%ecx
  805820:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  805824:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  805828:	66 39 d7             	cmp    %dx,%di
  80582b:	76 0e                	jbe    80583b <dhcp_get_option_ptr+0x7c>
  80582d:	0f b7 da             	movzwl %dx,%ebx
  805830:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  805833:	0f b6 0b             	movzbl (%ebx),%ecx
  805836:	80 f9 ff             	cmp    $0xff,%cl
  805839:	75 bf                	jne    8057fa <dhcp_get_option_ptr+0x3b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80583b:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  80583f:	74 7b                	je     8058bc <dhcp_get_option_ptr+0xfd>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  805841:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  805845:	75 0d                	jne    805854 <dhcp_get_option_ptr+0x95>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  805847:	8b 58 10             	mov    0x10(%eax),%ebx
  80584a:	83 c3 6c             	add    $0x6c,%ebx
  80584d:	b9 80 00 00 00       	mov    $0x80,%ecx
  805852:	eb 1e                	jmp    805872 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  805854:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  805858:	75 0d                	jne    805867 <dhcp_get_option_ptr+0xa8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80585a:	8b 58 10             	mov    0x10(%eax),%ebx
  80585d:	83 c3 2c             	add    $0x2c,%ebx
  805860:	b9 40 00 00 00       	mov    $0x40,%ecx
  805865:	eb 0b                	jmp    805872 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  805867:	8b 58 10             	mov    0x10(%eax),%ebx
  80586a:	83 c3 2c             	add    $0x2c,%ebx
  80586d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805872:	0f b6 13             	movzbl (%ebx),%edx
  805875:	80 fa ff             	cmp    $0xff,%dl
  805878:	74 42                	je     8058bc <dhcp_get_option_ptr+0xfd>
        if (options[offset] == option_type) {
  80587a:	b8 00 00 00 00       	mov    $0x0,%eax
  80587f:	38 55 f3             	cmp    %dl,-0xd(%ebp)
  805882:	75 0e                	jne    805892 <dhcp_get_option_ptr+0xd3>
  805884:	eb 3b                	jmp    8058c1 <dhcp_get_option_ptr+0x102>
  805886:	89 f9                	mov    %edi,%ecx
  805888:	38 d1                	cmp    %dl,%cl
  80588a:	75 0e                	jne    80589a <dhcp_get_option_ptr+0xdb>
  80588c:	89 f3                	mov    %esi,%ebx
  80588e:	66 90                	xchg   %ax,%ax
  805890:	eb 2f                	jmp    8058c1 <dhcp_get_option_ptr+0x102>
  805892:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  805896:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80589a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  80589d:	0f b7 d2             	movzwl %dx,%edx
  8058a0:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  8058a4:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8058a8:	66 39 45 ee          	cmp    %ax,-0x12(%ebp)
  8058ac:	76 0e                	jbe    8058bc <dhcp_get_option_ptr+0xfd>
  8058ae:	0f b7 f0             	movzwl %ax,%esi
  8058b1:	8d 34 33             	lea    (%ebx,%esi,1),%esi
  8058b4:	0f b6 16             	movzbl (%esi),%edx
  8058b7:	80 fa ff             	cmp    $0xff,%dl
  8058ba:	75 ca                	jne    805886 <dhcp_get_option_ptr+0xc7>
  8058bc:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  8058c1:	89 d8                	mov    %ebx,%eax
  8058c3:	83 c4 08             	add    $0x8,%esp
  8058c6:	5b                   	pop    %ebx
  8058c7:	5e                   	pop    %esi
  8058c8:	5f                   	pop    %edi
  8058c9:	5d                   	pop    %ebp
  8058ca:	c3                   	ret    

008058cb <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  8058cb:	55                   	push   %ebp
  8058cc:	89 e5                	mov    %esp,%ebp
  8058ce:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  8058d1:	5d                   	pop    %ebp
  8058d2:	c3                   	ret    

008058d3 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  8058d3:	55                   	push   %ebp
  8058d4:	89 e5                	mov    %esp,%ebp
  8058d6:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  8058d7:	0f b6 10             	movzbl (%eax),%edx
  8058da:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  8058dd:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  8058e1:	c1 e3 10             	shl    $0x10,%ebx
  8058e4:	09 d3                	or     %edx,%ebx
  8058e6:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  8058e9:	0f b6 0a             	movzbl (%edx),%ecx
  8058ec:	c1 e1 08             	shl    $0x8,%ecx
  8058ef:	89 d8                	mov    %ebx,%eax
  8058f1:	09 c8                	or     %ecx,%eax
  8058f3:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  8058f7:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  8058f9:	5b                   	pop    %ebx
  8058fa:	5d                   	pop    %ebp
  8058fb:	c3                   	ret    

008058fc <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  8058fc:	55                   	push   %ebp
  8058fd:	89 e5                	mov    %esp,%ebp
  8058ff:	83 ec 28             	sub    $0x28,%esp
  805902:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805905:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805908:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80590b:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  80590f:	0f b7 fb             	movzwl %bx,%edi
  805912:	0f b6 f1             	movzbl %cl,%esi
  805915:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  805919:	83 fe 44             	cmp    $0x44,%esi
  80591c:	76 1c                	jbe    80593a <dhcp_option+0x3e>
  80591e:	c7 44 24 08 dc 2e 81 	movl   $0x812edc,0x8(%esp)
  805925:	00 
  805926:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  80592d:	00 
  80592e:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805935:	e8 42 b0 ff ff       	call   80097c <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80593a:	8b 78 20             	mov    0x20(%eax),%edi
  80593d:	0f b7 f3             	movzwl %bx,%esi
  805940:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  805947:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80594a:	8b 70 20             	mov    0x20(%eax),%esi
  80594d:	0f b7 d2             	movzwl %dx,%edx
  805950:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  805957:	83 c3 02             	add    $0x2,%ebx
  80595a:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  80595e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805961:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805964:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805967:	89 ec                	mov    %ebp,%esp
  805969:	5d                   	pop    %ebp
  80596a:	c3                   	ret    

0080596b <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80596b:	55                   	push   %ebp
  80596c:	89 e5                	mov    %esp,%ebp
  80596e:	83 ec 18             	sub    $0x18,%esp
  805971:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805974:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805977:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80597b:	66 83 f9 43          	cmp    $0x43,%cx
  80597f:	76 1c                	jbe    80599d <dhcp_option_byte+0x32>
  805981:	c7 44 24 08 24 2f 81 	movl   $0x812f24,0x8(%esp)
  805988:	00 
  805989:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  805990:	00 
  805991:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805998:	e8 df af ff ff       	call   80097c <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80599d:	8b 70 20             	mov    0x20(%eax),%esi
  8059a0:	0f b7 d9             	movzwl %cx,%ebx
  8059a3:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  8059aa:	83 c1 01             	add    $0x1,%ecx
  8059ad:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  8059b1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8059b4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8059b7:	89 ec                	mov    %ebp,%esp
  8059b9:	5d                   	pop    %ebp
  8059ba:	c3                   	ret    

008059bb <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  8059bb:	55                   	push   %ebp
  8059bc:	89 e5                	mov    %esp,%ebp
  8059be:	53                   	push   %ebx
  8059bf:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8059c2:	85 c0                	test   %eax,%eax
  8059c4:	75 1c                	jne    8059e2 <dhcp_option_trailer+0x27>
  8059c6:	c7 44 24 08 60 2f 81 	movl   $0x812f60,0x8(%esp)
  8059cd:	00 
  8059ce:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  8059d5:	00 
  8059d6:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  8059dd:	e8 9a af ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  8059e2:	8b 48 20             	mov    0x20(%eax),%ecx
  8059e5:	85 c9                	test   %ecx,%ecx
  8059e7:	75 1c                	jne    805a05 <dhcp_option_trailer+0x4a>
  8059e9:	c7 44 24 08 84 2f 81 	movl   $0x812f84,0x8(%esp)
  8059f0:	00 
  8059f1:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  8059f8:	00 
  8059f9:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805a00:	e8 77 af ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805a05:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805a09:	66 83 fa 43          	cmp    $0x43,%dx
  805a0d:	76 1c                	jbe    805a2b <dhcp_option_trailer+0x70>
  805a0f:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  805a16:	00 
  805a17:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  805a1e:	00 
  805a1f:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805a26:	e8 51 af ff ff       	call   80097c <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  805a2b:	0f b7 da             	movzwl %dx,%ebx
  805a2e:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  805a35:	ff 
  805a36:	83 c2 01             	add    $0x1,%edx
  805a39:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805a3d:	eb 31                	jmp    805a70 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805a3f:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  805a46:	00 
  805a47:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  805a4e:	00 
  805a4f:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805a56:	e8 21 af ff ff       	call   80097c <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  805a5b:	8b 58 20             	mov    0x20(%eax),%ebx
  805a5e:	0f b7 ca             	movzwl %dx,%ecx
  805a61:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  805a68:	00 
  805a69:	83 c2 01             	add    $0x1,%edx
  805a6c:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805a70:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805a74:	66 83 fa 43          	cmp    $0x43,%dx
  805a78:	76 e1                	jbe    805a5b <dhcp_option_trailer+0xa0>
  805a7a:	f6 c2 03             	test   $0x3,%dl
  805a7d:	75 c0                	jne    805a3f <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  805a7f:	83 c4 14             	add    $0x14,%esp
  805a82:	5b                   	pop    %ebx
  805a83:	5d                   	pop    %ebp
  805a84:	c3                   	ret    

00805a85 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805a85:	55                   	push   %ebp
  805a86:	89 e5                	mov    %esp,%ebp
  805a88:	83 ec 48             	sub    $0x48,%esp
  805a8b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805a8e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805a91:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  805a94:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805a98:	0f b7 d9             	movzwl %cx,%ebx
  805a9b:	83 c3 02             	add    $0x2,%ebx
  805a9e:	83 fb 44             	cmp    $0x44,%ebx
  805aa1:	76 1c                	jbe    805abf <dhcp_option_short+0x3a>
  805aa3:	c7 44 24 08 f0 2f 81 	movl   $0x812ff0,0x8(%esp)
  805aaa:	00 
  805aab:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805ab2:	00 
  805ab3:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805aba:	e8 bd ae ff ff       	call   80097c <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  805abf:	0f b7 d9             	movzwl %cx,%ebx
  805ac2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805ac5:	89 d6                	mov    %edx,%esi
  805ac7:	66 c1 ee 08          	shr    $0x8,%si
  805acb:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  805acf:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  805ad3:	8b 78 20             	mov    0x20(%eax),%edi
  805ad6:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805ad9:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805ae0:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805ae3:	8b 70 20             	mov    0x20(%eax),%esi
  805ae6:	0f b7 db             	movzwl %bx,%ebx
  805ae9:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805af0:	83 c1 02             	add    $0x2,%ecx
  805af3:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805af7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805afa:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805afd:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805b00:	89 ec                	mov    %ebp,%esp
  805b02:	5d                   	pop    %ebp
  805b03:	c3                   	ret    

00805b04 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  805b04:	55                   	push   %ebp
  805b05:	89 e5                	mov    %esp,%ebp
  805b07:	83 ec 48             	sub    $0x48,%esp
  805b0a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805b0d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805b10:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  805b13:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805b17:	0f b7 d9             	movzwl %cx,%ebx
  805b1a:	83 c3 04             	add    $0x4,%ebx
  805b1d:	83 fb 44             	cmp    $0x44,%ebx
  805b20:	76 1c                	jbe    805b3e <dhcp_option_long+0x3a>
  805b22:	c7 44 24 08 34 30 81 	movl   $0x813034,0x8(%esp)
  805b29:	00 
  805b2a:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  805b31:	00 
  805b32:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805b39:	e8 3e ae ff ff       	call   80097c <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  805b3e:	0f b7 d9             	movzwl %cx,%ebx
  805b41:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b44:	89 d6                	mov    %edx,%esi
  805b46:	c1 ee 18             	shr    $0x18,%esi
  805b49:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  805b4c:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  805b50:	8b 78 20             	mov    0x20(%eax),%edi
  805b53:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b56:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b5d:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  805b60:	0f b7 db             	movzwl %bx,%ebx
  805b63:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b66:	89 d3                	mov    %edx,%ebx
  805b68:	c1 eb 10             	shr    $0x10,%ebx
  805b6b:	8b 78 20             	mov    0x20(%eax),%edi
  805b6e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b71:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b78:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  805b7b:	0f b7 db             	movzwl %bx,%ebx
  805b7e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b81:	0f b6 de             	movzbl %dh,%ebx
  805b84:	8b 78 20             	mov    0x20(%eax),%edi
  805b87:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b8a:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b91:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805b94:	8b 70 20             	mov    0x20(%eax),%esi
  805b97:	0f b7 db             	movzwl %bx,%ebx
  805b9a:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805ba1:	83 c1 04             	add    $0x4,%ecx
  805ba4:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805ba8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805bab:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805bae:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805bb1:	89 ec                	mov    %ebp,%esp
  805bb3:	5d                   	pop    %ebp
  805bb4:	c3                   	ret    

00805bb5 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  805bb5:	55                   	push   %ebp
  805bb6:	89 e5                	mov    %esp,%ebp
  805bb8:	53                   	push   %ebx
  805bb9:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  805bbc:	85 c0                	test   %eax,%eax
  805bbe:	75 1c                	jne    805bdc <dhcp_delete_request+0x27>
  805bc0:	c7 44 24 08 74 30 81 	movl   $0x813074,0x8(%esp)
  805bc7:	00 
  805bc8:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  805bcf:	00 
  805bd0:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805bd7:	e8 a0 ad ff ff       	call   80097c <_panic>
  dhcp = netif->dhcp;
  805bdc:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  805bdf:	85 db                	test   %ebx,%ebx
  805be1:	75 1c                	jne    805bff <dhcp_delete_request+0x4a>
  805be3:	c7 44 24 08 98 30 81 	movl   $0x813098,0x8(%esp)
  805bea:	00 
  805beb:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  805bf2:	00 
  805bf3:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805bfa:	e8 7d ad ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  805bff:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805c02:	85 c0                	test   %eax,%eax
  805c04:	75 1c                	jne    805c22 <dhcp_delete_request+0x6d>
  805c06:	c7 44 24 08 bc 30 81 	movl   $0x8130bc,0x8(%esp)
  805c0d:	00 
  805c0e:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  805c15:	00 
  805c16:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805c1d:	e8 5a ad ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  805c22:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805c26:	75 1c                	jne    805c44 <dhcp_delete_request+0x8f>
  805c28:	c7 44 24 08 e8 30 81 	movl   $0x8130e8,0x8(%esp)
  805c2f:	00 
  805c30:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  805c37:	00 
  805c38:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805c3f:	e8 38 ad ff ff       	call   80097c <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  805c44:	89 04 24             	mov    %eax,(%esp)
  805c47:	e8 8c 22 00 00       	call   807ed8 <pbuf_free>
  }
  dhcp->p_out = NULL;
  805c4c:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  805c53:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  805c5a:	83 c4 14             	add    $0x14,%esp
  805c5d:	5b                   	pop    %ebx
  805c5e:	5d                   	pop    %ebp
  805c5f:	c3                   	ret    

00805c60 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805c60:	55                   	push   %ebp
  805c61:	89 e5                	mov    %esp,%ebp
  805c63:	53                   	push   %ebx
  805c64:	83 ec 14             	sub    $0x14,%esp
  805c67:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  805c69:	8b 40 10             	mov    0x10(%eax),%eax
  805c6c:	85 c0                	test   %eax,%eax
  805c6e:	74 0f                	je     805c7f <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805c70:	89 04 24             	mov    %eax,(%esp)
  805c73:	e8 56 18 00 00       	call   8074ce <mem_free>
    dhcp->msg_in = NULL;
  805c78:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  805c7f:	8b 43 14             	mov    0x14(%ebx),%eax
  805c82:	85 c0                	test   %eax,%eax
  805c84:	74 15                	je     805c9b <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  805c86:	89 04 24             	mov    %eax,(%esp)
  805c89:	e8 40 18 00 00       	call   8074ce <mem_free>
    dhcp->options_in = NULL;
  805c8e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  805c95:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  805c9b:	83 c4 14             	add    $0x14,%esp
  805c9e:	5b                   	pop    %ebx
  805c9f:	5d                   	pop    %ebp
  805ca0:	c3                   	ret    

00805ca1 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805ca1:	55                   	push   %ebp
  805ca2:	89 e5                	mov    %esp,%ebp
  805ca4:	56                   	push   %esi
  805ca5:	53                   	push   %ebx
  805ca6:	83 ec 10             	sub    $0x10,%esp
  805ca9:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805cac:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  805caf:	85 f6                	test   %esi,%esi
  805cb1:	75 1c                	jne    805ccf <dhcp_stop+0x2e>
  805cb3:	c7 44 24 08 3f 32 81 	movl   $0x81323f,0x8(%esp)
  805cba:	00 
  805cbb:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805cc2:	00 
  805cc3:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805cca:	e8 ad ac ff ff       	call   80097c <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  805ccf:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  805cd3:	85 db                	test   %ebx,%ebx
  805cd5:	74 42                	je     805d19 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  805cd7:	8b 43 08             	mov    0x8(%ebx),%eax
  805cda:	85 c0                	test   %eax,%eax
  805cdc:	74 0f                	je     805ced <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  805cde:	89 04 24             	mov    %eax,(%esp)
  805ce1:	e8 e6 63 00 00       	call   80c0cc <udp_remove>
      dhcp->pcb = NULL;
  805ce6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  805ced:	8b 43 0c             	mov    0xc(%ebx),%eax
  805cf0:	85 c0                	test   %eax,%eax
  805cf2:	74 0f                	je     805d03 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  805cf4:	89 04 24             	mov    %eax,(%esp)
  805cf7:	e8 dc 21 00 00       	call   807ed8 <pbuf_free>
      dhcp->p = NULL;
  805cfc:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  805d03:	89 d8                	mov    %ebx,%eax
  805d05:	e8 56 ff ff ff       	call   805c60 <dhcp_free_reply>
    mem_free((void *)dhcp);
  805d0a:	89 1c 24             	mov    %ebx,(%esp)
  805d0d:	e8 bc 17 00 00       	call   8074ce <mem_free>
    netif->dhcp = NULL;
  805d12:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  805d19:	83 c4 10             	add    $0x10,%esp
  805d1c:	5b                   	pop    %ebx
  805d1d:	5e                   	pop    %esi
  805d1e:	5d                   	pop    %ebp
  805d1f:	c3                   	ret    

00805d20 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  805d20:	55                   	push   %ebp
  805d21:	89 e5                	mov    %esp,%ebp
  805d23:	57                   	push   %edi
  805d24:	56                   	push   %esi
  805d25:	53                   	push   %ebx
  805d26:	83 ec 2c             	sub    $0x2c,%esp
  805d29:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  805d2b:	85 c0                	test   %eax,%eax
  805d2d:	75 1c                	jne    805d4b <dhcp_create_request+0x2b>
  805d2f:	c7 44 24 08 14 31 81 	movl   $0x813114,0x8(%esp)
  805d36:	00 
  805d37:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  805d3e:	00 
  805d3f:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805d46:	e8 31 ac ff ff       	call   80097c <_panic>
  dhcp = netif->dhcp;
  805d4b:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  805d4e:	85 db                	test   %ebx,%ebx
  805d50:	75 1c                	jne    805d6e <dhcp_create_request+0x4e>
  805d52:	c7 44 24 08 38 31 81 	movl   $0x813138,0x8(%esp)
  805d59:	00 
  805d5a:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  805d61:	00 
  805d62:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805d69:	e8 0e ac ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  805d6e:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  805d72:	74 1c                	je     805d90 <dhcp_create_request+0x70>
  805d74:	c7 44 24 08 5c 31 81 	movl   $0x81315c,0x8(%esp)
  805d7b:	00 
  805d7c:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  805d83:	00 
  805d84:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805d8b:	e8 ec ab ff ff       	call   80097c <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  805d90:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805d94:	74 1c                	je     805db2 <dhcp_create_request+0x92>
  805d96:	c7 44 24 08 88 31 81 	movl   $0x813188,0x8(%esp)
  805d9d:	00 
  805d9e:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  805da5:	00 
  805da6:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805dad:	e8 ca ab ff ff       	call   80097c <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  805db2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805db9:	00 
  805dba:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  805dc1:	00 
  805dc2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805dc9:	e8 c5 23 00 00       	call   808193 <pbuf_alloc>
  805dce:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  805dd1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  805dd6:	85 c0                	test   %eax,%eax
  805dd8:	0f 84 2d 01 00 00    	je     805f0b <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  805dde:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  805de4:	77 1c                	ja     805e02 <dhcp_create_request+0xe2>
  805de6:	c7 44 24 08 b4 31 81 	movl   $0x8131b4,0x8(%esp)
  805ded:	00 
  805dee:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  805df5:	00 
  805df6:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  805dfd:	e8 7a ab ff ff       	call   80097c <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  805e02:	8b 15 78 80 81 00    	mov    0x818078,%edx
  805e08:	89 53 04             	mov    %edx,0x4(%ebx)
  805e0b:	83 c2 01             	add    $0x1,%edx
  805e0e:	89 15 78 80 81 00    	mov    %edx,0x818078
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  805e14:	8b 40 04             	mov    0x4(%eax),%eax
  805e17:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  805e1a:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  805e1d:	8b 43 20             	mov    0x20(%ebx),%eax
  805e20:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  805e24:	8b 43 20             	mov    0x20(%ebx),%eax
  805e27:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  805e2b:	8b 43 20             	mov    0x20(%ebx),%eax
  805e2e:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  805e32:	8b 73 20             	mov    0x20(%ebx),%esi
  805e35:	8b 43 04             	mov    0x4(%ebx),%eax
  805e38:	89 04 24             	mov    %eax,(%esp)
  805e3b:	e8 b5 4e 00 00       	call   80acf5 <htonl>
  805e40:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  805e43:	8b 43 20             	mov    0x20(%ebx),%eax
  805e46:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  805e4c:	8b 43 20             	mov    0x20(%ebx),%eax
  805e4f:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  805e55:	8b 43 20             	mov    0x20(%ebx),%eax
  805e58:	8b 57 04             	mov    0x4(%edi),%edx
  805e5b:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  805e5e:	8b 43 20             	mov    0x20(%ebx),%eax
  805e61:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805e68:	8b 43 20             	mov    0x20(%ebx),%eax
  805e6b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805e72:	8b 43 20             	mov    0x20(%ebx),%eax
  805e75:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  805e7c:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805e81:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805e84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  805e87:	8b 5a 20             	mov    0x20(%edx),%ebx
  805e8a:	89 c1                	mov    %eax,%ecx
  805e8c:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  805e90:	ba 00 00 00 00       	mov    $0x0,%edx
  805e95:	66 39 c6             	cmp    %ax,%si
  805e98:	76 05                	jbe    805e9f <dhcp_create_request+0x17f>
  805e9a:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  805e9f:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  805ea3:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805ea6:	83 f8 10             	cmp    $0x10,%eax
  805ea9:	75 d9                	jne    805e84 <dhcp_create_request+0x164>
  805eab:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  805eae:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805eb0:	8b 53 20             	mov    0x20(%ebx),%edx
  805eb3:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  805eb8:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  805ebb:	83 f8 40             	cmp    $0x40,%eax
  805ebe:	75 f0                	jne    805eb0 <dhcp_create_request+0x190>
  805ec0:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805ec2:	8b 53 20             	mov    0x20(%ebx),%edx
  805ec5:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  805eca:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  805ecd:	3d 80 00 00 00       	cmp    $0x80,%eax
  805ed2:	75 ee                	jne    805ec2 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805ed4:	8b 73 20             	mov    0x20(%ebx),%esi
  805ed7:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  805ede:	e8 12 4e 00 00       	call   80acf5 <htonl>
  805ee3:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  805ee9:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  805eef:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  805ef4:	8b 53 20             	mov    0x20(%ebx),%edx
  805ef7:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  805efe:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  805f01:	83 f8 44             	cmp    $0x44,%eax
  805f04:	75 ee                	jne    805ef4 <dhcp_create_request+0x1d4>
  805f06:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  805f0b:	89 d0                	mov    %edx,%eax
  805f0d:	83 c4 2c             	add    $0x2c,%esp
  805f10:	5b                   	pop    %ebx
  805f11:	5e                   	pop    %esi
  805f12:	5f                   	pop    %edi
  805f13:	5d                   	pop    %ebp
  805f14:	c3                   	ret    

00805f15 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  805f15:	55                   	push   %ebp
  805f16:	89 e5                	mov    %esp,%ebp
  805f18:	57                   	push   %edi
  805f19:	56                   	push   %esi
  805f1a:	53                   	push   %ebx
  805f1b:	83 ec 3c             	sub    $0x3c,%esp
  805f1e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805f21:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  805f24:	ba 0d 00 00 00       	mov    $0xd,%edx
  805f29:	89 d8                	mov    %ebx,%eax
  805f2b:	e8 80 f8 ff ff       	call   8057b0 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  805f30:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  805f37:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  805f3e:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  805f45:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  805f4c:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  805f53:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  805f5a:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  805f61:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  805f68:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805f6f:	89 f0                	mov    %esi,%eax
  805f71:	e8 aa fd ff ff       	call   805d20 <dhcp_create_request>
  805f76:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805f78:	84 c0                	test   %al,%al
  805f7a:	0f 85 87 00 00 00    	jne    806007 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805f80:	b9 01 00 00 00       	mov    $0x1,%ecx
  805f85:	ba 35 00 00 00       	mov    $0x35,%edx
  805f8a:	89 d8                	mov    %ebx,%eax
  805f8c:	e8 6b f9 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  805f91:	ba 07 00 00 00       	mov    $0x7,%edx
  805f96:	89 d8                	mov    %ebx,%eax
  805f98:	e8 ce f9 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805f9d:	89 d8                	mov    %ebx,%eax
  805f9f:	e8 17 fa ff ff       	call   8059bb <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805fa4:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805fa8:	66 05 f0 00          	add    $0xf0,%ax
  805fac:	0f b7 c0             	movzwl %ax,%eax
  805faf:	89 44 24 04          	mov    %eax,0x4(%esp)
  805fb3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805fb6:	89 04 24             	mov    %eax,(%esp)
  805fb9:	e8 a2 20 00 00       	call   808060 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805fbe:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805fc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805fc4:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805fcb:	00 
  805fcc:	89 44 24 04          	mov    %eax,0x4(%esp)
  805fd0:	8b 43 08             	mov    0x8(%ebx),%eax
  805fd3:	89 04 24             	mov    %eax,(%esp)
  805fd6:	e8 03 62 00 00       	call   80c1de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805fdb:	89 74 24 10          	mov    %esi,0x10(%esp)
  805fdf:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805fe6:	00 
  805fe7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805fea:	89 44 24 08          	mov    %eax,0x8(%esp)
  805fee:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805ff1:	89 44 24 04          	mov    %eax,0x4(%esp)
  805ff5:	8b 43 08             	mov    0x8(%ebx),%eax
  805ff8:	89 04 24             	mov    %eax,(%esp)
  805ffb:	e8 60 62 00 00       	call   80c260 <udp_sendto_if>
    dhcp_delete_request(netif);
  806000:	89 f0                	mov    %esi,%eax
  806002:	e8 ae fb ff ff       	call   805bb5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806007:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80600b:	83 c1 01             	add    $0x1,%ecx
  80600e:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  806011:	ba 10 27 00 00       	mov    $0x2710,%edx
  806016:	80 f9 09             	cmp    $0x9,%cl
  806019:	77 08                	ja     806023 <dhcp_release+0x10e>
  80601b:	0f b6 c9             	movzbl %cl,%ecx
  80601e:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806023:	0f b7 d2             	movzwl %dx,%edx
  806026:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80602c:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  806031:	89 d0                	mov    %edx,%eax
  806033:	f7 e9                	imul   %ecx
  806035:	c1 fa 05             	sar    $0x5,%edx
  806038:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80603c:	89 34 24             	mov    %esi,(%esp)
  80603f:	e8 84 18 00 00       	call   8078c8 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806044:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80604b:	00 
  80604c:	89 34 24             	mov    %esi,(%esp)
  80604f:	e8 d0 18 00 00       	call   807924 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806054:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80605b:	00 
  80605c:	89 34 24             	mov    %esi,(%esp)
  80605f:	e8 cb 17 00 00       	call   80782f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  806064:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80606b:	00 
  80606c:	89 34 24             	mov    %esi,(%esp)
  80606f:	e8 d4 17 00 00       	call   807848 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  806074:	89 f8                	mov    %edi,%eax
  806076:	83 c4 3c             	add    $0x3c,%esp
  806079:	5b                   	pop    %ebx
  80607a:	5e                   	pop    %esi
  80607b:	5f                   	pop    %edi
  80607c:	5d                   	pop    %ebp
  80607d:	c3                   	ret    

0080607e <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80607e:	55                   	push   %ebp
  80607f:	89 e5                	mov    %esp,%ebp
  806081:	83 ec 48             	sub    $0x48,%esp
  806084:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806087:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80608a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80608d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  806090:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  806093:	ba 05 00 00 00       	mov    $0x5,%edx
  806098:	89 d8                	mov    %ebx,%eax
  80609a:	e8 11 f7 ff ff       	call   8057b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80609f:	89 f8                	mov    %edi,%eax
  8060a1:	e8 7a fc ff ff       	call   805d20 <dhcp_create_request>
  8060a6:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8060a8:	84 c0                	test   %al,%al
  8060aa:	0f 85 a4 00 00 00    	jne    806154 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8060b0:	b9 01 00 00 00       	mov    $0x1,%ecx
  8060b5:	ba 35 00 00 00       	mov    $0x35,%edx
  8060ba:	89 d8                	mov    %ebx,%eax
  8060bc:	e8 3b f8 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8060c1:	ba 03 00 00 00       	mov    $0x3,%edx
  8060c6:	89 d8                	mov    %ebx,%eax
  8060c8:	e8 9e f8 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8060cd:	b9 02 00 00 00       	mov    $0x2,%ecx
  8060d2:	ba 39 00 00 00       	mov    $0x39,%edx
  8060d7:	89 d8                	mov    %ebx,%eax
  8060d9:	e8 1e f8 ff ff       	call   8058fc <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  8060de:	ba 40 02 00 00       	mov    $0x240,%edx
  8060e3:	89 d8                	mov    %ebx,%eax
  8060e5:	e8 9b f9 ff ff       	call   805a85 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  8060ea:	89 d8                	mov    %ebx,%eax
  8060ec:	e8 ca f8 ff ff       	call   8059bb <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8060f1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8060f5:	66 05 f0 00          	add    $0xf0,%ax
  8060f9:	0f b7 c0             	movzwl %ax,%eax
  8060fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  806100:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806103:	89 04 24             	mov    %eax,(%esp)
  806106:	e8 55 1f 00 00       	call   808060 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80610b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80610e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806111:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806118:	00 
  806119:	89 44 24 04          	mov    %eax,0x4(%esp)
  80611d:	8b 43 08             	mov    0x8(%ebx),%eax
  806120:	89 04 24             	mov    %eax,(%esp)
  806123:	e8 b6 60 00 00       	call   80c1de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  806128:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80612c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806133:	00 
  806134:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806137:	89 44 24 08          	mov    %eax,0x8(%esp)
  80613b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80613e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806142:	8b 43 08             	mov    0x8(%ebx),%eax
  806145:	89 04 24             	mov    %eax,(%esp)
  806148:	e8 13 61 00 00       	call   80c260 <udp_sendto_if>
    dhcp_delete_request(netif);
  80614d:	89 f8                	mov    %edi,%eax
  80614f:	e8 61 fa ff ff       	call   805bb5 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806154:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  806158:	83 c1 01             	add    $0x1,%ecx
  80615b:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80615e:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  806163:	80 f9 09             	cmp    $0x9,%cl
  806166:	77 08                	ja     806170 <dhcp_renew+0xf2>
  806168:	0f b6 c9             	movzbl %cl,%ecx
  80616b:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806170:	0f b7 d2             	movzwl %dx,%edx
  806173:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  806179:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80617e:	89 d0                	mov    %edx,%eax
  806180:	f7 e9                	imul   %ecx
  806182:	c1 fa 05             	sar    $0x5,%edx
  806185:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806189:	89 f0                	mov    %esi,%eax
  80618b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80618e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806191:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806194:	89 ec                	mov    %ebp,%esp
  806196:	5d                   	pop    %ebp
  806197:	c3                   	ret    

00806198 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  806198:	55                   	push   %ebp
  806199:	89 e5                	mov    %esp,%ebp
  80619b:	57                   	push   %edi
  80619c:	56                   	push   %esi
  80619d:	53                   	push   %ebx
  80619e:	83 ec 2c             	sub    $0x2c,%esp
  8061a1:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8061a3:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  8061a6:	a1 0c 3b 81 00       	mov    0x813b0c,%eax
  8061ab:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8061ae:	89 f8                	mov    %edi,%eax
  8061b0:	e8 6b fb ff ff       	call   805d20 <dhcp_create_request>
  8061b5:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8061b7:	84 c0                	test   %al,%al
  8061b9:	0f 85 f0 00 00 00    	jne    8062af <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8061bf:	b9 01 00 00 00       	mov    $0x1,%ecx
  8061c4:	ba 35 00 00 00       	mov    $0x35,%edx
  8061c9:	89 d8                	mov    %ebx,%eax
  8061cb:	e8 2c f7 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  8061d0:	ba 01 00 00 00       	mov    $0x1,%edx
  8061d5:	89 d8                	mov    %ebx,%eax
  8061d7:	e8 8f f7 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8061dc:	b9 02 00 00 00       	mov    $0x2,%ecx
  8061e1:	ba 39 00 00 00       	mov    $0x39,%edx
  8061e6:	89 d8                	mov    %ebx,%eax
  8061e8:	e8 0f f7 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8061ed:	ba 40 02 00 00       	mov    $0x240,%edx
  8061f2:	89 d8                	mov    %ebx,%eax
  8061f4:	e8 8c f8 ff ff       	call   805a85 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8061f9:	b9 04 00 00 00       	mov    $0x4,%ecx
  8061fe:	ba 37 00 00 00       	mov    $0x37,%edx
  806203:	89 d8                	mov    %ebx,%eax
  806205:	e8 f2 f6 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80620a:	ba 01 00 00 00       	mov    $0x1,%edx
  80620f:	89 d8                	mov    %ebx,%eax
  806211:	e8 55 f7 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  806216:	ba 03 00 00 00       	mov    $0x3,%edx
  80621b:	89 d8                	mov    %ebx,%eax
  80621d:	e8 49 f7 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806222:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806227:	89 d8                	mov    %ebx,%eax
  806229:	e8 3d f7 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80622e:	ba 06 00 00 00       	mov    $0x6,%edx
  806233:	89 d8                	mov    %ebx,%eax
  806235:	e8 31 f7 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  80623a:	89 d8                	mov    %ebx,%eax
  80623c:	e8 7a f7 ff ff       	call   8059bb <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806241:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806245:	66 05 f0 00          	add    $0xf0,%ax
  806249:	0f b7 c0             	movzwl %ax,%eax
  80624c:	89 44 24 04          	mov    %eax,0x4(%esp)
  806250:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806253:	89 04 24             	mov    %eax,(%esp)
  806256:	e8 05 1e 00 00       	call   808060 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80625b:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806262:	00 
  806263:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80626a:	00 
  80626b:	8b 43 08             	mov    0x8(%ebx),%eax
  80626e:	89 04 24             	mov    %eax,(%esp)
  806271:	e8 68 5f 00 00       	call   80c1de <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806276:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80627a:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806281:	00 
  806282:	c7 44 24 08 10 3b 81 	movl   $0x813b10,0x8(%esp)
  806289:	00 
  80628a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80628d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806291:	8b 43 08             	mov    0x8(%ebx),%eax
  806294:	89 04 24             	mov    %eax,(%esp)
  806297:	e8 c4 5f 00 00       	call   80c260 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80629c:	89 f8                	mov    %edi,%eax
  80629e:	e8 12 f9 ff ff       	call   805bb5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  8062a3:	ba 06 00 00 00       	mov    $0x6,%edx
  8062a8:	89 d8                	mov    %ebx,%eax
  8062aa:	e8 01 f5 ff ff       	call   8057b0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8062af:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8062b3:	83 c1 01             	add    $0x1,%ecx
  8062b6:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  8062b9:	ba 10 27 00 00       	mov    $0x2710,%edx
  8062be:	80 f9 03             	cmp    $0x3,%cl
  8062c1:	77 0b                	ja     8062ce <dhcp_discover+0x136>
  8062c3:	0f b6 d1             	movzbl %cl,%edx
  8062c6:	83 c2 01             	add    $0x1,%edx
  8062c9:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8062ce:	0f b7 d2             	movzwl %dx,%edx
  8062d1:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8062d7:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8062dc:	89 d0                	mov    %edx,%eax
  8062de:	f7 e9                	imul   %ecx
  8062e0:	c1 fa 05             	sar    $0x5,%edx
  8062e3:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8062e7:	89 f0                	mov    %esi,%eax
  8062e9:	83 c4 2c             	add    $0x2c,%esp
  8062ec:	5b                   	pop    %ebx
  8062ed:	5e                   	pop    %esi
  8062ee:	5f                   	pop    %edi
  8062ef:	5d                   	pop    %ebp
  8062f0:	c3                   	ret    

008062f1 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  8062f1:	55                   	push   %ebp
  8062f2:	89 e5                	mov    %esp,%ebp
  8062f4:	83 ec 38             	sub    $0x38,%esp
  8062f7:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8062fa:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8062fd:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806300:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  806302:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  806305:	ba 04 00 00 00       	mov    $0x4,%edx
  80630a:	89 d8                	mov    %ebx,%eax
  80630c:	e8 9f f4 ff ff       	call   8057b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806311:	89 f8                	mov    %edi,%eax
  806313:	e8 08 fa ff ff       	call   805d20 <dhcp_create_request>
  806318:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80631a:	84 c0                	test   %al,%al
  80631c:	0f 85 a3 00 00 00    	jne    8063c5 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806322:	b9 01 00 00 00       	mov    $0x1,%ecx
  806327:	ba 35 00 00 00       	mov    $0x35,%edx
  80632c:	89 d8                	mov    %ebx,%eax
  80632e:	e8 c9 f5 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  806333:	ba 03 00 00 00       	mov    $0x3,%edx
  806338:	89 d8                	mov    %ebx,%eax
  80633a:	e8 2c f6 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80633f:	b9 02 00 00 00       	mov    $0x2,%ecx
  806344:	ba 39 00 00 00       	mov    $0x39,%edx
  806349:	89 d8                	mov    %ebx,%eax
  80634b:	e8 ac f5 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_short(dhcp, 576);
  806350:	ba 40 02 00 00       	mov    $0x240,%edx
  806355:	89 d8                	mov    %ebx,%eax
  806357:	e8 29 f7 ff ff       	call   805a85 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80635c:	89 d8                	mov    %ebx,%eax
  80635e:	e8 58 f6 ff ff       	call   8059bb <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806363:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806367:	66 05 f0 00          	add    $0xf0,%ax
  80636b:	0f b7 c0             	movzwl %ax,%eax
  80636e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806372:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806375:	89 04 24             	mov    %eax,(%esp)
  806378:	e8 e3 1c 00 00       	call   808060 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80637d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806384:	00 
  806385:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80638c:	00 
  80638d:	8b 43 08             	mov    0x8(%ebx),%eax
  806390:	89 04 24             	mov    %eax,(%esp)
  806393:	e8 46 5e 00 00       	call   80c1de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806398:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80639c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8063a3:	00 
  8063a4:	c7 44 24 08 10 3b 81 	movl   $0x813b10,0x8(%esp)
  8063ab:	00 
  8063ac:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8063af:	89 44 24 04          	mov    %eax,0x4(%esp)
  8063b3:	8b 43 08             	mov    0x8(%ebx),%eax
  8063b6:	89 04 24             	mov    %eax,(%esp)
  8063b9:	e8 a2 5e 00 00       	call   80c260 <udp_sendto_if>
    dhcp_delete_request(netif);
  8063be:	89 f8                	mov    %edi,%eax
  8063c0:	e8 f0 f7 ff ff       	call   805bb5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8063c5:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8063c9:	83 c1 01             	add    $0x1,%ecx
  8063cc:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8063cf:	ba 10 27 00 00       	mov    $0x2710,%edx
  8063d4:	80 f9 09             	cmp    $0x9,%cl
  8063d7:	77 08                	ja     8063e1 <dhcp_rebind+0xf0>
  8063d9:	0f b6 c9             	movzbl %cl,%ecx
  8063dc:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8063e1:	0f b7 d2             	movzwl %dx,%edx
  8063e4:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8063ea:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8063ef:	89 d0                	mov    %edx,%eax
  8063f1:	f7 e9                	imul   %ecx
  8063f3:	c1 fa 05             	sar    $0x5,%edx
  8063f6:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8063fa:	89 f0                	mov    %esi,%eax
  8063fc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8063ff:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806402:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806405:	89 ec                	mov    %ebp,%esp
  806407:	5d                   	pop    %ebp
  806408:	c3                   	ret    

00806409 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  806409:	55                   	push   %ebp
  80640a:	89 e5                	mov    %esp,%ebp
  80640c:	53                   	push   %ebx
  80640d:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  806410:	8b 1d 00 e6 b3 00    	mov    0xb3e600,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  806416:	85 db                	test   %ebx,%ebx
  806418:	74 67                	je     806481 <dhcp_coarse_tmr+0x78>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80641a:	8b 43 20             	mov    0x20(%ebx),%eax
  80641d:	85 c0                	test   %eax,%eax
  80641f:	74 5a                	je     80647b <dhcp_coarse_tmr+0x72>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  806421:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  806425:	8d 4a ff             	lea    -0x1(%edx),%ecx
  806428:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  80642c:	66 83 fa 01          	cmp    $0x1,%dx
  806430:	75 1b                	jne    80644d <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  806432:	8b 43 20             	mov    0x20(%ebx),%eax
  806435:	0f b6 00             	movzbl (%eax),%eax
  806438:	3c 01                	cmp    $0x1,%al
  80643a:	74 08                	je     806444 <dhcp_coarse_tmr+0x3b>
  80643c:	3c 0a                	cmp    $0xa,%al
  80643e:	74 04                	je     806444 <dhcp_coarse_tmr+0x3b>
  806440:	3c 05                	cmp    $0x5,%al
  806442:	75 37                	jne    80647b <dhcp_coarse_tmr+0x72>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  806444:	89 d8                	mov    %ebx,%eax
  806446:	e8 a6 fe ff ff       	call   8062f1 <dhcp_rebind>
  80644b:	eb 2e                	jmp    80647b <dhcp_coarse_tmr+0x72>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  80644d:	8b 53 20             	mov    0x20(%ebx),%edx
  806450:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  806454:	8d 48 ff             	lea    -0x1(%eax),%ecx
  806457:	66 89 4a 28          	mov    %cx,0x28(%edx)
  80645b:	66 83 f8 01          	cmp    $0x1,%ax
  80645f:	75 1a                	jne    80647b <dhcp_coarse_tmr+0x72>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  806461:	8b 43 20             	mov    0x20(%ebx),%eax
  806464:	0f b6 00             	movzbl (%eax),%eax
  806467:	3c 01                	cmp    $0x1,%al
  806469:	74 08                	je     806473 <dhcp_coarse_tmr+0x6a>
  80646b:	3c 0a                	cmp    $0xa,%al
  80646d:	74 04                	je     806473 <dhcp_coarse_tmr+0x6a>
  80646f:	3c 05                	cmp    $0x5,%al
  806471:	75 08                	jne    80647b <dhcp_coarse_tmr+0x72>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  806473:	89 1c 24             	mov    %ebx,(%esp)
  806476:	e8 03 fc ff ff       	call   80607e <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  80647b:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80647d:	85 db                	test   %ebx,%ebx
  80647f:	75 99                	jne    80641a <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  806481:	83 c4 14             	add    $0x14,%esp
  806484:	5b                   	pop    %ebx
  806485:	5d                   	pop    %ebp
  806486:	c3                   	ret    

00806487 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  806487:	55                   	push   %ebp
  806488:	89 e5                	mov    %esp,%ebp
  80648a:	83 ec 28             	sub    $0x28,%esp
  80648d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806490:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806493:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  806496:	85 f6                	test   %esi,%esi
  806498:	75 1c                	jne    8064b6 <dhcp_arp_reply+0x2f>
  80649a:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  8064a1:	00 
  8064a2:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  8064a9:	00 
  8064aa:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  8064b1:	e8 c6 a4 ff ff       	call   80097c <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  8064b6:	8b 5e 20             	mov    0x20(%esi),%ebx
  8064b9:	85 db                	test   %ebx,%ebx
  8064bb:	0f 84 04 01 00 00    	je     8065c5 <dhcp_arp_reply+0x13e>
  8064c1:	80 3b 08             	cmpb   $0x8,(%ebx)
  8064c4:	0f 85 fb 00 00 00    	jne    8065c5 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8064ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  8064cd:	8b 00                	mov    (%eax),%eax
  8064cf:	3b 43 30             	cmp    0x30(%ebx),%eax
  8064d2:	0f 85 ed 00 00 00    	jne    8065c5 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8064d8:	ba 0c 00 00 00       	mov    $0xc,%edx
  8064dd:	89 d8                	mov    %ebx,%eax
  8064df:	e8 cc f2 ff ff       	call   8057b0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8064e4:	89 f0                	mov    %esi,%eax
  8064e6:	e8 35 f8 ff ff       	call   805d20 <dhcp_create_request>
  if (result == ERR_OK) {
  8064eb:	84 c0                	test   %al,%al
  8064ed:	0f 85 c8 00 00 00    	jne    8065bb <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8064f3:	b9 01 00 00 00       	mov    $0x1,%ecx
  8064f8:	ba 35 00 00 00       	mov    $0x35,%edx
  8064fd:	89 d8                	mov    %ebx,%eax
  8064ff:	e8 f8 f3 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  806504:	ba 04 00 00 00       	mov    $0x4,%edx
  806509:	89 d8                	mov    %ebx,%eax
  80650b:	e8 5b f4 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806510:	b9 02 00 00 00       	mov    $0x2,%ecx
  806515:	ba 39 00 00 00       	mov    $0x39,%edx
  80651a:	89 d8                	mov    %ebx,%eax
  80651c:	e8 db f3 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_short(dhcp, 576);
  806521:	ba 40 02 00 00       	mov    $0x240,%edx
  806526:	89 d8                	mov    %ebx,%eax
  806528:	e8 58 f5 ff ff       	call   805a85 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80652d:	b9 04 00 00 00       	mov    $0x4,%ecx
  806532:	ba 32 00 00 00       	mov    $0x32,%edx
  806537:	89 d8                	mov    %ebx,%eax
  806539:	e8 be f3 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80653e:	8b 43 30             	mov    0x30(%ebx),%eax
  806541:	89 04 24             	mov    %eax,(%esp)
  806544:	e8 d1 49 00 00       	call   80af1a <ntohl>
  806549:	89 c2                	mov    %eax,%edx
  80654b:	89 d8                	mov    %ebx,%eax
  80654d:	e8 b2 f5 ff ff       	call   805b04 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  806552:	89 d8                	mov    %ebx,%eax
  806554:	e8 62 f4 ff ff       	call   8059bb <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806559:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80655d:	66 05 f0 00          	add    $0xf0,%ax
  806561:	0f b7 c0             	movzwl %ax,%eax
  806564:	89 44 24 04          	mov    %eax,0x4(%esp)
  806568:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80656b:	89 04 24             	mov    %eax,(%esp)
  80656e:	e8 ed 1a 00 00       	call   808060 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806573:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80657a:	00 
  80657b:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806582:	00 
  806583:	8b 43 08             	mov    0x8(%ebx),%eax
  806586:	89 04 24             	mov    %eax,(%esp)
  806589:	e8 50 5c 00 00       	call   80c1de <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80658e:	89 74 24 10          	mov    %esi,0x10(%esp)
  806592:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806599:	00 
  80659a:	c7 44 24 08 10 3b 81 	movl   $0x813b10,0x8(%esp)
  8065a1:	00 
  8065a2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8065a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8065a9:	8b 43 08             	mov    0x8(%ebx),%eax
  8065ac:	89 04 24             	mov    %eax,(%esp)
  8065af:	e8 ac 5c 00 00       	call   80c260 <udp_sendto_if>
    dhcp_delete_request(netif);
  8065b4:	89 f0                	mov    %esi,%eax
  8065b6:	e8 fa f5 ff ff       	call   805bb5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8065bb:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8065bf:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  8065c5:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8065c8:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8065cb:	89 ec                	mov    %ebp,%esp
  8065cd:	5d                   	pop    %ebp
  8065ce:	c3                   	ret    

008065cf <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8065cf:	55                   	push   %ebp
  8065d0:	89 e5                	mov    %esp,%ebp
  8065d2:	57                   	push   %edi
  8065d3:	56                   	push   %esi
  8065d4:	53                   	push   %ebx
  8065d5:	83 ec 2c             	sub    $0x2c,%esp
  8065d8:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8065da:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8065dd:	e8 3e f7 ff ff       	call   805d20 <dhcp_create_request>
  8065e2:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8065e4:	84 c0                	test   %al,%al
  8065e6:	0f 85 3a 01 00 00    	jne    806726 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8065ec:	b9 01 00 00 00       	mov    $0x1,%ecx
  8065f1:	ba 35 00 00 00       	mov    $0x35,%edx
  8065f6:	89 d8                	mov    %ebx,%eax
  8065f8:	e8 ff f2 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8065fd:	ba 03 00 00 00       	mov    $0x3,%edx
  806602:	89 d8                	mov    %ebx,%eax
  806604:	e8 62 f3 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806609:	b9 02 00 00 00       	mov    $0x2,%ecx
  80660e:	ba 39 00 00 00       	mov    $0x39,%edx
  806613:	89 d8                	mov    %ebx,%eax
  806615:	e8 e2 f2 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80661a:	ba 40 02 00 00       	mov    $0x240,%edx
  80661f:	89 d8                	mov    %ebx,%eax
  806621:	e8 5f f4 ff ff       	call   805a85 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  806626:	b9 04 00 00 00       	mov    $0x4,%ecx
  80662b:	ba 32 00 00 00       	mov    $0x32,%edx
  806630:	89 d8                	mov    %ebx,%eax
  806632:	e8 c5 f2 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  806637:	8b 43 30             	mov    0x30(%ebx),%eax
  80663a:	89 04 24             	mov    %eax,(%esp)
  80663d:	e8 d8 48 00 00       	call   80af1a <ntohl>
  806642:	89 c2                	mov    %eax,%edx
  806644:	89 d8                	mov    %ebx,%eax
  806646:	e8 b9 f4 ff ff       	call   805b04 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80664b:	b9 04 00 00 00       	mov    $0x4,%ecx
  806650:	ba 36 00 00 00       	mov    $0x36,%edx
  806655:	89 d8                	mov    %ebx,%eax
  806657:	e8 a0 f2 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80665c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80665f:	89 04 24             	mov    %eax,(%esp)
  806662:	e8 b3 48 00 00       	call   80af1a <ntohl>
  806667:	89 c2                	mov    %eax,%edx
  806669:	89 d8                	mov    %ebx,%eax
  80666b:	e8 94 f4 ff ff       	call   805b04 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806670:	b9 04 00 00 00       	mov    $0x4,%ecx
  806675:	ba 37 00 00 00       	mov    $0x37,%edx
  80667a:	89 d8                	mov    %ebx,%eax
  80667c:	e8 7b f2 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806681:	ba 01 00 00 00       	mov    $0x1,%edx
  806686:	89 d8                	mov    %ebx,%eax
  806688:	e8 de f2 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80668d:	ba 03 00 00 00       	mov    $0x3,%edx
  806692:	89 d8                	mov    %ebx,%eax
  806694:	e8 d2 f2 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806699:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80669e:	89 d8                	mov    %ebx,%eax
  8066a0:	e8 c6 f2 ff ff       	call   80596b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8066a5:	ba 06 00 00 00       	mov    $0x6,%edx
  8066aa:	89 d8                	mov    %ebx,%eax
  8066ac:	e8 ba f2 ff ff       	call   80596b <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8066b1:	89 d8                	mov    %ebx,%eax
  8066b3:	e8 03 f3 ff ff       	call   8059bb <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8066b8:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8066bc:	66 05 f0 00          	add    $0xf0,%ax
  8066c0:	0f b7 c0             	movzwl %ax,%eax
  8066c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8066c7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8066ca:	89 04 24             	mov    %eax,(%esp)
  8066cd:	e8 8e 19 00 00       	call   808060 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8066d2:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8066d6:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8066dd:	00 
  8066de:	c7 44 24 08 10 3b 81 	movl   $0x813b10,0x8(%esp)
  8066e5:	00 
  8066e6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8066e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8066ed:	8b 43 08             	mov    0x8(%ebx),%eax
  8066f0:	89 04 24             	mov    %eax,(%esp)
  8066f3:	e8 68 5b 00 00       	call   80c260 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8066f8:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8066ff:	00 
  806700:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806707:	00 
  806708:	8b 43 08             	mov    0x8(%ebx),%eax
  80670b:	89 04 24             	mov    %eax,(%esp)
  80670e:	e8 cb 5a 00 00       	call   80c1de <udp_connect>
    dhcp_delete_request(netif);
  806713:	89 f8                	mov    %edi,%eax
  806715:	e8 9b f4 ff ff       	call   805bb5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80671a:	ba 01 00 00 00       	mov    $0x1,%edx
  80671f:	89 d8                	mov    %ebx,%eax
  806721:	e8 8a f0 ff ff       	call   8057b0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806726:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80672a:	83 c1 01             	add    $0x1,%ecx
  80672d:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  806730:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  806735:	80 f9 03             	cmp    $0x3,%cl
  806738:	77 08                	ja     806742 <dhcp_select+0x173>
  80673a:	0f b6 c9             	movzbl %cl,%ecx
  80673d:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806742:	0f b7 d2             	movzwl %dx,%edx
  806745:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80674b:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  806750:	89 d0                	mov    %edx,%eax
  806752:	f7 e9                	imul   %ecx
  806754:	c1 fa 05             	sar    $0x5,%edx
  806757:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80675b:	89 f0                	mov    %esi,%eax
  80675d:	83 c4 2c             	add    $0x2c,%esp
  806760:	5b                   	pop    %ebx
  806761:	5e                   	pop    %esi
  806762:	5f                   	pop    %edi
  806763:	5d                   	pop    %ebp
  806764:	c3                   	ret    

00806765 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  806765:	55                   	push   %ebp
  806766:	89 e5                	mov    %esp,%ebp
  806768:	83 ec 38             	sub    $0x38,%esp
  80676b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80676e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806771:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806774:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  806777:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80677a:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806781:	e8 ba 09 00 00       	call   807140 <mem_malloc>
  806786:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  806788:	85 c0                	test   %eax,%eax
  80678a:	0f 84 40 01 00 00    	je     8068d0 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806790:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806793:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80679a:	00 
  80679b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8067a2:	00 
  8067a3:	89 04 24             	mov    %eax,(%esp)
  8067a6:	e8 cb aa ff ff       	call   801276 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  8067ab:	e8 df 58 00 00       	call   80c08f <udp_new>
  8067b0:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8067b3:	85 c0                	test   %eax,%eax
  8067b5:	75 0e                	jne    8067c5 <dhcp_inform+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8067b7:	89 1c 24             	mov    %ebx,(%esp)
  8067ba:	e8 0f 0d 00 00       	call   8074ce <mem_free>
    return;
  8067bf:	90                   	nop
  8067c0:	e9 0b 01 00 00       	jmp    8068d0 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8067c5:	89 f0                	mov    %esi,%eax
  8067c7:	e8 54 f5 ff ff       	call   805d20 <dhcp_create_request>
  if (result == ERR_OK) {
  8067cc:	84 c0                	test   %al,%al
  8067ce:	66 90                	xchg   %ax,%ax
  8067d0:	0f 85 d9 00 00 00    	jne    8068af <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8067d6:	b9 01 00 00 00       	mov    $0x1,%ecx
  8067db:	ba 35 00 00 00       	mov    $0x35,%edx
  8067e0:	89 d8                	mov    %ebx,%eax
  8067e2:	e8 15 f1 ff ff       	call   8058fc <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8067e7:	ba 08 00 00 00       	mov    $0x8,%edx
  8067ec:	89 d8                	mov    %ebx,%eax
  8067ee:	e8 78 f1 ff ff       	call   80596b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8067f3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8067f8:	ba 39 00 00 00       	mov    $0x39,%edx
  8067fd:	89 d8                	mov    %ebx,%eax
  8067ff:	e8 f8 f0 ff ff       	call   8058fc <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  806804:	ba 40 02 00 00       	mov    $0x240,%edx
  806809:	89 d8                	mov    %ebx,%eax
  80680b:	e8 75 f2 ff ff       	call   805a85 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  806810:	89 d8                	mov    %ebx,%eax
  806812:	e8 a4 f1 ff ff       	call   8059bb <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806817:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80681b:	66 05 f0 00          	add    $0xf0,%ax
  80681f:	0f b7 c0             	movzwl %ax,%eax
  806822:	89 44 24 04          	mov    %eax,0x4(%esp)
  806826:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806829:	89 04 24             	mov    %eax,(%esp)
  80682c:	e8 2f 18 00 00       	call   808060 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  806831:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806838:	00 
  806839:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806840:	00 
  806841:	8b 43 08             	mov    0x8(%ebx),%eax
  806844:	89 04 24             	mov    %eax,(%esp)
  806847:	e8 cc 58 00 00       	call   80c118 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80684c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806853:	00 
  806854:	c7 44 24 04 10 3b 81 	movl   $0x813b10,0x4(%esp)
  80685b:	00 
  80685c:	8b 43 08             	mov    0x8(%ebx),%eax
  80685f:	89 04 24             	mov    %eax,(%esp)
  806862:	e8 77 59 00 00       	call   80c1de <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806867:	89 74 24 10          	mov    %esi,0x10(%esp)
  80686b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806872:	00 
  806873:	c7 44 24 08 10 3b 81 	movl   $0x813b10,0x8(%esp)
  80687a:	00 
  80687b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80687e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806882:	8b 43 08             	mov    0x8(%ebx),%eax
  806885:	89 04 24             	mov    %eax,(%esp)
  806888:	e8 d3 59 00 00       	call   80c260 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80688d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806894:	00 
  806895:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80689c:	00 
  80689d:	8b 43 08             	mov    0x8(%ebx),%eax
  8068a0:	89 04 24             	mov    %eax,(%esp)
  8068a3:	e8 36 59 00 00       	call   80c1de <udp_connect>
    dhcp_delete_request(netif);
  8068a8:	89 f0                	mov    %esi,%eax
  8068aa:	e8 06 f3 ff ff       	call   805bb5 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  8068af:	8b 43 08             	mov    0x8(%ebx),%eax
  8068b2:	85 c0                	test   %eax,%eax
  8068b4:	74 08                	je     8068be <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  8068b6:	89 04 24             	mov    %eax,(%esp)
  8068b9:	e8 0e 58 00 00       	call   80c0cc <udp_remove>
    }
    dhcp->pcb = NULL;
  8068be:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8068c5:	89 1c 24             	mov    %ebx,(%esp)
  8068c8:	e8 01 0c 00 00       	call   8074ce <mem_free>
    netif->dhcp = old_dhcp;
  8068cd:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  8068d0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8068d3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8068d6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8068d9:	89 ec                	mov    %ebp,%esp
  8068db:	5d                   	pop    %ebp
  8068dc:	c3                   	ret    

008068dd <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8068dd:	55                   	push   %ebp
  8068de:	89 e5                	mov    %esp,%ebp
  8068e0:	56                   	push   %esi
  8068e1:	53                   	push   %ebx
  8068e2:	83 ec 10             	sub    $0x10,%esp
  8068e5:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8068e8:	85 f6                	test   %esi,%esi
  8068ea:	75 1c                	jne    806908 <dhcp_start+0x2b>
  8068ec:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  8068f3:	00 
  8068f4:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8068fb:	00 
  8068fc:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806903:	e8 74 a0 ff ff       	call   80097c <_panic>
  dhcp = netif->dhcp;
  806908:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80690b:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  80690f:	85 db                	test   %ebx,%ebx
  806911:	75 1e                	jne    806931 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  806913:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  80691a:	e8 21 08 00 00       	call   807140 <mem_malloc>
  80691f:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  806921:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806926:	85 db                	test   %ebx,%ebx
  806928:	0f 84 a5 00 00 00    	je     8069d3 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  80692e:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  806931:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  806938:	00 
  806939:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806940:	00 
  806941:	89 1c 24             	mov    %ebx,(%esp)
  806944:	e8 2d a9 ff ff       	call   801276 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  806949:	e8 41 57 00 00       	call   80c08f <udp_new>
  80694e:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806951:	85 c0                	test   %eax,%eax
  806953:	75 16                	jne    80696b <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  806955:	89 1c 24             	mov    %ebx,(%esp)
  806958:	e8 71 0b 00 00       	call   8074ce <mem_free>
    netif->dhcp = dhcp = NULL;
  80695d:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806964:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  806969:	eb 68                	jmp    8069d3 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80696b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806972:	00 
  806973:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  80697a:	00 
  80697b:	89 04 24             	mov    %eax,(%esp)
  80697e:	e8 95 57 00 00       	call   80c118 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806983:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80698a:	00 
  80698b:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806992:	00 
  806993:	8b 43 08             	mov    0x8(%ebx),%eax
  806996:	89 04 24             	mov    %eax,(%esp)
  806999:	e8 40 58 00 00       	call   80c1de <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80699e:	89 74 24 08          	mov    %esi,0x8(%esp)
  8069a2:	c7 44 24 04 b2 6b 80 	movl   $0x806bb2,0x4(%esp)
  8069a9:	00 
  8069aa:	8b 43 08             	mov    0x8(%ebx),%eax
  8069ad:	89 04 24             	mov    %eax,(%esp)
  8069b0:	e8 c6 56 00 00       	call   80c07b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  8069b5:	89 f0                	mov    %esi,%eax
  8069b7:	e8 dc f7 ff ff       	call   806198 <dhcp_discover>
  if (result != ERR_OK) {
  8069bc:	84 c0                	test   %al,%al
  8069be:	74 0f                	je     8069cf <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  8069c0:	89 34 24             	mov    %esi,(%esp)
  8069c3:	e8 d9 f2 ff ff       	call   805ca1 <dhcp_stop>
  8069c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  8069cd:	eb 04                	jmp    8069d3 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8069cf:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  8069d3:	83 c4 10             	add    $0x10,%esp
  8069d6:	5b                   	pop    %ebx
  8069d7:	5e                   	pop    %esi
  8069d8:	5d                   	pop    %ebp
  8069d9:	c3                   	ret    

008069da <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8069da:	55                   	push   %ebp
  8069db:	89 e5                	mov    %esp,%ebp
  8069dd:	53                   	push   %ebx
  8069de:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  8069e1:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8069e4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8069eb:	00 
  8069ec:	8d 53 30             	lea    0x30(%ebx),%edx
  8069ef:	89 54 24 04          	mov    %edx,0x4(%esp)
  8069f3:	89 04 24             	mov    %eax,(%esp)
  8069f6:	e8 9c 62 00 00       	call   80cc97 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8069fb:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8069ff:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  806a05:	ba 08 00 00 00       	mov    $0x8,%edx
  806a0a:	89 d8                	mov    %ebx,%eax
  806a0c:	e8 9f ed ff ff       	call   8057b0 <dhcp_set_state>
}
  806a11:	83 c4 14             	add    $0x14,%esp
  806a14:	5b                   	pop    %ebx
  806a15:	5d                   	pop    %ebp
  806a16:	c3                   	ret    

00806a17 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  806a17:	55                   	push   %ebp
  806a18:	89 e5                	mov    %esp,%ebp
  806a1a:	57                   	push   %edi
  806a1b:	56                   	push   %esi
  806a1c:	53                   	push   %ebx
  806a1d:	83 ec 2c             	sub    $0x2c,%esp
  806a20:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  806a22:	85 c0                	test   %eax,%eax
  806a24:	75 1c                	jne    806a42 <dhcp_bind+0x2b>
  806a26:	c7 44 24 08 58 32 81 	movl   $0x813258,0x8(%esp)
  806a2d:	00 
  806a2e:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  806a35:	00 
  806a36:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806a3d:	e8 3a 9f ff ff       	call   80097c <_panic>
  dhcp = netif->dhcp;
  806a42:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  806a45:	85 db                	test   %ebx,%ebx
  806a47:	75 1c                	jne    806a65 <dhcp_bind+0x4e>
  806a49:	c7 44 24 08 71 32 81 	movl   $0x813271,0x8(%esp)
  806a50:	00 
  806a51:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  806a58:	00 
  806a59:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806a60:	e8 17 9f ff ff       	call   80097c <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  806a65:	8b 53 50             	mov    0x50(%ebx),%edx
  806a68:	83 fa ff             	cmp    $0xffffffff,%edx
  806a6b:	74 2b                	je     806a98 <dhcp_bind+0x81>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806a6d:	83 c2 1e             	add    $0x1e,%edx
  806a70:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806a75:	89 d0                	mov    %edx,%eax
  806a77:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  806a79:	c1 ea 05             	shr    $0x5,%edx
  806a7c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806a82:	76 05                	jbe    806a89 <dhcp_bind+0x72>
  806a84:	ba ff ff 00 00       	mov    $0xffff,%edx
  806a89:	66 89 53 28          	mov    %dx,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  806a8d:	66 85 d2             	test   %dx,%dx
  806a90:	75 06                	jne    806a98 <dhcp_bind+0x81>
      dhcp->t1_timeout = 1;
  806a92:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  806a98:	8b 53 54             	mov    0x54(%ebx),%edx
  806a9b:	83 fa ff             	cmp    $0xffffffff,%edx
  806a9e:	74 2b                	je     806acb <dhcp_bind+0xb4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806aa0:	83 c2 1e             	add    $0x1e,%edx
  806aa3:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806aa8:	89 d0                	mov    %edx,%eax
  806aaa:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806aac:	c1 ea 05             	shr    $0x5,%edx
  806aaf:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806ab5:	76 05                	jbe    806abc <dhcp_bind+0xa5>
  806ab7:	ba ff ff 00 00       	mov    $0xffff,%edx
  806abc:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  806ac0:	66 85 d2             	test   %dx,%dx
  806ac3:	75 06                	jne    806acb <dhcp_bind+0xb4>
      dhcp->t2_timeout = 1;
  806ac5:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806acb:	83 fb cc             	cmp    $0xffffffcc,%ebx
  806ace:	0f 84 c7 00 00 00    	je     806b9b <dhcp_bind+0x184>
  806ad4:	8b 43 34             	mov    0x34(%ebx),%eax
  806ad7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  806ada:	85 c0                	test   %eax,%eax
  806adc:	75 4b                	jne    806b29 <dhcp_bind+0x112>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  806ade:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806ae5:	e8 30 44 00 00       	call   80af1a <ntohl>
  806aea:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  806aed:	84 c0                	test   %al,%al
  806aef:	78 11                	js     806b02 <dhcp_bind+0xeb>
      sn_mask.addr = htonl(0xff000000);
  806af1:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  806af8:	e8 f8 41 00 00       	call   80acf5 <htonl>
  806afd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b00:	eb 27                	jmp    806b29 <dhcp_bind+0x112>
    } else if (first_octet >= 192) {
  806b02:	3c bf                	cmp    $0xbf,%al
  806b04:	76 14                	jbe    806b1a <dhcp_bind+0x103>
      sn_mask.addr = htonl(0xffffff00);
  806b06:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  806b0d:	8d 76 00             	lea    0x0(%esi),%esi
  806b10:	e8 e0 41 00 00       	call   80acf5 <htonl>
  806b15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b18:	eb 0f                	jmp    806b29 <dhcp_bind+0x112>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  806b1a:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  806b21:	e8 cf 41 00 00       	call   80acf5 <htonl>
  806b26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806b29:	83 fb c8             	cmp    $0xffffffc8,%ebx
  806b2c:	74 79                	je     806ba7 <dhcp_bind+0x190>
  806b2e:	8b 43 38             	mov    0x38(%ebx),%eax
  806b31:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  806b34:	85 c0                	test   %eax,%eax
  806b36:	75 1a                	jne    806b52 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  806b38:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806b3b:	23 7b 30             	and    0x30(%ebx),%edi
  806b3e:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  806b41:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  806b48:	e8 a8 41 00 00       	call   80acf5 <htonl>
  806b4d:	09 c7                	or     %eax,%edi
  806b4f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  806b52:	8d 43 30             	lea    0x30(%ebx),%eax
  806b55:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b59:	89 34 24             	mov    %esi,(%esp)
  806b5c:	e8 c3 0d 00 00       	call   807924 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806b61:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806b64:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b68:	89 34 24             	mov    %esi,(%esp)
  806b6b:	e8 d8 0c 00 00       	call   807848 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806b70:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806b73:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b77:	89 34 24             	mov    %esi,(%esp)
  806b7a:	e8 b0 0c 00 00       	call   80782f <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  806b7f:	89 34 24             	mov    %esi,(%esp)
  806b82:	e8 67 0d 00 00       	call   8078ee <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  806b87:	ba 0a 00 00 00       	mov    $0xa,%edx
  806b8c:	89 d8                	mov    %ebx,%eax
  806b8e:	e8 1d ec ff ff       	call   8057b0 <dhcp_set_state>
}
  806b93:	83 c4 2c             	add    $0x2c,%esp
  806b96:	5b                   	pop    %ebx
  806b97:	5e                   	pop    %esi
  806b98:	5f                   	pop    %edi
  806b99:	5d                   	pop    %ebp
  806b9a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806b9b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806ba2:	e9 37 ff ff ff       	jmp    806ade <dhcp_bind+0xc7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806ba7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806bae:	66 90                	xchg   %ax,%ax
  806bb0:	eb 86                	jmp    806b38 <dhcp_bind+0x121>

00806bb2 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806bb2:	55                   	push   %ebp
  806bb3:	89 e5                	mov    %esp,%ebp
  806bb5:	57                   	push   %edi
  806bb6:	56                   	push   %esi
  806bb7:	53                   	push   %ebx
  806bb8:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  806bbb:	8b 45 08             	mov    0x8(%ebp),%eax
  806bbe:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  806bc1:	8b 50 20             	mov    0x20(%eax),%edx
  806bc4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806bc7:	8b 4d 10             	mov    0x10(%ebp),%ecx
  806bca:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  806bcd:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  806bd0:	80 3e 02             	cmpb   $0x2,(%esi)
  806bd3:	0f 85 33 04 00 00    	jne    80700c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806bd9:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  806bdd:	89 fb                	mov    %edi,%ebx
  806bdf:	84 db                	test   %bl,%bl
  806be1:	74 35                	je     806c18 <dhcp_recv+0x66>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  806be3:	0f b6 48 25          	movzbl 0x25(%eax),%ecx
  806be7:	89 c2                	mov    %eax,%edx
  806be9:	b8 00 00 00 00       	mov    $0x0,%eax
  806bee:	3a 4e 1c             	cmp    0x1c(%esi),%cl
  806bf1:	74 1c                	je     806c0f <dhcp_recv+0x5d>
  806bf3:	e9 14 04 00 00       	jmp    80700c <dhcp_recv+0x45a>
  806bf8:	0f b6 5a 26          	movzbl 0x26(%edx),%ebx
  806bfc:	0f b6 4c 06 1d       	movzbl 0x1d(%esi,%eax,1),%ecx
  806c01:	83 c0 01             	add    $0x1,%eax
  806c04:	83 c2 01             	add    $0x1,%edx
  806c07:	38 cb                	cmp    %cl,%bl
  806c09:	0f 85 fd 03 00 00    	jne    80700c <dhcp_recv+0x45a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806c0f:	8d 48 01             	lea    0x1(%eax),%ecx
  806c12:	89 fb                	mov    %edi,%ebx
  806c14:	38 cb                	cmp    %cl,%bl
  806c16:	77 e0                	ja     806bf8 <dhcp_recv+0x46>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  806c18:	8b 46 04             	mov    0x4(%esi),%eax
  806c1b:	89 04 24             	mov    %eax,(%esp)
  806c1e:	e8 f7 42 00 00       	call   80af1a <ntohl>
  806c23:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c26:	3b 42 04             	cmp    0x4(%edx),%eax
  806c29:	0f 85 dd 03 00 00    	jne    80700c <dhcp_recv+0x45a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  806c2f:	85 d2                	test   %edx,%edx
  806c31:	75 1c                	jne    806c4f <dhcp_recv+0x9d>
  806c33:	c7 44 24 08 7c 32 81 	movl   $0x81327c,0x8(%esp)
  806c3a:	00 
  806c3b:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  806c42:	00 
  806c43:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806c4a:	e8 2d 9d ff ff       	call   80097c <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  806c4f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806c52:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  806c56:	75 1c                	jne    806c74 <dhcp_recv+0xc2>
  806c58:	c7 44 24 08 89 32 81 	movl   $0x813289,0x8(%esp)
  806c5f:	00 
  806c60:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  806c67:	00 
  806c68:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806c6f:	e8 08 9d ff ff       	call   80097c <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  806c74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c77:	e8 e4 ef ff ff       	call   805c60 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  806c7c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806c7f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806c82:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806c86:	66 3d f0 00          	cmp    $0xf0,%ax
  806c8a:	76 1e                	jbe    806caa <dhcp_recv+0xf8>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806c8c:	66 2d f0 00          	sub    $0xf0,%ax
  806c90:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  806c94:	0f b7 c0             	movzwl %ax,%eax
  806c97:	89 04 24             	mov    %eax,(%esp)
  806c9a:	e8 a1 04 00 00       	call   807140 <mem_malloc>
  806c9f:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  806ca2:	85 c0                	test   %eax,%eax
  806ca4:	0f 84 62 03 00 00    	je     80700c <dhcp_recv+0x45a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806caa:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  806cb1:	e8 8a 04 00 00       	call   807140 <mem_malloc>
  806cb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806cb9:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  806cbc:	85 c0                	test   %eax,%eax
  806cbe:	75 1a                	jne    806cda <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  806cc0:	8b 42 14             	mov    0x14(%edx),%eax
  806cc3:	89 04 24             	mov    %eax,(%esp)
  806cc6:	e8 03 08 00 00       	call   8074ce <mem_free>
    dhcp->options_in = NULL;
  806ccb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806cce:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  806cd5:	e9 32 03 00 00       	jmp    80700c <dhcp_recv+0x45a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  806cda:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806ce1:	00 
  806ce2:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  806ce9:	00 
  806cea:	89 44 24 04          	mov    %eax,0x4(%esp)
  806cee:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806cf1:	8b 43 0c             	mov    0xc(%ebx),%eax
  806cf4:	89 04 24             	mov    %eax,(%esp)
  806cf7:	e8 5a 0f 00 00       	call   807c56 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806cfc:	66 3d f0 00          	cmp    $0xf0,%ax
  806d00:	74 1c                	je     806d1e <dhcp_recv+0x16c>
  806d02:	c7 44 24 08 f8 31 81 	movl   $0x8131f8,0x8(%esp)
  806d09:	00 
  806d0a:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  806d11:	00 
  806d12:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806d19:	e8 5e 9c ff ff       	call   80097c <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  806d1e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d21:	8b 42 14             	mov    0x14(%edx),%eax
  806d24:	85 c0                	test   %eax,%eax
  806d26:	0f 84 fd 02 00 00    	je     807029 <dhcp_recv+0x477>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806d2c:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  806d33:	00 
  806d34:	89 d1                	mov    %edx,%ecx
  806d36:	0f b7 52 18          	movzwl 0x18(%edx),%edx
  806d3a:	89 54 24 08          	mov    %edx,0x8(%esp)
  806d3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d42:	8b 41 0c             	mov    0xc(%ecx),%eax
  806d45:	89 04 24             	mov    %eax,(%esp)
  806d48:	e8 09 0f 00 00       	call   807c56 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  806d4d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806d50:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  806d54:	0f 84 cf 02 00 00    	je     807029 <dhcp_recv+0x477>
  806d5a:	c7 44 24 08 99 32 81 	movl   $0x813299,0x8(%esp)
  806d61:	00 
  806d62:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806d69:	00 
  806d6a:	c7 04 24 2a 32 81 00 	movl   $0x81322a,(%esp)
  806d71:	e8 06 9c ff ff       	call   80097c <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806d76:	83 c0 02             	add    $0x2,%eax
  806d79:	e8 4d eb ff ff       	call   8058cb <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  806d7e:	3c 05                	cmp    $0x5,%al
  806d80:	0f 85 a6 01 00 00    	jne    806f2c <dhcp_recv+0x37a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806d86:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d89:	0f b6 02             	movzbl (%edx),%eax
  806d8c:	3c 01                	cmp    $0x1,%al
  806d8e:	0f 85 77 01 00 00    	jne    806f0b <dhcp_recv+0x359>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806d94:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806d97:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  806d9a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  806da1:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  806da8:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  806daf:	ba 33 00 00 00       	mov    $0x33,%edx
  806db4:	89 d8                	mov    %ebx,%eax
  806db6:	e8 04 ea ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806dbb:	85 c0                	test   %eax,%eax
  806dbd:	74 0b                	je     806dca <dhcp_recv+0x218>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  806dbf:	83 c0 02             	add    $0x2,%eax
  806dc2:	e8 0c eb ff ff       	call   8058d3 <dhcp_get_option_long>
  806dc7:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  806dca:	ba 3a 00 00 00       	mov    $0x3a,%edx
  806dcf:	89 d8                	mov    %ebx,%eax
  806dd1:	e8 e9 e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806dd6:	85 c0                	test   %eax,%eax
  806dd8:	74 0d                	je     806de7 <dhcp_recv+0x235>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  806dda:	83 c0 02             	add    $0x2,%eax
  806ddd:	e8 f1 ea ff ff       	call   8058d3 <dhcp_get_option_long>
  806de2:	89 43 50             	mov    %eax,0x50(%ebx)
  806de5:	eb 08                	jmp    806def <dhcp_recv+0x23d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  806de7:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806dea:	d1 e8                	shr    %eax
  806dec:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  806def:	ba 3b 00 00 00       	mov    $0x3b,%edx
  806df4:	89 d8                	mov    %ebx,%eax
  806df6:	e8 c4 e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806dfb:	85 c0                	test   %eax,%eax
  806dfd:	74 0d                	je     806e0c <dhcp_recv+0x25a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  806dff:	83 c0 02             	add    $0x2,%eax
  806e02:	e8 cc ea ff ff       	call   8058d3 <dhcp_get_option_long>
  806e07:	89 43 54             	mov    %eax,0x54(%ebx)
  806e0a:	eb 06                	jmp    806e12 <dhcp_recv+0x260>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  806e0c:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806e0f:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  806e12:	8b 53 10             	mov    0x10(%ebx),%edx
  806e15:	b8 00 00 00 00       	mov    $0x0,%eax
  806e1a:	83 fa f0             	cmp    $0xfffffff0,%edx
  806e1d:	74 03                	je     806e22 <dhcp_recv+0x270>
  806e1f:	8b 42 10             	mov    0x10(%edx),%eax
  806e22:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  806e25:	ba 01 00 00 00       	mov    $0x1,%edx
  806e2a:	89 d8                	mov    %ebx,%eax
  806e2c:	e8 8e e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  806e31:	85 c0                	test   %eax,%eax
  806e33:	74 13                	je     806e48 <dhcp_recv+0x296>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806e35:	83 c0 02             	add    $0x2,%eax
  806e38:	e8 96 ea ff ff       	call   8058d3 <dhcp_get_option_long>
  806e3d:	89 04 24             	mov    %eax,(%esp)
  806e40:	e8 b0 3e 00 00       	call   80acf5 <htonl>
  806e45:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  806e48:	ba 03 00 00 00       	mov    $0x3,%edx
  806e4d:	89 d8                	mov    %ebx,%eax
  806e4f:	e8 6b e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e54:	85 c0                	test   %eax,%eax
  806e56:	74 13                	je     806e6b <dhcp_recv+0x2b9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806e58:	83 c0 02             	add    $0x2,%eax
  806e5b:	e8 73 ea ff ff       	call   8058d3 <dhcp_get_option_long>
  806e60:	89 04 24             	mov    %eax,(%esp)
  806e63:	e8 8d 3e 00 00       	call   80acf5 <htonl>
  806e68:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  806e6b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806e70:	89 d8                	mov    %ebx,%eax
  806e72:	e8 48 e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e77:	85 c0                	test   %eax,%eax
  806e79:	74 13                	je     806e8e <dhcp_recv+0x2dc>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806e7b:	83 c0 02             	add    $0x2,%eax
  806e7e:	e8 50 ea ff ff       	call   8058d3 <dhcp_get_option_long>
  806e83:	89 04 24             	mov    %eax,(%esp)
  806e86:	e8 6a 3e 00 00       	call   80acf5 <htonl>
  806e8b:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  806e8e:	ba 06 00 00 00       	mov    $0x6,%edx
  806e93:	89 d8                	mov    %ebx,%eax
  806e95:	e8 25 e9 ff ff       	call   8057bf <dhcp_get_option_ptr>
  806e9a:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  806e9c:	85 c0                	test   %eax,%eax
  806e9e:	74 55                	je     806ef5 <dhcp_recv+0x343>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806ea0:	8d 40 01             	lea    0x1(%eax),%eax
  806ea3:	e8 23 ea ff ff       	call   8058cb <dhcp_get_option_byte>
  806ea8:	c0 e8 02             	shr    $0x2,%al
  806eab:	0f b6 c0             	movzbl %al,%eax
  806eae:	89 43 40             	mov    %eax,0x40(%ebx)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  806eb1:	83 f8 02             	cmp    $0x2,%eax
  806eb4:	76 07                	jbe    806ebd <dhcp_recv+0x30b>
      dhcp->dns_count = DHCP_MAX_DNS;
  806eb6:	c7 43 40 02 00 00 00 	movl   $0x2,0x40(%ebx)
  806ebd:	bf 00 00 00 00       	mov    $0x0,%edi
  806ec2:	89 f8                	mov    %edi,%eax
  806ec4:	89 f7                	mov    %esi,%edi
  806ec6:	89 de                	mov    %ebx,%esi
  806ec8:	89 c3                	mov    %eax,%ebx
  806eca:	eb 21                	jmp    806eed <dhcp_recv+0x33b>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  806ecc:	0f b6 c3             	movzbl %bl,%eax
  806ecf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806ed2:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  806ed6:	e8 f8 e9 ff ff       	call   8058d3 <dhcp_get_option_long>
  806edb:	89 04 24             	mov    %eax,(%esp)
  806ede:	e8 12 3e 00 00       	call   80acf5 <htonl>
  806ee3:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806ee6:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806eea:	83 c3 01             	add    $0x1,%ebx
  806eed:	0f b6 c3             	movzbl %bl,%eax
  806ef0:	3b 46 40             	cmp    0x40(%esi),%eax
  806ef3:	72 d7                	jb     806ecc <dhcp_recv+0x31a>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  806ef5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806ef8:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  806efe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f01:	e8 d4 fa ff ff       	call   8069da <dhcp_check>
  806f06:	e9 01 01 00 00       	jmp    80700c <dhcp_recv+0x45a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  806f0b:	83 e8 03             	sub    $0x3,%eax
  806f0e:	3c 02                	cmp    $0x2,%al
  806f10:	0f 87 f6 00 00 00    	ja     80700c <dhcp_recv+0x45a>
      dhcp->request_timeout = 0;
  806f16:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806f19:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  806f1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f22:	e8 f0 fa ff ff       	call   806a17 <dhcp_bind>
  806f27:	e9 e0 00 00 00       	jmp    80700c <dhcp_recv+0x45a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806f2c:	3c 06                	cmp    $0x6,%al
  806f2e:	0f 85 80 00 00 00    	jne    806fb4 <dhcp_recv+0x402>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  806f34:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806f37:	0f b6 02             	movzbl (%edx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806f3a:	3c 03                	cmp    $0x3,%al
  806f3c:	74 10                	je     806f4e <dhcp_recv+0x39c>
  806f3e:	3c 01                	cmp    $0x1,%al
  806f40:	74 0c                	je     806f4e <dhcp_recv+0x39c>
  806f42:	3c 04                	cmp    $0x4,%al
  806f44:	74 08                	je     806f4e <dhcp_recv+0x39c>
  806f46:	3c 05                	cmp    $0x5,%al
  806f48:	0f 85 be 00 00 00    	jne    80700c <dhcp_recv+0x45a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  806f4e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806f51:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806f57:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f5a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  806f5d:	89 04 24             	mov    %eax,(%esp)
  806f60:	e8 63 09 00 00       	call   8078c8 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806f65:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806f6c:	00 
  806f6d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f70:	89 14 24             	mov    %edx,(%esp)
  806f73:	e8 ac 09 00 00       	call   807924 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806f78:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806f7f:	00 
  806f80:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f83:	89 0c 24             	mov    %ecx,(%esp)
  806f86:	e8 a4 08 00 00       	call   80782f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  806f8b:	c7 44 24 04 0c 3b 81 	movl   $0x813b0c,0x4(%esp)
  806f92:	00 
  806f93:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f96:	89 04 24             	mov    %eax,(%esp)
  806f99:	e8 aa 08 00 00       	call   807848 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806f9e:	ba 0c 00 00 00       	mov    $0xc,%edx
  806fa3:	89 d8                	mov    %ebx,%eax
  806fa5:	e8 06 e8 ff ff       	call   8057b0 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  806faa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806fad:	e8 e6 f1 ff ff       	call   806198 <dhcp_discover>
  806fb2:	eb 58                	jmp    80700c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  806fb4:	3c 02                	cmp    $0x2,%al
  806fb6:	75 54                	jne    80700c <dhcp_recv+0x45a>
  806fb8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806fbb:	80 3a 06             	cmpb   $0x6,(%edx)
  806fbe:	66 90                	xchg   %ax,%ax
  806fc0:	75 4a                	jne    80700c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  806fc2:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806fc8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806fcb:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  806fce:	ba 36 00 00 00       	mov    $0x36,%edx
  806fd3:	89 d8                	mov    %ebx,%eax
  806fd5:	e8 e5 e7 ff ff       	call   8057bf <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  806fda:	85 c0                	test   %eax,%eax
  806fdc:	74 2e                	je     80700c <dhcp_recv+0x45a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806fde:	83 c0 02             	add    $0x2,%eax
  806fe1:	e8 ed e8 ff ff       	call   8058d3 <dhcp_get_option_long>
  806fe6:	89 04 24             	mov    %eax,(%esp)
  806fe9:	e8 07 3d 00 00       	call   80acf5 <htonl>
  806fee:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  806ff1:	8b 53 10             	mov    0x10(%ebx),%edx
  806ff4:	b8 00 00 00 00       	mov    $0x0,%eax
  806ff9:	83 fa f0             	cmp    $0xfffffff0,%edx
  806ffc:	74 03                	je     807001 <dhcp_recv+0x44f>
  806ffe:	8b 42 10             	mov    0x10(%edx),%eax
  807001:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  807004:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807007:	e8 c3 f5 ff ff       	call   8065cf <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80700c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80700f:	89 1c 24             	mov    %ebx,(%esp)
  807012:	e8 c1 0e 00 00       	call   807ed8 <pbuf_free>
  dhcp->p = NULL;
  807017:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80701a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  807021:	83 c4 2c             	add    $0x2c,%esp
  807024:	5b                   	pop    %ebx
  807025:	5e                   	pop    %esi
  807026:	5f                   	pop    %edi
  807027:	5d                   	pop    %ebp
  807028:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  807029:	ba 35 00 00 00       	mov    $0x35,%edx
  80702e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807031:	e8 89 e7 ff ff       	call   8057bf <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  807036:	85 c0                	test   %eax,%eax
  807038:	0f 85 38 fd ff ff    	jne    806d76 <dhcp_recv+0x1c4>
  80703e:	66 90                	xchg   %ax,%ax
  807040:	eb ca                	jmp    80700c <dhcp_recv+0x45a>

00807042 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  807042:	55                   	push   %ebp
  807043:	89 e5                	mov    %esp,%ebp
  807045:	53                   	push   %ebx
  807046:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  807049:	8b 1d 00 e6 b3 00    	mov    0xb3e600,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  80704f:	85 db                	test   %ebx,%ebx
  807051:	0f 84 dd 00 00 00    	je     807134 <dhcp_fine_tmr+0xf2>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  807057:	8b 43 20             	mov    0x20(%ebx),%eax
  80705a:	85 c0                	test   %eax,%eax
  80705c:	0f 84 c8 00 00 00    	je     80712a <dhcp_fine_tmr+0xe8>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  807062:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  807066:	66 83 fa 01          	cmp    $0x1,%dx
  80706a:	76 0c                	jbe    807078 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  80706c:	83 ea 01             	sub    $0x1,%edx
  80706f:	66 89 50 26          	mov    %dx,0x26(%eax)
  807073:	e9 b2 00 00 00       	jmp    80712a <dhcp_fine_tmr+0xe8>
      }
      else if (netif->dhcp->request_timeout == 1) {
  807078:	66 83 fa 01          	cmp    $0x1,%dx
  80707c:	0f 85 a8 00 00 00    	jne    80712a <dhcp_fine_tmr+0xe8>
        netif->dhcp->request_timeout--;
  807082:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807088:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80708b:	0f b6 02             	movzbl (%edx),%eax
  80708e:	3c 0c                	cmp    $0xc,%al
  807090:	74 04                	je     807096 <dhcp_fine_tmr+0x54>
  807092:	3c 06                	cmp    $0x6,%al
  807094:	75 0f                	jne    8070a5 <dhcp_fine_tmr+0x63>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  807096:	89 d8                	mov    %ebx,%eax
  807098:	e8 fb f0 ff ff       	call   806198 <dhcp_discover>
  80709d:	8d 76 00             	lea    0x0(%esi),%esi
  8070a0:	e9 85 00 00 00       	jmp    80712a <dhcp_fine_tmr+0xe8>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  8070a5:	3c 01                	cmp    $0x1,%al
  8070a7:	75 23                	jne    8070cc <dhcp_fine_tmr+0x8a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  8070a9:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  8070ad:	8d 76 00             	lea    0x0(%esi),%esi
  8070b0:	77 09                	ja     8070bb <dhcp_fine_tmr+0x79>
      dhcp_select(netif);
  8070b2:	89 d8                	mov    %ebx,%eax
  8070b4:	e8 16 f5 ff ff       	call   8065cf <dhcp_select>
  8070b9:	eb 6f                	jmp    80712a <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8070bb:	89 1c 24             	mov    %ebx,(%esp)
  8070be:	e8 52 ee ff ff       	call   805f15 <dhcp_release>
      dhcp_discover(netif);
  8070c3:	89 d8                	mov    %ebx,%eax
  8070c5:	e8 ce f0 ff ff       	call   806198 <dhcp_discover>
  8070ca:	eb 5e                	jmp    80712a <dhcp_fine_tmr+0xe8>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8070cc:	3c 08                	cmp    $0x8,%al
  8070ce:	66 90                	xchg   %ax,%ax
  8070d0:	75 20                	jne    8070f2 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8070d2:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  8070d6:	66 90                	xchg   %ax,%ax
  8070d8:	77 0d                	ja     8070e7 <dhcp_fine_tmr+0xa5>
      dhcp_check(netif);
  8070da:	89 d8                	mov    %ebx,%eax
  8070dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8070e0:	e8 f5 f8 ff ff       	call   8069da <dhcp_check>
  8070e5:	eb 43                	jmp    80712a <dhcp_fine_tmr+0xe8>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8070e7:	89 d8                	mov    %ebx,%eax
  8070e9:	e8 29 f9 ff ff       	call   806a17 <dhcp_bind>
  8070ee:	66 90                	xchg   %ax,%ax
  8070f0:	eb 38                	jmp    80712a <dhcp_fine_tmr+0xe8>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8070f2:	3c 05                	cmp    $0x5,%al
  8070f4:	75 11                	jne    807107 <dhcp_fine_tmr+0xc5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8070f6:	89 1c 24             	mov    %ebx,(%esp)
  8070f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  807100:	e8 79 ef ff ff       	call   80607e <dhcp_renew>
  807105:	eb 23                	jmp    80712a <dhcp_fine_tmr+0xe8>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  807107:	3c 04                	cmp    $0x4,%al
  807109:	75 1f                	jne    80712a <dhcp_fine_tmr+0xe8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80710b:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  80710f:	90                   	nop
  807110:	77 09                	ja     80711b <dhcp_fine_tmr+0xd9>
      dhcp_rebind(netif);
  807112:	89 d8                	mov    %ebx,%eax
  807114:	e8 d8 f1 ff ff       	call   8062f1 <dhcp_rebind>
  807119:	eb 0f                	jmp    80712a <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80711b:	89 1c 24             	mov    %ebx,(%esp)
  80711e:	e8 f2 ed ff ff       	call   805f15 <dhcp_release>
      dhcp_discover(netif);
  807123:	89 d8                	mov    %ebx,%eax
  807125:	e8 6e f0 ff ff       	call   806198 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  80712a:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  80712c:	85 db                	test   %ebx,%ebx
  80712e:	0f 85 23 ff ff ff    	jne    807057 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  807134:	83 c4 14             	add    $0x14,%esp
  807137:	5b                   	pop    %ebx
  807138:	5d                   	pop    %ebp
  807139:	c3                   	ret    
  80713a:	00 00                	add    %al,(%eax)
  80713c:	00 00                	add    %al,(%eax)
	...

00807140 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  807140:	55                   	push   %ebp
  807141:	89 e5                	mov    %esp,%ebp
  807143:	83 ec 38             	sub    $0x38,%esp
  807146:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807149:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80714c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80714f:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  807152:	85 c0                	test   %eax,%eax
  807154:	0f 84 be 01 00 00    	je     807318 <mem_malloc+0x1d8>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80715a:	83 c0 03             	add    $0x3,%eax
  80715d:	83 e0 fc             	and    $0xfffffffc,%eax
  807160:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  807163:	83 f8 0b             	cmp    $0xb,%eax
  807166:	77 09                	ja     807171 <mem_malloc+0x31>
  807168:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  80716f:	eb 0d                	jmp    80717e <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  807171:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  807178:	0f 87 9a 01 00 00    	ja     807318 <mem_malloc+0x1d8>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80717e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807185:	00 
  807186:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  80718b:	89 04 24             	mov    %eax,(%esp)
  80718e:	e8 23 67 00 00       	call   80d8b6 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  807193:	a1 e4 86 a3 00       	mov    0xa386e4,%eax
  807198:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80719b:	8b 15 dc 86 a3 00    	mov    0xa386dc,%edx
  8071a1:	29 d0                	sub    %edx,%eax
  8071a3:	b9 00 00 22 00       	mov    $0x220000,%ecx
  8071a8:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  8071ab:	39 c8                	cmp    %ecx,%eax
  8071ad:	0f 83 51 01 00 00    	jae    807304 <mem_malloc+0x1c4>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  8071b3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  8071b6:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8071b9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8071bc:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8071c0:	0f 85 34 01 00 00    	jne    8072fa <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  8071c6:	8b 3b                	mov    (%ebx),%edi
  8071c8:	83 ef 0c             	sub    $0xc,%edi
  8071cb:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8071cd:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  8071d0:	0f 87 24 01 00 00    	ja     8072fa <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8071d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8071d9:	83 c2 18             	add    $0x18,%edx
  8071dc:	39 d7                	cmp    %edx,%edi
  8071de:	72 2a                	jb     80720a <mem_malloc+0xca>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8071e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8071e3:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8071e7:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  8071ea:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  8071ee:	8b 3b                	mov    (%ebx),%edi
  8071f0:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  8071f2:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8071f5:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  8071f7:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8071fb:	8b 02                	mov    (%edx),%eax
  8071fd:	3d 00 00 22 00       	cmp    $0x220000,%eax
  807202:	74 0a                	je     80720e <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  807204:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  807208:	eb 04                	jmp    80720e <mem_malloc+0xce>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80720a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80720e:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  807211:	75 67                	jne    80727a <mem_malloc+0x13a>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  807213:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807216:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  80721a:	84 c0                	test   %al,%al
  80721c:	74 31                	je     80724f <mem_malloc+0x10f>
  80721e:	8b 15 e0 86 a3 00    	mov    0xa386e0,%edx
  807224:	39 d1                	cmp    %edx,%ecx
  807226:	74 52                	je     80727a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  807228:	8b 01                	mov    (%ecx),%eax
  80722a:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80722d:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  807231:	84 c0                	test   %al,%al
  807233:	75 0b                	jne    807240 <mem_malloc+0x100>
  807235:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  807238:	89 0d e4 86 a3 00    	mov    %ecx,0xa386e4
  80723e:	eb 0f                	jmp    80724f <mem_malloc+0x10f>
  807240:	39 d1                	cmp    %edx,%ecx
  807242:	75 e4                	jne    807228 <mem_malloc+0xe8>
  807244:	89 4d dc             	mov    %ecx,-0x24(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  807247:	89 0d e4 86 a3 00    	mov    %ecx,0xa386e4
  80724d:	eb 2b                	jmp    80727a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80724f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807252:	3b 15 e0 86 a3 00    	cmp    0xa386e0,%edx
  807258:	74 20                	je     80727a <mem_malloc+0x13a>
  80725a:	84 c0                	test   %al,%al
  80725c:	74 1c                	je     80727a <mem_malloc+0x13a>
  80725e:	c7 44 24 08 b5 32 81 	movl   $0x8132b5,0x8(%esp)
  807265:	00 
  807266:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  80726d:	00 
  80726e:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  807275:	e8 02 97 ff ff       	call   80097c <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80727a:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  80727f:	89 04 24             	mov    %eax,(%esp)
  807282:	e8 20 69 00 00       	call   80dba7 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  807287:	89 d8                	mov    %ebx,%eax
  807289:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80728c:	8d 54 0b 0c          	lea    0xc(%ebx,%ecx,1),%edx
  807290:	39 15 e0 86 a3 00    	cmp    %edx,0xa386e0
  807296:	73 1c                	jae    8072b4 <mem_malloc+0x174>
  807298:	c7 44 24 08 58 33 81 	movl   $0x813358,0x8(%esp)
  80729f:	00 
  8072a0:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8072a7:	00 
  8072a8:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8072af:	e8 c8 96 ff ff       	call   80097c <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8072b4:	f6 c3 03             	test   $0x3,%bl
  8072b7:	74 1c                	je     8072d5 <mem_malloc+0x195>
  8072b9:	c7 44 24 08 88 33 81 	movl   $0x813388,0x8(%esp)
  8072c0:	00 
  8072c1:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  8072c8:	00 
  8072c9:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8072d0:	e8 a7 96 ff ff       	call   80097c <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8072d5:	a8 03                	test   $0x3,%al
  8072d7:	74 1c                	je     8072f5 <mem_malloc+0x1b5>
  8072d9:	c7 44 24 08 b8 33 81 	movl   $0x8133b8,0x8(%esp)
  8072e0:	00 
  8072e1:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  8072e8:	00 
  8072e9:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8072f0:	e8 87 96 ff ff       	call   80097c <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  8072f5:	8d 43 0c             	lea    0xc(%ebx),%eax
  8072f8:	eb 23                	jmp    80731d <mem_malloc+0x1dd>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  8072fa:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8072fc:	39 c1                	cmp    %eax,%ecx
  8072fe:	0f 87 b2 fe ff ff    	ja     8071b6 <mem_malloc+0x76>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  807304:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  807309:	89 04 24             	mov    %eax,(%esp)
  80730c:	e8 96 68 00 00       	call   80dba7 <sys_sem_signal>
  807311:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  807316:	eb 05                	jmp    80731d <mem_malloc+0x1dd>
  807318:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80731d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807320:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807323:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807326:	89 ec                	mov    %ebp,%esp
  807328:	5d                   	pop    %ebp
  807329:	c3                   	ret    

0080732a <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80732a:	55                   	push   %ebp
  80732b:	89 e5                	mov    %esp,%ebp
  80732d:	83 ec 18             	sub    $0x18,%esp
  807330:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807333:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  807336:	8b 75 0c             	mov    0xc(%ebp),%esi
  807339:	0f af 75 08          	imul   0x8(%ebp),%esi
  80733d:	89 34 24             	mov    %esi,(%esp)
  807340:	e8 fb fd ff ff       	call   807140 <mem_malloc>
  807345:	89 c3                	mov    %eax,%ebx
  if (p) {
  807347:	85 c0                	test   %eax,%eax
  807349:	74 14                	je     80735f <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  80734b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80734f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807356:	00 
  807357:	89 04 24             	mov    %eax,(%esp)
  80735a:	e8 17 9f ff ff       	call   801276 <memset>
  }
  return p;
}
  80735f:	89 d8                	mov    %ebx,%eax
  807361:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807364:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807367:	89 ec                	mov    %ebp,%esp
  807369:	5d                   	pop    %ebp
  80736a:	c3                   	ret    

0080736b <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80736b:	55                   	push   %ebp
  80736c:	89 e5                	mov    %esp,%ebp
  80736e:	83 ec 38             	sub    $0x38,%esp
  807371:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807374:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807377:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80737a:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80737d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  807380:	83 c3 03             	add    $0x3,%ebx
  807383:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  807386:	83 fb 0b             	cmp    $0xb,%ebx
  807389:	77 07                	ja     807392 <mem_realloc+0x27>
  80738b:	bb 0c 00 00 00       	mov    $0xc,%ebx
  807390:	eb 13                	jmp    8073a5 <mem_realloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  807392:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  807398:	76 0b                	jbe    8073a5 <mem_realloc+0x3a>
  80739a:	be 00 00 00 00       	mov    $0x0,%esi
  80739f:	90                   	nop
  8073a0:	e9 1a 01 00 00       	jmp    8074bf <mem_realloc+0x154>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8073a5:	a1 dc 86 a3 00       	mov    0xa386dc,%eax
  8073aa:	39 c6                	cmp    %eax,%esi
  8073ac:	72 08                	jb     8073b6 <mem_realloc+0x4b>
  8073ae:	3b 35 e0 86 a3 00    	cmp    0xa386e0,%esi
  8073b4:	72 1c                	jb     8073d2 <mem_realloc+0x67>
  8073b6:	c7 44 24 08 e2 32 81 	movl   $0x8132e2,0x8(%esp)
  8073bd:	00 
  8073be:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  8073c5:	00 
  8073c6:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8073cd:	e8 aa 95 ff ff       	call   80097c <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8073d2:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8073d5:	89 fa                	mov    %edi,%edx
  8073d7:	29 c2                	sub    %eax,%edx
  8073d9:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8073dc:	8b 07                	mov    (%edi),%eax
  8073de:	83 e8 0c             	sub    $0xc,%eax
  8073e1:	29 d0                	sub    %edx,%eax
  8073e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8073e6:	39 d8                	cmp    %ebx,%eax
  8073e8:	73 1c                	jae    807406 <mem_realloc+0x9b>
  8073ea:	c7 44 24 08 dc 33 81 	movl   $0x8133dc,0x8(%esp)
  8073f1:	00 
  8073f2:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  8073f9:	00 
  8073fa:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  807401:	e8 76 95 ff ff       	call   80097c <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  807406:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  807409:	0f 84 b0 00 00 00    	je     8074bf <mem_realloc+0x154>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80740f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807416:	00 
  807417:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  80741c:	89 04 24             	mov    %eax,(%esp)
  80741f:	e8 92 64 00 00       	call   80d8b6 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  807424:	a1 dc 86 a3 00       	mov    0xa386dc,%eax
  807429:	89 c2                	mov    %eax,%edx
  80742b:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  80742d:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  807431:	75 41                	jne    807474 <mem_realloc+0x109>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  807433:	8b 0a                	mov    (%edx),%ecx
  807435:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  807438:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80743b:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  80743f:	39 15 e4 86 a3 00    	cmp    %edx,0xa386e4
  807445:	75 09                	jne    807450 <mem_realloc+0xe5>
      lfree = (struct mem *)&ram[ptr2];
  807447:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  80744a:	89 15 e4 86 a3 00    	mov    %edx,0xa386e4
    }
    mem2 = (struct mem *)&ram[ptr2];
  807450:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  807453:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  807457:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80745a:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80745c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80745f:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  807462:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  807464:	8b 12                	mov    (%edx),%edx
  807466:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80746c:	74 44                	je     8074b2 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80746e:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  807472:	eb 3e                	jmp    8074b2 <mem_realloc+0x147>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  807474:	8d 53 18             	lea    0x18(%ebx),%edx
  807477:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80747a:	72 36                	jb     8074b2 <mem_realloc+0x147>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80747c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80747f:	8d 4c 13 0c          	lea    0xc(%ebx,%edx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  807483:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  807486:	3b 15 e4 86 a3 00    	cmp    0xa386e4,%edx
  80748c:	73 06                	jae    807494 <mem_realloc+0x129>
      lfree = mem2;
  80748e:	89 15 e4 86 a3 00    	mov    %edx,0xa386e4
    }
    mem2->used = 0;
  807494:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  807498:	8b 1f                	mov    (%edi),%ebx
  80749a:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  80749c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80749f:	89 5a 04             	mov    %ebx,0x4(%edx)
    mem->next = ptr2;
  8074a2:	89 0f                	mov    %ecx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8074a4:	8b 12                	mov    (%edx),%edx
  8074a6:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8074ac:	74 04                	je     8074b2 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8074ae:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8074b2:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  8074b7:	89 04 24             	mov    %eax,(%esp)
  8074ba:	e8 e8 66 00 00       	call   80dba7 <sys_sem_signal>
  return rmem;
}
  8074bf:	89 f0                	mov    %esi,%eax
  8074c1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8074c4:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8074c7:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8074ca:	89 ec                	mov    %ebp,%esp
  8074cc:	5d                   	pop    %ebp
  8074cd:	c3                   	ret    

008074ce <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  8074ce:	55                   	push   %ebp
  8074cf:	89 e5                	mov    %esp,%ebp
  8074d1:	83 ec 18             	sub    $0x18,%esp
  8074d4:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8074d7:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8074da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  8074dd:	85 db                	test   %ebx,%ebx
  8074df:	0f 84 6f 01 00 00    	je     807654 <mem_free+0x186>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8074e5:	f6 c3 03             	test   $0x3,%bl
  8074e8:	74 1c                	je     807506 <mem_free+0x38>
  8074ea:	c7 44 24 08 00 34 81 	movl   $0x813400,0x8(%esp)
  8074f1:	00 
  8074f2:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  8074f9:	00 
  8074fa:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  807501:	e8 76 94 ff ff       	call   80097c <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  807506:	3b 1d dc 86 a3 00    	cmp    0xa386dc,%ebx
  80750c:	72 08                	jb     807516 <mem_free+0x48>
  80750e:	3b 1d e0 86 a3 00    	cmp    0xa386e0,%ebx
  807514:	72 1c                	jb     807532 <mem_free+0x64>
  807516:	c7 44 24 08 fc 32 81 	movl   $0x8132fc,0x8(%esp)
  80751d:	00 
  80751e:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  807525:	00 
  807526:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  80752d:	e8 4a 94 ff ff       	call   80097c <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  807532:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807539:	00 
  80753a:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  80753f:	89 04 24             	mov    %eax,(%esp)
  807542:	e8 6f 63 00 00       	call   80d8b6 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  807547:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80754a:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  80754e:	75 1c                	jne    80756c <mem_free+0x9e>
  807550:	c7 44 24 08 13 33 81 	movl   $0x813313,0x8(%esp)
  807557:	00 
  807558:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80755f:	00 
  807560:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  807567:	e8 10 94 ff ff       	call   80097c <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  80756c:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  807570:	3b 1d e4 86 a3 00    	cmp    0xa386e4,%ebx
  807576:	73 06                	jae    80757e <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  807578:	89 1d e4 86 a3 00    	mov    %ebx,0xa386e4
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80757e:	a1 dc 86 a3 00       	mov    0xa386dc,%eax
  807583:	39 c3                	cmp    %eax,%ebx
  807585:	73 1c                	jae    8075a3 <mem_free+0xd5>
  807587:	c7 44 24 08 27 33 81 	movl   $0x813327,0x8(%esp)
  80758e:	00 
  80758f:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  807596:	00 
  807597:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  80759e:	e8 d9 93 ff ff       	call   80097c <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  8075a3:	8b 35 e0 86 a3 00    	mov    0xa386e0,%esi
  8075a9:	39 f3                	cmp    %esi,%ebx
  8075ab:	72 1c                	jb     8075c9 <mem_free+0xfb>
  8075ad:	c7 44 24 08 3e 33 81 	movl   $0x81333e,0x8(%esp)
  8075b4:	00 
  8075b5:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  8075bc:	00 
  8075bd:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8075c4:	e8 b3 93 ff ff       	call   80097c <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  8075c9:	8b 13                	mov    (%ebx),%edx
  8075cb:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8075d1:	76 1c                	jbe    8075ef <mem_free+0x121>
  8075d3:	c7 44 24 08 24 34 81 	movl   $0x813424,0x8(%esp)
  8075da:	00 
  8075db:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  8075e2:	00 
  8075e3:	c7 04 24 ce 32 81 00 	movl   $0x8132ce,(%esp)
  8075ea:	e8 8d 93 ff ff       	call   80097c <_panic>

  nmem = (struct mem *)&ram[mem->next];
  8075ef:	89 c1                	mov    %eax,%ecx
  8075f1:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  8075f4:	39 d3                	cmp    %edx,%ebx
  8075f6:	74 26                	je     80761e <mem_free+0x150>
  8075f8:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8075fc:	75 20                	jne    80761e <mem_free+0x150>
  8075fe:	39 d6                	cmp    %edx,%esi
  807600:	74 1c                	je     80761e <mem_free+0x150>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  807602:	3b 15 e4 86 a3 00    	cmp    0xa386e4,%edx
  807608:	75 06                	jne    807610 <mem_free+0x142>
      lfree = mem;
  80760a:	89 1d e4 86 a3 00    	mov    %ebx,0xa386e4
    }
    mem->next = nmem->next;
  807610:	8b 32                	mov    (%edx),%esi
  807612:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  807614:	8b 12                	mov    (%edx),%edx
  807616:	89 de                	mov    %ebx,%esi
  807618:	29 c6                	sub    %eax,%esi
  80761a:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80761e:	89 ca                	mov    %ecx,%edx
  807620:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  807623:	39 d3                	cmp    %edx,%ebx
  807625:	74 20                	je     807647 <mem_free+0x179>
  807627:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80762b:	75 1a                	jne    807647 <mem_free+0x179>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80762d:	3b 1d e4 86 a3 00    	cmp    0xa386e4,%ebx
  807633:	75 06                	jne    80763b <mem_free+0x16d>
      lfree = pmem;
  807635:	89 15 e4 86 a3 00    	mov    %edx,0xa386e4
    }
    pmem->next = mem->next;
  80763b:	8b 33                	mov    (%ebx),%esi
  80763d:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80763f:	8b 1b                	mov    (%ebx),%ebx
  807641:	29 c2                	sub    %eax,%edx
  807643:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  807647:	a1 e8 86 a3 00       	mov    0xa386e8,%eax
  80764c:	89 04 24             	mov    %eax,(%esp)
  80764f:	e8 53 65 00 00       	call   80dba7 <sys_sem_signal>
}
  807654:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807657:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80765a:	89 ec                	mov    %ebp,%esp
  80765c:	5d                   	pop    %ebp
  80765d:	c3                   	ret    

0080765e <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80765e:	55                   	push   %ebp
  80765f:	89 e5                	mov    %esp,%ebp
  807661:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  807664:	b8 c3 86 81 00       	mov    $0x8186c3,%eax
  807669:	83 e0 fc             	and    $0xfffffffc,%eax
  80766c:	a3 dc 86 a3 00       	mov    %eax,0xa386dc
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  807671:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  807677:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  80767e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807682:	05 00 00 22 00       	add    $0x220000,%eax
  807687:	a3 e0 86 a3 00       	mov    %eax,0xa386e0
  ram_end->used = 1;
  80768c:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  807690:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  807696:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  80769d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8076a4:	e8 5c 63 00 00       	call   80da05 <sys_sem_new>
  8076a9:	a3 e8 86 a3 00       	mov    %eax,0xa386e8

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8076ae:	a1 dc 86 a3 00       	mov    0xa386dc,%eax
  8076b3:	a3 e4 86 a3 00       	mov    %eax,0xa386e4

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  8076b8:	c9                   	leave  
  8076b9:	c3                   	ret    
	...

008076bc <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8076bc:	55                   	push   %ebp
  8076bd:	89 e5                	mov    %esp,%ebp
  8076bf:	57                   	push   %edi
  8076c0:	56                   	push   %esi
  8076c1:	53                   	push   %ebx
  8076c2:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8076c5:	b8 43 87 a3 00       	mov    $0xa38743,%eax
  8076ca:	83 e0 fc             	and    $0xfffffffc,%eax
  8076cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8076d0:	bf 00 00 00 00       	mov    $0x0,%edi
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  8076d5:	c7 84 3f 00 87 a3 00 	movl   $0x0,0xa38700(%edi,%edi,1)
  8076dc:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8076e0:	0f b7 9f e2 34 81 00 	movzwl 0x8134e2(%edi),%ebx
  8076e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8076ea:	66 85 db             	test   %bx,%bx
  8076ed:	74 3c                	je     80772b <memp_init+0x6f>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8076ef:	0f b7 b7 c6 34 81 00 	movzwl 0x8134c6(%edi),%esi
  8076f6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8076fb:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  807700:	89 08                	mov    %ecx,(%eax)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807702:	83 c2 01             	add    $0x1,%edx
  807705:	89 c1                	mov    %eax,%ecx
  807707:	8d 04 30             	lea    (%eax,%esi,1),%eax
  80770a:	66 39 da             	cmp    %bx,%dx
  80770d:	72 f1                	jb     807700 <memp_init+0x44>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
  80770f:	83 eb 01             	sub    $0x1,%ebx
  807712:	0f b7 db             	movzwl %bx,%ebx
  807715:	8d 43 01             	lea    0x1(%ebx),%eax
  807718:	0f af c6             	imul   %esi,%eax
  80771b:	03 45 f0             	add    -0x10(%ebp),%eax
  80771e:	0f af de             	imul   %esi,%ebx
  807721:	03 5d f0             	add    -0x10(%ebp),%ebx
  807724:	89 9c 3f 00 87 a3 00 	mov    %ebx,0xa38700(%edi,%edi,1)
  80772b:	83 c7 02             	add    $0x2,%edi
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80772e:	83 ff 1c             	cmp    $0x1c,%edi
  807731:	74 05                	je     807738 <memp_init+0x7c>
  807733:	89 45 f0             	mov    %eax,-0x10(%ebp)
  807736:	eb 9d                	jmp    8076d5 <memp_init+0x19>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  807738:	83 c4 04             	add    $0x4,%esp
  80773b:	5b                   	pop    %ebx
  80773c:	5e                   	pop    %esi
  80773d:	5f                   	pop    %edi
  80773e:	5d                   	pop    %ebp
  80773f:	c3                   	ret    

00807740 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  807740:	55                   	push   %ebp
  807741:	89 e5                	mov    %esp,%ebp
  807743:	53                   	push   %ebx
  807744:	83 ec 14             	sub    $0x14,%esp
  807747:	8b 55 08             	mov    0x8(%ebp),%edx
  80774a:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80774d:	85 c0                	test   %eax,%eax
  80774f:	74 2d                	je     80777e <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  807751:	a8 03                	test   $0x3,%al
  807753:	74 1c                	je     807771 <memp_free+0x31>
  807755:	c7 44 24 08 50 34 81 	movl   $0x813450,0x8(%esp)
  80775c:	00 
  80775d:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  807764:	00 
  807765:	c7 04 24 93 34 81 00 	movl   $0x813493,(%esp)
  80776c:	e8 0b 92 ff ff       	call   80097c <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  807771:	b9 00 87 a3 00       	mov    $0xa38700,%ecx
  807776:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  807779:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  80777b:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80777e:	83 c4 14             	add    $0x14,%esp
  807781:	5b                   	pop    %ebx
  807782:	5d                   	pop    %ebp
  807783:	c3                   	ret    

00807784 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807784:	55                   	push   %ebp
  807785:	89 e5                	mov    %esp,%ebp
  807787:	83 ec 18             	sub    $0x18,%esp
  80778a:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80778d:	83 fa 0d             	cmp    $0xd,%edx
  807790:	76 1c                	jbe    8077ae <memp_malloc+0x2a>
  807792:	c7 44 24 08 a8 34 81 	movl   $0x8134a8,0x8(%esp)
  807799:	00 
  80779a:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  8077a1:	00 
  8077a2:	c7 04 24 93 34 81 00 	movl   $0x813493,(%esp)
  8077a9:	e8 ce 91 ff ff       	call   80097c <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8077ae:	8b 04 95 00 87 a3 00 	mov    0xa38700(,%edx,4),%eax
  
  if (memp != NULL) {    
  8077b5:	85 c0                	test   %eax,%eax
  8077b7:	74 29                	je     8077e2 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  8077b9:	8b 08                	mov    (%eax),%ecx
  8077bb:	89 0c 95 00 87 a3 00 	mov    %ecx,0xa38700(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8077c2:	a8 03                	test   $0x3,%al
  8077c4:	74 1c                	je     8077e2 <memp_malloc+0x5e>
  8077c6:	c7 44 24 08 70 34 81 	movl   $0x813470,0x8(%esp)
  8077cd:	00 
  8077ce:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  8077d5:	00 
  8077d6:	c7 04 24 93 34 81 00 	movl   $0x813493,(%esp)
  8077dd:	e8 9a 91 ff ff       	call   80097c <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8077e2:	c9                   	leave  
  8077e3:	c3                   	ret    
	...

008077f0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  8077f0:	55                   	push   %ebp
  8077f1:	89 e5                	mov    %esp,%ebp
  8077f3:	53                   	push   %ebx
  8077f4:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  8077f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8077fc:	85 d2                	test   %edx,%edx
  8077fe:	74 2c                	je     80782c <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  807800:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  807804:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  807807:	a1 00 e6 b3 00       	mov    0xb3e600,%eax
  80780c:	85 c0                	test   %eax,%eax
  80780e:	74 1c                	je     80782c <netif_find+0x3c>
    if (num == netif->num &&
  807810:	38 58 31             	cmp    %bl,0x31(%eax)
  807813:	75 11                	jne    807826 <netif_find+0x36>
       name[0] == netif->name[0] &&
  807815:	0f b6 0a             	movzbl (%edx),%ecx
  807818:	3a 48 2f             	cmp    0x2f(%eax),%cl
  80781b:	75 09                	jne    807826 <netif_find+0x36>
       name[1] == netif->name[1]) {
  80781d:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  807821:	3a 48 30             	cmp    0x30(%eax),%cl
  807824:	74 06                	je     80782c <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  807826:	8b 00                	mov    (%eax),%eax
  807828:	85 c0                	test   %eax,%eax
  80782a:	75 e4                	jne    807810 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  80782c:	5b                   	pop    %ebx
  80782d:	5d                   	pop    %ebp
  80782e:	c3                   	ret    

0080782f <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80782f:	55                   	push   %ebp
  807830:	89 e5                	mov    %esp,%ebp
  807832:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  807835:	b8 00 00 00 00       	mov    $0x0,%eax
  80783a:	85 d2                	test   %edx,%edx
  80783c:	74 02                	je     807840 <netif_set_gw+0x11>
  80783e:	8b 02                	mov    (%edx),%eax
  807840:	8b 55 08             	mov    0x8(%ebp),%edx
  807843:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  807846:	5d                   	pop    %ebp
  807847:	c3                   	ret    

00807848 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  807848:	55                   	push   %ebp
  807849:	89 e5                	mov    %esp,%ebp
  80784b:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80784e:	b8 00 00 00 00       	mov    $0x0,%eax
  807853:	85 d2                	test   %edx,%edx
  807855:	74 02                	je     807859 <netif_set_netmask+0x11>
  807857:	8b 02                	mov    (%edx),%eax
  807859:	8b 55 08             	mov    0x8(%ebp),%edx
  80785c:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80785f:	5d                   	pop    %ebp
  807860:	c3                   	ret    

00807861 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  807861:	55                   	push   %ebp
  807862:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  807864:	8b 45 08             	mov    0x8(%ebp),%eax
  807867:	a3 04 e6 b3 00       	mov    %eax,0xb3e604
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80786c:	5d                   	pop    %ebp
  80786d:	c3                   	ret    

0080786e <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80786e:	55                   	push   %ebp
  80786f:	89 e5                	mov    %esp,%ebp
  807871:	83 ec 04             	sub    $0x4,%esp
  807874:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  807877:	85 c9                	test   %ecx,%ecx
  807879:	74 4b                	je     8078c6 <netif_remove+0x58>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80787b:	a1 00 e6 b3 00       	mov    0xb3e600,%eax
  807880:	39 c8                	cmp    %ecx,%eax
  807882:	75 1e                	jne    8078a2 <netif_remove+0x34>
    netif_list = netif->next;
  807884:	8b 00                	mov    (%eax),%eax
  807886:	a3 00 e6 b3 00       	mov    %eax,0xb3e600
  80788b:	eb 25                	jmp    8078b2 <netif_remove+0x44>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80788d:	8b 10                	mov    (%eax),%edx
  80788f:	39 ca                	cmp    %ecx,%edx
  807891:	74 08                	je     80789b <netif_remove+0x2d>
  807893:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807895:	85 c0                	test   %eax,%eax
  807897:	75 f4                	jne    80788d <netif_remove+0x1f>
  807899:	eb 2b                	jmp    8078c6 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  80789b:	8b 11                	mov    (%ecx),%edx
  80789d:	89 10                	mov    %edx,(%eax)
  80789f:	90                   	nop
  8078a0:	eb 10                	jmp    8078b2 <netif_remove+0x44>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8078a2:	85 c0                	test   %eax,%eax
  8078a4:	74 20                	je     8078c6 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
  8078a6:	8b 10                	mov    (%eax),%edx
  8078a8:	39 ca                	cmp    %ecx,%edx
  8078aa:	74 ef                	je     80789b <netif_remove+0x2d>
  8078ac:	89 d0                	mov    %edx,%eax
  8078ae:	66 90                	xchg   %ax,%ax
  8078b0:	eb e3                	jmp    807895 <netif_remove+0x27>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  8078b2:	39 0d 04 e6 b3 00    	cmp    %ecx,0xb3e604
  8078b8:	75 0c                	jne    8078c6 <netif_remove+0x58>
    /* reset default netif */
    netif_set_default(NULL);
  8078ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8078c1:	e8 9b ff ff ff       	call   807861 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  8078c6:	c9                   	leave  
  8078c7:	c3                   	ret    

008078c8 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  8078c8:	55                   	push   %ebp
  8078c9:	89 e5                	mov    %esp,%ebp
  8078cb:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  8078ce:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8078d2:	f6 c2 01             	test   $0x1,%dl
  8078d5:	74 06                	je     8078dd <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  8078d7:	83 e2 fe             	and    $0xfffffffe,%edx
  8078da:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  8078dd:	5d                   	pop    %ebp
  8078de:	c3                   	ret    

008078df <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  8078df:	55                   	push   %ebp
  8078e0:	89 e5                	mov    %esp,%ebp
  8078e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8078e5:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  8078e9:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  8078ec:	5d                   	pop    %ebp
  8078ed:	c3                   	ret    

008078ee <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8078ee:	55                   	push   %ebp
  8078ef:	89 e5                	mov    %esp,%ebp
  8078f1:	83 ec 18             	sub    $0x18,%esp
  8078f4:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8078f7:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8078fb:	f6 c2 01             	test   $0x1,%dl
  8078fe:	75 22                	jne    807922 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  807900:	83 ca 01             	or     $0x1,%edx
  807903:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  807906:	f6 c2 20             	test   $0x20,%dl
  807909:	74 17                	je     807922 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80790b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  807912:	00 
  807913:	8d 50 04             	lea    0x4(%eax),%edx
  807916:	89 54 24 04          	mov    %edx,0x4(%esp)
  80791a:	89 04 24             	mov    %eax,(%esp)
  80791d:	e8 75 53 00 00       	call   80cc97 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  807922:	c9                   	leave  
  807923:	c3                   	ret    

00807924 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  807924:	55                   	push   %ebp
  807925:	89 e5                	mov    %esp,%ebp
  807927:	57                   	push   %edi
  807928:	56                   	push   %esi
  807929:	53                   	push   %ebx
  80792a:	83 ec 1c             	sub    $0x1c,%esp
  80792d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807930:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  807933:	8b 06                	mov    (%esi),%eax
  807935:	3b 43 04             	cmp    0x4(%ebx),%eax
  807938:	74 54                	je     80798e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80793a:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
    while (pcb != NULL) {
  80793f:	85 c0                	test   %eax,%eax
  807941:	74 1d                	je     807960 <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  807943:	8b 10                	mov    (%eax),%edx
  807945:	3b 53 04             	cmp    0x4(%ebx),%edx
  807948:	75 0f                	jne    807959 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80794a:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80794d:	89 04 24             	mov    %eax,(%esp)
  807950:	e8 a9 16 00 00       	call   808ffe <tcp_abort>
  807955:	89 f8                	mov    %edi,%eax
  807957:	eb 03                	jmp    80795c <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
  807959:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80795c:	85 c0                	test   %eax,%eax
  80795e:	75 e3                	jne    807943 <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807960:	a1 10 e6 b3 00       	mov    0xb3e610,%eax
  807965:	85 c0                	test   %eax,%eax
  807967:	74 25                	je     80798e <netif_set_ipaddr+0x6a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  807969:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80796e:	85 c0                	test   %eax,%eax
  807970:	74 15                	je     807987 <netif_set_ipaddr+0x63>
  807972:	8b 10                	mov    (%eax),%edx
  807974:	85 d2                	test   %edx,%edx
  807976:	74 0f                	je     807987 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  807978:	3b 53 04             	cmp    0x4(%ebx),%edx
  80797b:	75 0a                	jne    807987 <netif_set_ipaddr+0x63>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80797d:	89 ca                	mov    %ecx,%edx
  80797f:	85 f6                	test   %esi,%esi
  807981:	74 02                	je     807985 <netif_set_ipaddr+0x61>
  807983:	8b 16                	mov    (%esi),%edx
  807985:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807987:	8b 40 0c             	mov    0xc(%eax),%eax
  80798a:	85 c0                	test   %eax,%eax
  80798c:	75 e0                	jne    80796e <netif_set_ipaddr+0x4a>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80798e:	b8 00 00 00 00       	mov    $0x0,%eax
  807993:	85 f6                	test   %esi,%esi
  807995:	74 02                	je     807999 <netif_set_ipaddr+0x75>
  807997:	8b 06                	mov    (%esi),%eax
  807999:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80799c:	83 c4 1c             	add    $0x1c,%esp
  80799f:	5b                   	pop    %ebx
  8079a0:	5e                   	pop    %esi
  8079a1:	5f                   	pop    %edi
  8079a2:	5d                   	pop    %ebp
  8079a3:	c3                   	ret    

008079a4 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8079a4:	55                   	push   %ebp
  8079a5:	89 e5                	mov    %esp,%ebp
  8079a7:	53                   	push   %ebx
  8079a8:	83 ec 14             	sub    $0x14,%esp
  8079ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  8079ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  8079b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8079b5:	89 1c 24             	mov    %ebx,(%esp)
  8079b8:	e8 67 ff ff ff       	call   807924 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  8079bd:	8b 45 10             	mov    0x10(%ebp),%eax
  8079c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8079c4:	89 1c 24             	mov    %ebx,(%esp)
  8079c7:	e8 7c fe ff ff       	call   807848 <netif_set_netmask>
  netif_set_gw(netif, gw);
  8079cc:	8b 45 14             	mov    0x14(%ebp),%eax
  8079cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8079d3:	89 1c 24             	mov    %ebx,(%esp)
  8079d6:	e8 54 fe ff ff       	call   80782f <netif_set_gw>
}
  8079db:	83 c4 14             	add    $0x14,%esp
  8079de:	5b                   	pop    %ebx
  8079df:	5d                   	pop    %ebp
  8079e0:	c3                   	ret    

008079e1 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  8079e1:	55                   	push   %ebp
  8079e2:	89 e5                	mov    %esp,%ebp
  8079e4:	53                   	push   %ebx
  8079e5:	83 ec 14             	sub    $0x14,%esp
  8079e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  8079eb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  8079f2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  8079f9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  807a00:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  807a04:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  807a0b:	8b 45 18             	mov    0x18(%ebp),%eax
  807a0e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  807a11:	0f b6 05 a4 77 b3 00 	movzbl 0xb377a4,%eax
  807a18:	88 43 31             	mov    %al,0x31(%ebx)
  807a1b:	83 c0 01             	add    $0x1,%eax
  807a1e:	a2 a4 77 b3 00       	mov    %al,0xb377a4
  netif->input = input;
  807a23:	8b 45 20             	mov    0x20(%ebp),%eax
  807a26:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  807a29:	8b 45 14             	mov    0x14(%ebp),%eax
  807a2c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  807a30:	8b 45 10             	mov    0x10(%ebp),%eax
  807a33:	89 44 24 08          	mov    %eax,0x8(%esp)
  807a37:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a3e:	89 1c 24             	mov    %ebx,(%esp)
  807a41:	e8 5e ff ff ff       	call   8079a4 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  807a46:	89 1c 24             	mov    %ebx,(%esp)
  807a49:	ff 55 1c             	call   *0x1c(%ebp)
  807a4c:	84 c0                	test   %al,%al
  807a4e:	74 07                	je     807a57 <netif_add+0x76>
  807a50:	bb 00 00 00 00       	mov    $0x0,%ebx
  807a55:	eb 0d                	jmp    807a64 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807a57:	a1 00 e6 b3 00       	mov    0xb3e600,%eax
  807a5c:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  807a5e:	89 1d 00 e6 b3 00    	mov    %ebx,0xb3e600
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807a64:	89 d8                	mov    %ebx,%eax
  807a66:	83 c4 14             	add    $0x14,%esp
  807a69:	5b                   	pop    %ebx
  807a6a:	5d                   	pop    %ebp
  807a6b:	c3                   	ret    
  807a6c:	00 00                	add    %al,(%eax)
	...

00807a70 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807a70:	55                   	push   %ebp
  807a71:	89 e5                	mov    %esp,%ebp
  807a73:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807a76:	b8 00 00 00 00       	mov    $0x0,%eax
  807a7b:	85 d2                	test   %edx,%edx
  807a7d:	74 09                	je     807a88 <pbuf_clen+0x18>
    ++len;
  807a7f:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807a82:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807a84:	85 d2                	test   %edx,%edx
  807a86:	75 f7                	jne    807a7f <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  807a88:	5d                   	pop    %ebp
  807a89:	c3                   	ret    

00807a8a <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  807a8a:	55                   	push   %ebp
  807a8b:	89 e5                	mov    %esp,%ebp
  807a8d:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807a90:	85 c0                	test   %eax,%eax
  807a92:	74 05                	je     807a99 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807a94:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807a99:	5d                   	pop    %ebp
  807a9a:	c3                   	ret    

00807a9b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  807a9b:	55                   	push   %ebp
  807a9c:	89 e5                	mov    %esp,%ebp
  807a9e:	53                   	push   %ebx
  807a9f:	83 ec 14             	sub    $0x14,%esp
  807aa2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807aa5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807aa8:	85 db                	test   %ebx,%ebx
  807aaa:	74 0e                	je     807aba <pbuf_cat+0x1f>
  807aac:	85 c9                	test   %ecx,%ecx
  807aae:	74 0a                	je     807aba <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807ab0:	8b 13                	mov    (%ebx),%edx
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807ab2:	89 d8                	mov    %ebx,%eax
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807ab4:	85 d2                	test   %edx,%edx
  807ab6:	75 1e                	jne    807ad6 <pbuf_cat+0x3b>
  807ab8:	eb 2c                	jmp    807ae6 <pbuf_cat+0x4b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807aba:	c7 44 24 08 00 35 81 	movl   $0x813500,0x8(%esp)
  807ac1:	00 
  807ac2:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807ac9:	00 
  807aca:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807ad1:	e8 a6 8e ff ff       	call   80097c <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807ad6:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  807ada:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807ade:	8b 00                	mov    (%eax),%eax
  807ae0:	8b 10                	mov    (%eax),%edx
  807ae2:	85 d2                	test   %edx,%edx
  807ae4:	75 f0                	jne    807ad6 <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  807ae6:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  807aea:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  807aee:	74 1c                	je     807b0c <pbuf_cat+0x71>
  807af0:	c7 44 24 08 38 35 81 	movl   $0x813538,0x8(%esp)
  807af7:	00 
  807af8:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  807aff:	00 
  807b00:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807b07:	e8 70 8e ff ff       	call   80097c <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  807b0c:	85 d2                	test   %edx,%edx
  807b0e:	74 1c                	je     807b2c <pbuf_cat+0x91>
  807b10:	c7 44 24 08 aa 36 81 	movl   $0x8136aa,0x8(%esp)
  807b17:	00 
  807b18:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  807b1f:	00 
  807b20:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807b27:	e8 50 8e ff ff       	call   80097c <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  807b2c:	66 03 59 08          	add    0x8(%ecx),%bx
  807b30:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  807b34:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  807b36:	83 c4 14             	add    $0x14,%esp
  807b39:	5b                   	pop    %ebx
  807b3a:	5d                   	pop    %ebp
  807b3b:	c3                   	ret    

00807b3c <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  807b3c:	55                   	push   %ebp
  807b3d:	89 e5                	mov    %esp,%ebp
  807b3f:	53                   	push   %ebx
  807b40:	83 ec 14             	sub    $0x14,%esp
  807b43:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  807b46:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807b4a:	8b 45 08             	mov    0x8(%ebp),%eax
  807b4d:	89 04 24             	mov    %eax,(%esp)
  807b50:	e8 46 ff ff ff       	call   807a9b <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807b55:	89 1c 24             	mov    %ebx,(%esp)
  807b58:	e8 2d ff ff ff       	call   807a8a <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  807b5d:	83 c4 14             	add    $0x14,%esp
  807b60:	5b                   	pop    %ebx
  807b61:	5d                   	pop    %ebp
  807b62:	c3                   	ret    

00807b63 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807b63:	55                   	push   %ebp
  807b64:	89 e5                	mov    %esp,%ebp
  807b66:	83 ec 18             	sub    $0x18,%esp
  807b69:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807b6c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  807b6f:	8b 55 08             	mov    0x8(%ebp),%edx
  807b72:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807b76:	85 d2                	test   %edx,%edx
  807b78:	75 1c                	jne    807b96 <pbuf_header+0x33>
  807b7a:	c7 44 24 08 73 37 81 	movl   $0x813773,0x8(%esp)
  807b81:	00 
  807b82:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  807b89:	00 
  807b8a:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807b91:	e8 e6 8d ff ff       	call   80097c <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807b96:	b8 00 00 00 00       	mov    $0x0,%eax
  807b9b:	66 85 c9             	test   %cx,%cx
  807b9e:	0f 84 a8 00 00 00    	je     807c4c <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807ba4:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807ba6:	66 85 c9             	test   %cx,%cx
  807ba9:	79 24                	jns    807bcf <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  807bab:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  807bad:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807bb1:	76 1c                	jbe    807bcf <pbuf_header+0x6c>
  807bb3:	c7 44 24 08 ba 36 81 	movl   $0x8136ba,0x8(%esp)
  807bba:	00 
  807bbb:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807bc2:	00 
  807bc3:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807bca:	e8 ad 8d ff ff       	call   80097c <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  807bcf:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807bd3:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807bd6:	66 85 c0             	test   %ax,%ax
  807bd9:	74 06                	je     807be1 <pbuf_header+0x7e>
  807bdb:	66 83 f8 03          	cmp    $0x3,%ax
  807bdf:	75 1d                	jne    807bfe <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  807be1:	0f bf c1             	movswl %cx,%eax
  807be4:	89 de                	mov    %ebx,%esi
  807be6:	29 c6                	sub    %eax,%esi
  807be8:	89 f0                	mov    %esi,%eax
  807bea:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  807bed:	8d 72 10             	lea    0x10(%edx),%esi
  807bf0:	39 f0                	cmp    %esi,%eax
  807bf2:	73 44                	jae    807c38 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  807bf4:	89 5a 04             	mov    %ebx,0x4(%edx)
  807bf7:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  807bfc:	eb 4e                	jmp    807c4c <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  807bfe:	83 e8 01             	sub    $0x1,%eax
  807c01:	66 83 f8 01          	cmp    $0x1,%ax
  807c05:	77 15                	ja     807c1c <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  807c07:	66 85 c9             	test   %cx,%cx
  807c0a:	79 3b                	jns    807c47 <pbuf_header+0xe4>
  807c0c:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807c10:	77 35                	ja     807c47 <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  807c12:	0f bf c1             	movswl %cx,%eax
  807c15:	29 c3                	sub    %eax,%ebx
  807c17:	89 5a 04             	mov    %ebx,0x4(%edx)
  807c1a:	eb 1c                	jmp    807c38 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  807c1c:	c7 44 24 08 d8 36 81 	movl   $0x8136d8,0x8(%esp)
  807c23:	00 
  807c24:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  807c2b:	00 
  807c2c:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807c33:	e8 44 8d ff ff       	call   80097c <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  807c38:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  807c3c:	66 01 4a 08          	add    %cx,0x8(%edx)
  807c40:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  807c45:	eb 05                	jmp    807c4c <pbuf_header+0xe9>
  807c47:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807c4c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807c4f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807c52:	89 ec                	mov    %ebp,%esp
  807c54:	5d                   	pop    %ebp
  807c55:	c3                   	ret    

00807c56 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807c56:	55                   	push   %ebp
  807c57:	89 e5                	mov    %esp,%ebp
  807c59:	57                   	push   %edi
  807c5a:	56                   	push   %esi
  807c5b:	53                   	push   %ebx
  807c5c:	83 ec 2c             	sub    $0x2c,%esp
  807c5f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807c62:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  807c66:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  807c6a:	85 db                	test   %ebx,%ebx
  807c6c:	75 1c                	jne    807c8a <pbuf_copy_partial+0x34>
  807c6e:	c7 44 24 08 68 35 81 	movl   $0x813568,0x8(%esp)
  807c75:	00 
  807c76:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  807c7d:	00 
  807c7e:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807c85:	e8 f2 8c ff ff       	call   80097c <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  807c8a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807c8e:	75 1c                	jne    807cac <pbuf_copy_partial+0x56>
  807c90:	c7 44 24 08 8c 35 81 	movl   $0x81358c,0x8(%esp)
  807c97:	00 
  807c98:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  807c9f:	00 
  807ca0:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807ca7:	e8 d0 8c ff ff       	call   80097c <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807cac:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  807cb2:	66 85 ff             	test   %di,%di
  807cb5:	74 62                	je     807d19 <pbuf_copy_partial+0xc3>
  807cb7:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  807cbd:	66 85 c0             	test   %ax,%ax
  807cc0:	74 0e                	je     807cd0 <pbuf_copy_partial+0x7a>
  807cc2:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807cc6:	66 39 c2             	cmp    %ax,%dx
  807cc9:	77 05                	ja     807cd0 <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  807ccb:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  807cce:	eb 3e                	jmp    807d0e <pbuf_copy_partial+0xb8>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807cd0:	0f b7 73 0a          	movzwl 0xa(%ebx),%esi
  807cd4:	66 29 c6             	sub    %ax,%si
  807cd7:	66 39 fe             	cmp    %di,%si
  807cda:	76 02                	jbe    807cde <pbuf_copy_partial+0x88>
  807cdc:	89 fe                	mov    %edi,%esi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  807cde:	0f b7 d6             	movzwl %si,%edx
  807ce1:	89 54 24 08          	mov    %edx,0x8(%esp)
  807ce5:	0f b7 c0             	movzwl %ax,%eax
  807ce8:	03 43 04             	add    0x4(%ebx),%eax
  807ceb:	89 44 24 04          	mov    %eax,0x4(%esp)
  807cef:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807cf3:	03 45 0c             	add    0xc(%ebp),%eax
  807cf6:	89 04 24             	mov    %eax,(%esp)
  807cf9:	e8 53 96 ff ff       	call   801351 <memcpy>
      copied_total += buf_copy_len;
  807cfe:	66 01 75 e4          	add    %si,-0x1c(%ebp)
      left += buf_copy_len;
  807d02:	66 01 75 e6          	add    %si,-0x1a(%ebp)
      len -= buf_copy_len;
  807d06:	66 29 f7             	sub    %si,%di
  807d09:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807d0e:	8b 1b                	mov    (%ebx),%ebx
  807d10:	66 85 ff             	test   %di,%di
  807d13:	74 04                	je     807d19 <pbuf_copy_partial+0xc3>
  807d15:	85 db                	test   %ebx,%ebx
  807d17:	75 a4                	jne    807cbd <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  807d19:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807d1d:	83 c4 2c             	add    $0x2c,%esp
  807d20:	5b                   	pop    %ebx
  807d21:	5e                   	pop    %esi
  807d22:	5f                   	pop    %edi
  807d23:	5d                   	pop    %ebp
  807d24:	c3                   	ret    

00807d25 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  807d25:	55                   	push   %ebp
  807d26:	89 e5                	mov    %esp,%ebp
  807d28:	57                   	push   %edi
  807d29:	56                   	push   %esi
  807d2a:	53                   	push   %ebx
  807d2b:	83 ec 2c             	sub    $0x2c,%esp
  807d2e:	8b 75 08             	mov    0x8(%ebp),%esi
  807d31:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  807d34:	85 f6                	test   %esi,%esi
  807d36:	0f 94 c0             	sete   %al
  807d39:	74 0e                	je     807d49 <pbuf_copy+0x24>
  807d3b:	85 db                	test   %ebx,%ebx
  807d3d:	74 0a                	je     807d49 <pbuf_copy+0x24>
  807d3f:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  807d43:	66 3b 53 08          	cmp    0x8(%ebx),%dx
  807d47:	73 1c                	jae    807d65 <pbuf_copy+0x40>
  807d49:	c7 44 24 08 b4 35 81 	movl   $0x8135b4,0x8(%esp)
  807d50:	00 
  807d51:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  807d58:	00 
  807d59:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807d60:	e8 17 8c ff ff       	call   80097c <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807d65:	84 c0                	test   %al,%al
  807d67:	74 25                	je     807d8e <pbuf_copy+0x69>
  807d69:	eb 07                	jmp    807d72 <pbuf_copy+0x4d>
  807d6b:	85 f6                	test   %esi,%esi
  807d6d:	8d 76 00             	lea    0x0(%esi),%esi
  807d70:	75 27                	jne    807d99 <pbuf_copy+0x74>
  807d72:	c7 44 24 08 e6 36 81 	movl   $0x8136e6,0x8(%esp)
  807d79:	00 
  807d7a:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807d81:	00 
  807d82:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807d89:	e8 ee 8b ff ff       	call   80097c <_panic>
  807d8e:	bf 00 00 00 00       	mov    $0x0,%edi
  807d93:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807d99:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807d9d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  807da1:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  807da5:	0f b7 d0             	movzwl %ax,%edx
  807da8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807dac:	29 c2                	sub    %eax,%edx
  807dae:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807db1:	0f b7 d1             	movzwl %cx,%edx
  807db4:	0f b7 c7             	movzwl %di,%eax
  807db7:	29 c2                	sub    %eax,%edx
  807db9:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807dbc:	7c 09                	jl     807dc7 <pbuf_copy+0xa2>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807dbe:	66 29 f9             	sub    %di,%cx
  807dc1:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  807dc5:	eb 0c                	jmp    807dd3 <pbuf_copy+0xae>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  807dc7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807dcb:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  807dcf:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807dd3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807dd7:	89 44 24 08          	mov    %eax,0x8(%esp)
  807ddb:	0f b7 c7             	movzwl %di,%eax
  807dde:	03 43 04             	add    0x4(%ebx),%eax
  807de1:	89 44 24 04          	mov    %eax,0x4(%esp)
  807de5:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807de9:	03 46 04             	add    0x4(%esi),%eax
  807dec:	89 04 24             	mov    %eax,(%esp)
  807def:	e8 5d 95 ff ff       	call   801351 <memcpy>
    offset_to += len;
  807df4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807df8:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  807dfc:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e00:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807e04:	76 1c                	jbe    807e22 <pbuf_copy+0xfd>
  807e06:	c7 44 24 08 f3 36 81 	movl   $0x8136f3,0x8(%esp)
  807e0d:	00 
  807e0e:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  807e15:	00 
  807e16:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807e1d:	e8 5a 8b ff ff       	call   80097c <_panic>
    if (offset_to == p_to->len) {
  807e22:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807e26:	75 08                	jne    807e30 <pbuf_copy+0x10b>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  807e28:	8b 36                	mov    (%esi),%esi
  807e2a:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  807e30:	66 03 7d e4          	add    -0x1c(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  807e34:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807e38:	66 39 c7             	cmp    %ax,%di
  807e3b:	76 1c                	jbe    807e59 <pbuf_copy+0x134>
  807e3d:	c7 44 24 08 0a 37 81 	movl   $0x81370a,0x8(%esp)
  807e44:	00 
  807e45:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  807e4c:	00 
  807e4d:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807e54:	e8 23 8b ff ff       	call   80097c <_panic>
    if (offset_from >= p_from->len) {
  807e59:	66 39 c7             	cmp    %ax,%di
  807e5c:	72 07                	jb     807e65 <pbuf_copy+0x140>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  807e5e:	8b 1b                	mov    (%ebx),%ebx
  807e60:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  807e65:	85 db                	test   %ebx,%ebx
  807e67:	74 2b                	je     807e94 <pbuf_copy+0x16f>
  807e69:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807e6d:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  807e71:	75 21                	jne    807e94 <pbuf_copy+0x16f>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807e73:	83 3b 00             	cmpl   $0x0,(%ebx)
  807e76:	74 1c                	je     807e94 <pbuf_copy+0x16f>
  807e78:	c7 44 24 08 e4 35 81 	movl   $0x8135e4,0x8(%esp)
  807e7f:	00 
  807e80:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  807e87:	00 
  807e88:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807e8f:	e8 e8 8a ff ff       	call   80097c <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807e94:	85 f6                	test   %esi,%esi
  807e96:	74 2b                	je     807ec3 <pbuf_copy+0x19e>
  807e98:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e9c:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807ea0:	75 21                	jne    807ec3 <pbuf_copy+0x19e>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807ea2:	83 3e 00             	cmpl   $0x0,(%esi)
  807ea5:	74 1c                	je     807ec3 <pbuf_copy+0x19e>
  807ea7:	c7 44 24 08 e4 35 81 	movl   $0x8135e4,0x8(%esp)
  807eae:	00 
  807eaf:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  807eb6:	00 
  807eb7:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807ebe:	e8 b9 8a ff ff       	call   80097c <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807ec3:	85 db                	test   %ebx,%ebx
  807ec5:	0f 85 a0 fe ff ff    	jne    807d6b <pbuf_copy+0x46>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807ecb:	b8 00 00 00 00       	mov    $0x0,%eax
  807ed0:	83 c4 2c             	add    $0x2c,%esp
  807ed3:	5b                   	pop    %ebx
  807ed4:	5e                   	pop    %esi
  807ed5:	5f                   	pop    %edi
  807ed6:	5d                   	pop    %ebp
  807ed7:	c3                   	ret    

00807ed8 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  807ed8:	55                   	push   %ebp
  807ed9:	89 e5                	mov    %esp,%ebp
  807edb:	56                   	push   %esi
  807edc:	53                   	push   %ebx
  807edd:	83 ec 10             	sub    $0x10,%esp
  807ee0:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807ee3:	85 c0                	test   %eax,%eax
  807ee5:	75 1c                	jne    807f03 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  807ee7:	c7 44 24 08 73 37 81 	movl   $0x813773,0x8(%esp)
  807eee:	00 
  807eef:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  807ef6:	00 
  807ef7:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807efe:	e8 79 8a ff ff       	call   80097c <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  807f03:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  807f07:	77 0a                	ja     807f13 <pbuf_free+0x3b>
  807f09:	be 00 00 00 00       	mov    $0x0,%esi
  807f0e:	e9 82 00 00 00       	jmp    807f95 <pbuf_free+0xbd>
  807f13:	c7 44 24 08 25 37 81 	movl   $0x813725,0x8(%esp)
  807f1a:	00 
  807f1b:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  807f22:	00 
  807f23:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807f2a:	e8 4d 8a ff ff       	call   80097c <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807f2f:	c7 44 24 08 3a 37 81 	movl   $0x81373a,0x8(%esp)
  807f36:	00 
  807f37:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  807f3e:	00 
  807f3f:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  807f46:	e8 31 8a ff ff       	call   80097c <_panic>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  807f4b:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  807f4d:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  807f51:	66 83 fa 03          	cmp    $0x3,%dx
  807f55:	75 12                	jne    807f69 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  807f57:	89 44 24 04          	mov    %eax,0x4(%esp)
  807f5b:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807f62:	e8 d9 f7 ff ff       	call   807740 <memp_free>
  807f67:	eb 23                	jmp    807f8c <pbuf_free+0xb4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807f69:	83 ea 01             	sub    $0x1,%edx
  807f6c:	66 83 fa 01          	cmp    $0x1,%dx
  807f70:	77 12                	ja     807f84 <pbuf_free+0xac>
        memp_free(MEMP_PBUF, p);
  807f72:	89 44 24 04          	mov    %eax,0x4(%esp)
  807f76:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807f7d:	e8 be f7 ff ff       	call   807740 <memp_free>
  807f82:	eb 08                	jmp    807f8c <pbuf_free+0xb4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  807f84:	89 04 24             	mov    %eax,(%esp)
  807f87:	e8 42 f5 ff ff       	call   8074ce <mem_free>
      }
      count++;
  807f8c:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  807f8f:	85 db                	test   %ebx,%ebx
  807f91:	74 17                	je     807faa <pbuf_free+0xd2>
  807f93:	89 d8                	mov    %ebx,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807f95:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  807f99:	66 85 d2             	test   %dx,%dx
  807f9c:	74 91                	je     807f2f <pbuf_free+0x57>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  807f9e:	83 ea 01             	sub    $0x1,%edx
  807fa1:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  807fa5:	66 85 d2             	test   %dx,%dx
  807fa8:	74 a1                	je     807f4b <pbuf_free+0x73>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  807faa:	89 f0                	mov    %esi,%eax
  807fac:	83 c4 10             	add    $0x10,%esp
  807faf:	5b                   	pop    %ebx
  807fb0:	5e                   	pop    %esi
  807fb1:	5d                   	pop    %ebp
  807fb2:	c3                   	ret    

00807fb3 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807fb3:	55                   	push   %ebp
  807fb4:	89 e5                	mov    %esp,%ebp
  807fb6:	83 ec 38             	sub    $0x38,%esp
  807fb9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807fbc:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807fbf:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807fc2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  807fc5:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807fc7:	b8 01 00 00 00       	mov    $0x1,%eax
  807fcc:	85 f6                	test   %esi,%esi
  807fce:	74 55                	je     808025 <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807fd0:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807fd4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807fd8:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  807fdc:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  807fdf:	0f b7 fa             	movzwl %dx,%edi
  807fe2:	0f b7 c8             	movzwl %ax,%ecx
  807fe5:	29 cf                	sub    %ecx,%edi
  807fe7:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807fea:	74 1c                	je     808008 <pbuf_dechain+0x55>
  807fec:	c7 44 24 08 10 36 81 	movl   $0x813610,0x8(%esp)
  807ff3:	00 
  807ff4:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  807ffb:	00 
  807ffc:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  808003:	e8 74 89 ff ff       	call   80097c <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  808008:	66 29 c2             	sub    %ax,%dx
  80800b:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80800f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  808015:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  808019:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80801d:	89 34 24             	mov    %esi,(%esp)
  808020:	e8 b3 fe ff ff       	call   807ed8 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  808025:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  808029:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  80802d:	74 1c                	je     80804b <pbuf_dechain+0x98>
  80802f:	c7 44 24 08 50 37 81 	movl   $0x813750,0x8(%esp)
  808036:	00 
  808037:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  80803e:	00 
  80803f:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  808046:	e8 31 89 ff ff       	call   80097c <_panic>
  return ((tail_gone > 0) ? NULL : q);
  80804b:	3c 01                	cmp    $0x1,%al
  80804d:	19 c0                	sbb    %eax,%eax
  80804f:	21 c6                	and    %eax,%esi
}
  808051:	89 f0                	mov    %esi,%eax
  808053:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808056:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808059:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80805c:	89 ec                	mov    %ebp,%esp
  80805e:	5d                   	pop    %ebp
  80805f:	c3                   	ret    

00808060 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  808060:	55                   	push   %ebp
  808061:	89 e5                	mov    %esp,%ebp
  808063:	56                   	push   %esi
  808064:	53                   	push   %ebx
  808065:	83 ec 10             	sub    $0x10,%esp
  808068:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80806b:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80806f:	85 db                	test   %ebx,%ebx
  808071:	75 1c                	jne    80808f <pbuf_realloc+0x2f>
  808073:	c7 44 24 08 65 37 81 	movl   $0x813765,0x8(%esp)
  80807a:	00 
  80807b:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  808082:	00 
  808083:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  80808a:	e8 ed 88 ff ff       	call   80097c <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80808f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  808093:	3c 03                	cmp    $0x3,%al
  808095:	74 2b                	je     8080c2 <pbuf_realloc+0x62>
  808097:	3c 01                	cmp    $0x1,%al
  808099:	74 27                	je     8080c2 <pbuf_realloc+0x62>
  80809b:	84 c0                	test   %al,%al
  80809d:	8d 76 00             	lea    0x0(%esi),%esi
  8080a0:	74 20                	je     8080c2 <pbuf_realloc+0x62>
  8080a2:	3c 02                	cmp    $0x2,%al
  8080a4:	74 1c                	je     8080c2 <pbuf_realloc+0x62>
  8080a6:	c7 44 24 08 7d 37 81 	movl   $0x81377d,0x8(%esp)
  8080ad:	00 
  8080ae:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  8080b5:	00 
  8080b6:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  8080bd:	e8 ba 88 ff ff       	call   80097c <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  8080c2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8080c6:	66 39 f0             	cmp    %si,%ax
  8080c9:	0f 86 bd 00 00 00    	jbe    80818c <pbuf_realloc+0x12c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  8080cf:	0f b7 d6             	movzwl %si,%edx
  8080d2:	0f b7 c0             	movzwl %ax,%eax
  8080d5:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8080d7:	eb 4d                	jmp    808126 <pbuf_realloc+0xc6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  8080d9:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  8080df:	7e 1c                	jle    8080fd <pbuf_realloc+0x9d>
  8080e1:	c7 44 24 08 98 37 81 	movl   $0x813798,0x8(%esp)
  8080e8:	00 
  8080e9:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  8080f0:	00 
  8080f1:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  8080f8:	e8 7f 88 ff ff       	call   80097c <_panic>
    q->tot_len += (u16_t)grow;
  8080fd:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  808101:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  808103:	85 db                	test   %ebx,%ebx
  808105:	75 1c                	jne    808123 <pbuf_realloc+0xc3>
  808107:	c7 44 24 08 a9 37 81 	movl   $0x8137a9,0x8(%esp)
  80810e:	00 
  80810f:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  808116:	00 
  808117:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  80811e:	e8 59 88 ff ff       	call   80097c <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  808123:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  808126:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80812a:	66 39 c6             	cmp    %ax,%si
  80812d:	77 aa                	ja     8080d9 <pbuf_realloc+0x79>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80812f:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  808133:	75 3b                	jne    808170 <pbuf_realloc+0x110>
  808135:	66 39 f0             	cmp    %si,%ax
  808138:	74 36                	je     808170 <pbuf_realloc+0x110>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80813a:	0f b7 c6             	movzwl %si,%eax
  80813d:	03 43 04             	add    0x4(%ebx),%eax
  808140:	29 d8                	sub    %ebx,%eax
  808142:	89 44 24 04          	mov    %eax,0x4(%esp)
  808146:	89 1c 24             	mov    %ebx,(%esp)
  808149:	e8 1d f2 ff ff       	call   80736b <mem_realloc>
  80814e:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  808150:	85 c0                	test   %eax,%eax
  808152:	75 1c                	jne    808170 <pbuf_realloc+0x110>
  808154:	c7 44 24 08 c1 37 81 	movl   $0x8137c1,0x8(%esp)
  80815b:	00 
  80815c:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  808163:	00 
  808164:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  80816b:	e8 0c 88 ff ff       	call   80097c <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  808170:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  808174:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  808178:	8b 03                	mov    (%ebx),%eax
  80817a:	85 c0                	test   %eax,%eax
  80817c:	74 08                	je     808186 <pbuf_realloc+0x126>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80817e:	89 04 24             	mov    %eax,(%esp)
  808181:	e8 52 fd ff ff       	call   807ed8 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  808186:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  80818c:	83 c4 10             	add    $0x10,%esp
  80818f:	5b                   	pop    %ebx
  808190:	5e                   	pop    %esi
  808191:	5d                   	pop    %ebp
  808192:	c3                   	ret    

00808193 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  808193:	55                   	push   %ebp
  808194:	89 e5                	mov    %esp,%ebp
  808196:	57                   	push   %edi
  808197:	56                   	push   %esi
  808198:	53                   	push   %ebx
  808199:	83 ec 2c             	sub    $0x2c,%esp
  80819c:	8b 45 08             	mov    0x8(%ebp),%eax
  80819f:	8b 7d 10             	mov    0x10(%ebp),%edi
  8081a2:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8081a6:	83 f8 01             	cmp    $0x1,%eax
  8081a9:	74 27                	je     8081d2 <pbuf_alloc+0x3f>
  8081ab:	ba 14 00 00 00       	mov    $0x14,%edx
  8081b0:	83 f8 01             	cmp    $0x1,%eax
  8081b3:	72 22                	jb     8081d7 <pbuf_alloc+0x44>
  8081b5:	83 f8 02             	cmp    $0x2,%eax
  8081b8:	74 10                	je     8081ca <pbuf_alloc+0x37>
  8081ba:	83 f8 03             	cmp    $0x3,%eax
  8081bd:	8d 76 00             	lea    0x0(%esi),%esi
  8081c0:	75 21                	jne    8081e3 <pbuf_alloc+0x50>
  8081c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8081c8:	eb 35                	jmp    8081ff <pbuf_alloc+0x6c>
  8081ca:	ba 00 00 00 00       	mov    $0x0,%edx
  8081cf:	90                   	nop
  8081d0:	eb 08                	jmp    8081da <pbuf_alloc+0x47>
  8081d2:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  8081d7:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  8081da:	83 c2 0e             	add    $0xe,%edx
  8081dd:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  8081e1:	eb 22                	jmp    808205 <pbuf_alloc+0x72>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  8081e3:	c7 44 24 08 dc 37 81 	movl   $0x8137dc,0x8(%esp)
  8081ea:	00 
  8081eb:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  8081f2:	00 
  8081f3:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  8081fa:	e8 7d 87 ff ff       	call   80097c <_panic>
  8081ff:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  808205:	83 ff 02             	cmp    $0x2,%edi
  808208:	77 0e                	ja     808218 <pbuf_alloc+0x85>
  80820a:	83 ff 01             	cmp    $0x1,%edi
  80820d:	0f 83 c1 01 00 00    	jae    8083d4 <pbuf_alloc+0x241>
  808213:	e9 7a 01 00 00       	jmp    808392 <pbuf_alloc+0x1ff>
  808218:	83 ff 03             	cmp    $0x3,%edi
  80821b:	90                   	nop
  80821c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  808220:	0f 85 dc 01 00 00    	jne    808402 <pbuf_alloc+0x26f>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  808226:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  80822d:	8d 76 00             	lea    0x0(%esi),%esi
  808230:	e8 4f f5 ff ff       	call   807784 <memp_malloc>
  808235:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  808237:	85 c0                	test   %eax,%eax
  808239:	0f 84 e9 01 00 00    	je     808428 <pbuf_alloc+0x295>
      return NULL;
    }
    p->type = type;
  80823f:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  808243:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  808249:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80824d:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  808251:	83 e2 fc             	and    $0xfffffffc,%edx
  808254:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  808257:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80825b:	0f b7 db             	movzwl %bx,%ebx
  80825e:	83 c0 03             	add    $0x3,%eax
  808261:	89 c1                	mov    %eax,%ecx
  808263:	83 e1 fc             	and    $0xfffffffc,%ecx
  808266:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80826b:	29 c8                	sub    %ecx,%eax
  80826d:	39 d8                	cmp    %ebx,%eax
  80826f:	7e 02                	jle    808273 <pbuf_alloc+0xe0>
  808271:	89 d8                	mov    %ebx,%eax
  808273:	89 c1                	mov    %eax,%ecx
  808275:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  808279:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  80827f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808282:	0f b7 c1             	movzwl %cx,%eax
  808285:	01 c2                	add    %eax,%edx
  808287:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80828a:	73 1c                	jae    8082a8 <pbuf_alloc+0x115>
  80828c:	c7 44 24 08 34 36 81 	movl   $0x813634,0x8(%esp)
  808293:	00 
  808294:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  80829b:	00 
  80829c:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  8082a3:	e8 d4 86 ff ff       	call   80097c <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8082a8:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8082ae:	0f b7 c9             	movzwl %cx,%ecx
  8082b1:	29 cb                	sub    %ecx,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8082b3:	85 db                	test   %ebx,%ebx
  8082b5:	0f 8e 63 01 00 00    	jle    80841e <pbuf_alloc+0x28b>
  8082bb:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  8082bd:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8082c4:	e8 bb f4 ff ff       	call   807784 <memp_malloc>
      if (q == NULL) {
  8082c9:	85 c0                	test   %eax,%eax
  8082cb:	75 12                	jne    8082df <pbuf_alloc+0x14c>
        /* free chain so far allocated */
        pbuf_free(p);
  8082cd:	89 34 24             	mov    %esi,(%esp)
  8082d0:	e8 03 fc ff ff       	call   807ed8 <pbuf_free>
  8082d5:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  8082da:	e9 49 01 00 00       	jmp    808428 <pbuf_alloc+0x295>
      }
      q->type = type;
  8082df:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  8082e3:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  8082e7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  8082ed:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  8082ef:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  8082f5:	7e 1c                	jle    808313 <pbuf_alloc+0x180>
  8082f7:	c7 44 24 08 f7 37 81 	movl   $0x8137f7,0x8(%esp)
  8082fe:	00 
  8082ff:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  808306:	00 
  808307:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  80830e:	e8 69 86 ff ff       	call   80097c <_panic>
      q->tot_len = (u16_t)rem_len;
  808313:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  808317:	89 da                	mov    %ebx,%edx
  808319:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  80831e:	76 05                	jbe    808325 <pbuf_alloc+0x192>
  808320:	ba d0 07 00 00       	mov    $0x7d0,%edx
  808325:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  808329:	8d 48 10             	lea    0x10(%eax),%ecx
  80832c:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80832f:	f6 c1 03             	test   $0x3,%cl
  808332:	74 1c                	je     808350 <pbuf_alloc+0x1bd>
  808334:	c7 44 24 08 68 36 81 	movl   $0x813668,0x8(%esp)
  80833b:	00 
  80833c:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  808343:	00 
  808344:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  80834b:	e8 2c 86 ff ff       	call   80097c <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  808350:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  808354:	03 4e 04             	add    0x4(%esi),%ecx
  808357:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  80835a:	73 1c                	jae    808378 <pbuf_alloc+0x1e5>
  80835c:	c7 44 24 08 34 36 81 	movl   $0x813634,0x8(%esp)
  808363:	00 
  808364:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  80836b:	00 
  80836c:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  808373:	e8 04 86 ff ff       	call   80097c <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  808378:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80837e:	0f b7 d2             	movzwl %dx,%edx
  808381:	29 d3                	sub    %edx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  808383:	85 db                	test   %ebx,%ebx
  808385:	0f 8e 93 00 00 00    	jle    80841e <pbuf_alloc+0x28b>
  80838b:	89 c7                	mov    %eax,%edi
  80838d:	e9 2b ff ff ff       	jmp    8082bd <pbuf_alloc+0x12a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  808392:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  808396:	8d 57 13             	lea    0x13(%edi),%edx
  808399:	83 e2 fc             	and    $0xfffffffc,%edx
  80839c:	0f b7 c3             	movzwl %bx,%eax
  80839f:	83 c0 03             	add    $0x3,%eax
  8083a2:	83 e0 fc             	and    $0xfffffffc,%eax
  8083a5:	8d 04 02             	lea    (%edx,%eax,1),%eax
  8083a8:	89 04 24             	mov    %eax,(%esp)
  8083ab:	e8 90 ed ff ff       	call   807140 <mem_malloc>
  8083b0:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8083b2:	85 c0                	test   %eax,%eax
  8083b4:	74 72                	je     808428 <pbuf_alloc+0x295>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8083b6:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  8083ba:	83 e0 fc             	and    $0xfffffffc,%eax
  8083bd:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  8083c0:	66 89 5e 08          	mov    %bx,0x8(%esi)
  8083c4:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  8083c8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8083ce:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  8083d2:	eb 4a                	jmp    80841e <pbuf_alloc+0x28b>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  8083d4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8083db:	e8 a4 f3 ff ff       	call   807784 <memp_malloc>
  8083e0:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8083e2:	85 c0                	test   %eax,%eax
  8083e4:	74 42                	je     808428 <pbuf_alloc+0x295>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  8083e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  8083ed:	66 89 58 08          	mov    %bx,0x8(%eax)
  8083f1:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  8083f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  8083fb:	89 f8                	mov    %edi,%eax
  8083fd:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  808400:	eb 1c                	jmp    80841e <pbuf_alloc+0x28b>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  808402:	c7 44 24 08 0b 38 81 	movl   $0x81380b,0x8(%esp)
  808409:	00 
  80840a:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  808411:	00 
  808412:	c7 04 24 95 36 81 00 	movl   $0x813695,(%esp)
  808419:	e8 5e 85 ff ff       	call   80097c <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80841e:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  808424:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  808428:	89 f0                	mov    %esi,%eax
  80842a:	83 c4 2c             	add    $0x2c,%esp
  80842d:	5b                   	pop    %ebx
  80842e:	5e                   	pop    %esi
  80842f:	5f                   	pop    %edi
  808430:	5d                   	pop    %ebp
  808431:	c3                   	ret    
	...

00808440 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  808440:	55                   	push   %ebp
  808441:	89 e5                	mov    %esp,%ebp
  808443:	83 ec 18             	sub    $0x18,%esp
  808446:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  808449:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80844e:	8b 40 04             	mov    0x4(%eax),%eax
  808451:	8b 00                	mov    (%eax),%eax
  808453:	89 04 24             	mov    %eax,(%esp)
  808456:	e8 4c 57 00 00       	call   80dba7 <sys_sem_signal>
}
  80845b:	c9                   	leave  
  80845c:	c3                   	ret    

0080845d <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80845d:	55                   	push   %ebp
  80845e:	89 e5                	mov    %esp,%ebp
  808460:	57                   	push   %edi
  808461:	56                   	push   %esi
  808462:	53                   	push   %ebx
  808463:	83 ec 1c             	sub    $0x1c,%esp
  808466:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808469:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80846c:	e8 0e 52 00 00       	call   80d67f <sys_arch_timeouts>

  if (timeouts == NULL) {
  808471:	85 c0                	test   %eax,%eax
  808473:	75 1c                	jne    808491 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  808475:	c7 44 24 08 28 38 81 	movl   $0x813828,0x8(%esp)
  80847c:	00 
  80847d:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  808484:	00 
  808485:	c7 04 24 48 38 81 00 	movl   $0x813848,(%esp)
  80848c:	e8 eb 84 ff ff       	call   80097c <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  808491:	8b 10                	mov    (%eax),%edx
  808493:	85 d2                	test   %edx,%edx
  808495:	74 4b                	je     8084e2 <sys_untimeout+0x85>
  808497:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  80849c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  80849f:	75 33                	jne    8084d4 <sys_untimeout+0x77>
  8084a1:	39 72 0c             	cmp    %esi,0xc(%edx)
  8084a4:	75 2e                	jne    8084d4 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  8084a6:	85 ff                	test   %edi,%edi
  8084a8:	75 08                	jne    8084b2 <sys_untimeout+0x55>
        timeouts->next = t->next;
  8084aa:	8b 0a                	mov    (%edx),%ecx
  8084ac:	89 08                	mov    %ecx,(%eax)
  8084ae:	66 90                	xchg   %ax,%ax
  8084b0:	eb 04                	jmp    8084b6 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  8084b2:	8b 02                	mov    (%edx),%eax
  8084b4:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8084b6:	8b 02                	mov    (%edx),%eax
  8084b8:	85 c0                	test   %eax,%eax
  8084ba:	74 06                	je     8084c2 <sys_untimeout+0x65>
        t->next->time += t->time;
  8084bc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8084bf:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8084c2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8084c6:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8084cd:	e8 6e f2 ff ff       	call   807740 <memp_free>
      return;
  8084d2:	eb 0e                	jmp    8084e2 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8084d4:	8b 0a                	mov    (%edx),%ecx
  8084d6:	85 c9                	test   %ecx,%ecx
  8084d8:	74 08                	je     8084e2 <sys_untimeout+0x85>
  8084da:	89 d7                	mov    %edx,%edi
  8084dc:	89 ca                	mov    %ecx,%edx
  8084de:	66 90                	xchg   %ax,%ax
  8084e0:	eb ba                	jmp    80849c <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  8084e2:	83 c4 1c             	add    $0x1c,%esp
  8084e5:	5b                   	pop    %ebx
  8084e6:	5e                   	pop    %esi
  8084e7:	5f                   	pop    %edi
  8084e8:	5d                   	pop    %ebp
  8084e9:	c3                   	ret    

008084ea <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8084ea:	55                   	push   %ebp
  8084eb:	89 e5                	mov    %esp,%ebp
  8084ed:	56                   	push   %esi
  8084ee:	53                   	push   %ebx
  8084ef:	83 ec 10             	sub    $0x10,%esp
  8084f2:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8084f5:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8084fc:	e8 83 f2 ff ff       	call   807784 <memp_malloc>
  808501:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  808503:	85 c0                	test   %eax,%eax
  808505:	75 1c                	jne    808523 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  808507:	c7 44 24 08 5c 38 81 	movl   $0x81385c,0x8(%esp)
  80850e:	00 
  80850f:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  808516:	00 
  808517:	c7 04 24 48 38 81 00 	movl   $0x813848,(%esp)
  80851e:	e8 59 84 ff ff       	call   80097c <_panic>
    return;
  }
  timeout->next = NULL;
  808523:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  808529:	8b 45 0c             	mov    0xc(%ebp),%eax
  80852c:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80852f:	8b 45 10             	mov    0x10(%ebp),%eax
  808532:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  808535:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  808538:	e8 42 51 00 00       	call   80d67f <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80853d:	85 c0                	test   %eax,%eax
  80853f:	75 1c                	jne    80855d <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  808541:	c7 44 24 08 79 38 81 	movl   $0x813879,0x8(%esp)
  808548:	00 
  808549:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  808550:	00 
  808551:	c7 04 24 48 38 81 00 	movl   $0x813848,(%esp)
  808558:	e8 1f 84 ff ff       	call   80097c <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  80855d:	8b 10                	mov    (%eax),%edx
  80855f:	85 d2                	test   %edx,%edx
  808561:	75 04                	jne    808567 <sys_timeout+0x7d>
    timeouts->next = timeout;
  808563:	89 18                	mov    %ebx,(%eax)
    return;
  808565:	eb 4c                	jmp    8085b3 <sys_timeout+0xc9>
  }

  if (timeouts->next->time > msecs) {
  808567:	8b 4a 04             	mov    0x4(%edx),%ecx
  80856a:	39 ce                	cmp    %ecx,%esi
  80856c:	73 2d                	jae    80859b <sys_timeout+0xb1>
    timeouts->next->time -= msecs;
  80856e:	29 f1                	sub    %esi,%ecx
  808570:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  808573:	8b 10                	mov    (%eax),%edx
  808575:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  808577:	89 18                	mov    %ebx,(%eax)
  808579:	eb 38                	jmp    8085b3 <sys_timeout+0xc9>
  80857b:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80857d:	8b 73 04             	mov    0x4(%ebx),%esi
  808580:	2b 70 04             	sub    0x4(%eax),%esi
  808583:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808586:	8b 00                	mov    (%eax),%eax
  808588:	85 c0                	test   %eax,%eax
  80858a:	74 07                	je     808593 <sys_timeout+0xa9>
  80858c:	3b 70 04             	cmp    0x4(%eax),%esi
  80858f:	73 ea                	jae    80857b <sys_timeout+0x91>
  808591:	eb 1b                	jmp    8085ae <sys_timeout+0xc4>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  808593:	8b 02                	mov    (%edx),%eax
  808595:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  808597:	89 1a                	mov    %ebx,(%edx)
  808599:	eb 18                	jmp    8085b3 <sys_timeout+0xc9>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80859b:	8b 73 04             	mov    0x4(%ebx),%esi
  80859e:	29 ce                	sub    %ecx,%esi
  8085a0:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8085a3:	8b 02                	mov    (%edx),%eax
  8085a5:	85 c0                	test   %eax,%eax
  8085a7:	74 ea                	je     808593 <sys_timeout+0xa9>
  8085a9:	3b 70 04             	cmp    0x4(%eax),%esi
  8085ac:	73 cd                	jae    80857b <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  8085ae:	29 70 04             	sub    %esi,0x4(%eax)
  8085b1:	eb e0                	jmp    808593 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  8085b3:	83 c4 10             	add    $0x10,%esp
  8085b6:	5b                   	pop    %ebx
  8085b7:	5e                   	pop    %esi
  8085b8:	5d                   	pop    %ebp
  8085b9:	c3                   	ret    

008085ba <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  8085ba:	55                   	push   %ebp
  8085bb:	89 e5                	mov    %esp,%ebp
  8085bd:	57                   	push   %edi
  8085be:	56                   	push   %esi
  8085bf:	53                   	push   %ebx
  8085c0:	83 ec 1c             	sub    $0x1c,%esp
  8085c3:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  8085c6:	e8 b4 50 00 00       	call   80d67f <sys_arch_timeouts>
  8085cb:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8085cd:	85 c0                	test   %eax,%eax
  8085cf:	74 06                	je     8085d7 <sys_sem_wait+0x1d>
  8085d1:	8b 00                	mov    (%eax),%eax
  8085d3:	85 c0                	test   %eax,%eax
  8085d5:	75 12                	jne    8085e9 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  8085d7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8085de:	00 
  8085df:	89 3c 24             	mov    %edi,(%esp)
  8085e2:	e8 cf 52 00 00       	call   80d8b6 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  8085e7:	eb 58                	jmp    808641 <sys_sem_wait+0x87>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  8085e9:	8b 40 04             	mov    0x4(%eax),%eax
  8085ec:	85 c0                	test   %eax,%eax
  8085ee:	74 11                	je     808601 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8085f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8085f4:	89 3c 24             	mov    %edi,(%esp)
  8085f7:	e8 ba 52 00 00       	call   80d8b6 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8085fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8085ff:	75 29                	jne    80862a <sys_sem_wait+0x70>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  808601:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  808603:	8b 10                	mov    (%eax),%edx
  808605:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  808607:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80860a:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80860d:	89 44 24 04          	mov    %eax,0x4(%esp)
  808611:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  808618:	e8 23 f1 ff ff       	call   807740 <memp_free>
      if (h != NULL) {
  80861d:	85 db                	test   %ebx,%ebx
  80861f:	74 a5                	je     8085c6 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  808621:	89 34 24             	mov    %esi,(%esp)
  808624:	ff d3                	call   *%ebx
  808626:	66 90                	xchg   %ax,%ax
  808628:	eb 9c                	jmp    8085c6 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80862a:	8b 13                	mov    (%ebx),%edx
  80862c:	8b 4a 04             	mov    0x4(%edx),%ecx
  80862f:	39 c8                	cmp    %ecx,%eax
  808631:	73 07                	jae    80863a <sys_sem_wait+0x80>
        timeouts->next->time -= time_needed;
  808633:	29 c1                	sub    %eax,%ecx
  808635:	89 4a 04             	mov    %ecx,0x4(%edx)
  808638:	eb 07                	jmp    808641 <sys_sem_wait+0x87>
      } else {
        timeouts->next->time = 0;
  80863a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808641:	83 c4 1c             	add    $0x1c,%esp
  808644:	5b                   	pop    %ebx
  808645:	5e                   	pop    %esi
  808646:	5f                   	pop    %edi
  808647:	5d                   	pop    %ebp
  808648:	c3                   	ret    

00808649 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  808649:	55                   	push   %ebp
  80864a:	89 e5                	mov    %esp,%ebp
  80864c:	83 ec 28             	sub    $0x28,%esp
  80864f:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  808652:	8d 55 08             	lea    0x8(%ebp),%edx
  808655:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  808658:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80865e:	85 c0                	test   %eax,%eax
  808660:	74 17                	je     808679 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  808662:	8d 55 f0             	lea    -0x10(%ebp),%edx
  808665:	89 54 24 08          	mov    %edx,0x8(%esp)
  808669:	c7 44 24 04 40 84 80 	movl   $0x808440,0x4(%esp)
  808670:	00 
  808671:	89 04 24             	mov    %eax,(%esp)
  808674:	e8 71 fe ff ff       	call   8084ea <sys_timeout>
  }
  sys_sem_wait(sem);
  808679:	8b 45 08             	mov    0x8(%ebp),%eax
  80867c:	89 04 24             	mov    %eax,(%esp)
  80867f:	e8 36 ff ff ff       	call   8085ba <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808684:	b8 00 00 00 00       	mov    $0x0,%eax
  808689:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80868e:	75 18                	jne    8086a8 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808690:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808693:	89 44 24 04          	mov    %eax,0x4(%esp)
  808697:	c7 04 24 40 84 80 00 	movl   $0x808440,(%esp)
  80869e:	e8 ba fd ff ff       	call   80845d <sys_untimeout>
  8086a3:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  8086a8:	c9                   	leave  
  8086a9:	c3                   	ret    

008086aa <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8086aa:	55                   	push   %ebp
  8086ab:	89 e5                	mov    %esp,%ebp
  8086ad:	53                   	push   %ebx
  8086ae:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8086b1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8086b8:	e8 48 53 00 00       	call   80da05 <sys_sem_new>
  8086bd:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8086bf:	8b 45 08             	mov    0x8(%ebp),%eax
  8086c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8086c6:	89 1c 24             	mov    %ebx,(%esp)
  8086c9:	e8 7b ff ff ff       	call   808649 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8086ce:	89 1c 24             	mov    %ebx,(%esp)
  8086d1:	e8 8d 4e 00 00       	call   80d563 <sys_sem_free>
}
  8086d6:	83 c4 14             	add    $0x14,%esp
  8086d9:	5b                   	pop    %ebx
  8086da:	5d                   	pop    %ebp
  8086db:	c3                   	ret    

008086dc <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  8086dc:	55                   	push   %ebp
  8086dd:	89 e5                	mov    %esp,%ebp
  8086df:	57                   	push   %edi
  8086e0:	56                   	push   %esi
  8086e1:	53                   	push   %ebx
  8086e2:	83 ec 1c             	sub    $0x1c,%esp
  8086e5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  8086e8:	e8 92 4f 00 00       	call   80d67f <sys_arch_timeouts>
  8086ed:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8086ef:	85 c0                	test   %eax,%eax
  8086f1:	74 06                	je     8086f9 <sys_mbox_fetch+0x1d>
  8086f3:	8b 00                	mov    (%eax),%eax
  8086f5:	85 c0                	test   %eax,%eax
  8086f7:	75 19                	jne    808712 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8086f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808700:	00 
  808701:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808705:	8b 45 08             	mov    0x8(%ebp),%eax
  808708:	89 04 24             	mov    %eax,(%esp)
  80870b:	e8 04 55 00 00       	call   80dc14 <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808710:	eb 5f                	jmp    808771 <sys_mbox_fetch+0x95>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  808712:	8b 40 04             	mov    0x4(%eax),%eax
  808715:	85 c0                	test   %eax,%eax
  808717:	74 18                	je     808731 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  808719:	89 44 24 08          	mov    %eax,0x8(%esp)
  80871d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808721:	8b 45 08             	mov    0x8(%ebp),%eax
  808724:	89 04 24             	mov    %eax,(%esp)
  808727:	e8 e8 54 00 00       	call   80dc14 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80872c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80872f:	75 29                	jne    80875a <sys_mbox_fetch+0x7e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  808731:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  808733:	8b 10                	mov    (%eax),%edx
  808735:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  808737:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80873a:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80873d:	89 44 24 04          	mov    %eax,0x4(%esp)
  808741:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  808748:	e8 f3 ef ff ff       	call   807740 <memp_free>
      if (h != NULL) {
  80874d:	85 db                	test   %ebx,%ebx
  80874f:	74 97                	je     8086e8 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  808751:	89 34 24             	mov    %esi,(%esp)
  808754:	ff d3                	call   *%ebx
  808756:	66 90                	xchg   %ax,%ax
  808758:	eb 8e                	jmp    8086e8 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80875a:	8b 13                	mov    (%ebx),%edx
  80875c:	8b 4a 04             	mov    0x4(%edx),%ecx
  80875f:	39 c8                	cmp    %ecx,%eax
  808761:	73 07                	jae    80876a <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  808763:	29 c1                	sub    %eax,%ecx
  808765:	89 4a 04             	mov    %ecx,0x4(%edx)
  808768:	eb 07                	jmp    808771 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  80876a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808771:	83 c4 1c             	add    $0x1c,%esp
  808774:	5b                   	pop    %ebx
  808775:	5e                   	pop    %esi
  808776:	5f                   	pop    %edi
  808777:	5d                   	pop    %ebp
  808778:	c3                   	ret    
  808779:	00 00                	add    %al,(%eax)
  80877b:	00 00                	add    %al,(%eax)
  80877d:	00 00                	add    %al,(%eax)
	...

00808780 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808780:	55                   	push   %ebp
  808781:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808783:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808788:	5d                   	pop    %ebp
  808789:	c3                   	ret    

0080878a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80878a:	55                   	push   %ebp
  80878b:	89 e5                	mov    %esp,%ebp
  80878d:	57                   	push   %edi
  80878e:	56                   	push   %esi
  80878f:	53                   	push   %ebx
  808790:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808793:	8b 0d 08 e6 b3 00    	mov    0xb3e608,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808799:	8b 1d 1c e6 b3 00    	mov    0xb3e61c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80879f:	8b 35 10 e6 b3 00    	mov    0xb3e610,%esi
  8087a5:	0f b7 15 80 80 81 00 	movzwl 0x818080,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8087ac:	bf 00 10 00 00       	mov    $0x1000,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  8087b1:	89 75 f0             	mov    %esi,-0x10(%ebp)
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8087b4:	66 83 c2 01          	add    $0x1,%dx
  8087b8:	79 02                	jns    8087bc <tcp_new_port+0x32>
  8087ba:	89 fa                	mov    %edi,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8087bc:	85 c9                	test   %ecx,%ecx
  8087be:	74 19                	je     8087d9 <tcp_new_port+0x4f>
    if (pcb->local_port == port) {
  8087c0:	89 c8                	mov    %ecx,%eax
  8087c2:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  8087c6:	75 0a                	jne    8087d2 <tcp_new_port+0x48>
  8087c8:	eb ea                	jmp    8087b4 <tcp_new_port+0x2a>
  8087ca:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8087ce:	66 90                	xchg   %ax,%ax
  8087d0:	74 e2                	je     8087b4 <tcp_new_port+0x2a>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8087d2:	8b 40 0c             	mov    0xc(%eax),%eax
  8087d5:	85 c0                	test   %eax,%eax
  8087d7:	75 f1                	jne    8087ca <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8087d9:	85 db                	test   %ebx,%ebx
  8087db:	74 1c                	je     8087f9 <tcp_new_port+0x6f>
    if (pcb->local_port == port) {
  8087dd:	89 d8                	mov    %ebx,%eax
  8087df:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  8087e3:	75 0d                	jne    8087f2 <tcp_new_port+0x68>
  8087e5:	eb cd                	jmp    8087b4 <tcp_new_port+0x2a>
  8087e7:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8087eb:	90                   	nop
  8087ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8087f0:	74 c2                	je     8087b4 <tcp_new_port+0x2a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8087f2:	8b 40 0c             	mov    0xc(%eax),%eax
  8087f5:	85 c0                	test   %eax,%eax
  8087f7:	75 ee                	jne    8087e7 <tcp_new_port+0x5d>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8087f9:	85 f6                	test   %esi,%esi
  8087fb:	75 09                	jne    808806 <tcp_new_port+0x7c>
  8087fd:	66 89 15 80 80 81 00 	mov    %dx,0x818080
  808804:	eb 23                	jmp    808829 <tcp_new_port+0x9f>
    if (pcb->local_port == port) {
  808806:	8b 45 f0             	mov    -0x10(%ebp),%eax
  808809:	66 3b 56 1c          	cmp    0x1c(%esi),%dx
  80880d:	75 09                	jne    808818 <tcp_new_port+0x8e>
  80880f:	90                   	nop
  808810:	eb a2                	jmp    8087b4 <tcp_new_port+0x2a>
  808812:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  808816:	74 9c                	je     8087b4 <tcp_new_port+0x2a>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808818:	8b 40 0c             	mov    0xc(%eax),%eax
  80881b:	85 c0                	test   %eax,%eax
  80881d:	8d 76 00             	lea    0x0(%esi),%esi
  808820:	75 f0                	jne    808812 <tcp_new_port+0x88>
  808822:	66 89 15 80 80 81 00 	mov    %dx,0x818080
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  808829:	0f b7 05 80 80 81 00 	movzwl 0x818080,%eax
  808830:	83 c4 04             	add    $0x4,%esp
  808833:	5b                   	pop    %ebx
  808834:	5e                   	pop    %esi
  808835:	5f                   	pop    %edi
  808836:	5d                   	pop    %ebp
  808837:	c3                   	ret    

00808838 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  808838:	55                   	push   %ebp
  808839:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80883b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80883e:	8b 45 08             	mov    0x8(%ebp),%eax
  808841:	88 50 14             	mov    %dl,0x14(%eax)
}
  808844:	5d                   	pop    %ebp
  808845:	c3                   	ret    

00808846 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  808846:	55                   	push   %ebp
  808847:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  808849:	8b 55 0c             	mov    0xc(%ebp),%edx
  80884c:	8b 45 08             	mov    0x8(%ebp),%eax
  80884f:	89 50 18             	mov    %edx,0x18(%eax)
}
  808852:	5d                   	pop    %ebp
  808853:	c3                   	ret    

00808854 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  808854:	55                   	push   %ebp
  808855:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  808857:	8b 55 0c             	mov    0xc(%ebp),%edx
  80885a:	8b 45 08             	mov    0x8(%ebp),%eax
  80885d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808863:	5d                   	pop    %ebp
  808864:	c3                   	ret    

00808865 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808865:	55                   	push   %ebp
  808866:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  808868:	8b 55 0c             	mov    0xc(%ebp),%edx
  80886b:	8b 45 08             	mov    0x8(%ebp),%eax
  80886e:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808874:	5d                   	pop    %ebp
  808875:	c3                   	ret    

00808876 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808876:	55                   	push   %ebp
  808877:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  808879:	8b 55 0c             	mov    0xc(%ebp),%edx
  80887c:	8b 45 08             	mov    0x8(%ebp),%eax
  80887f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808885:	5d                   	pop    %ebp
  808886:	c3                   	ret    

00808887 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808887:	55                   	push   %ebp
  808888:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80888a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80888d:	8b 45 08             	mov    0x8(%ebp),%eax
  808890:	89 50 20             	mov    %edx,0x20(%eax)
}
  808893:	5d                   	pop    %ebp
  808894:	c3                   	ret    

00808895 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808895:	55                   	push   %ebp
  808896:	89 e5                	mov    %esp,%ebp
  808898:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80889b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80889e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8088a4:	8b 55 10             	mov    0x10(%ebp),%edx
  8088a7:	88 50 31             	mov    %dl,0x31(%eax)
}
  8088aa:	5d                   	pop    %ebp
  8088ab:	c3                   	ret    

008088ac <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8088ac:	55                   	push   %ebp
  8088ad:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8088af:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  8088b4:	03 05 7c 80 81 00    	add    0x81807c,%eax
  8088ba:	a3 7c 80 81 00       	mov    %eax,0x81807c
  return iss;
}
  8088bf:	5d                   	pop    %ebp
  8088c0:	c3                   	ret    

008088c1 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8088c1:	55                   	push   %ebp
  8088c2:	89 e5                	mov    %esp,%ebp
  8088c4:	53                   	push   %ebx
  8088c5:	83 ec 14             	sub    $0x14,%esp
  8088c8:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8088cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8088cf:	89 04 24             	mov    %eax,(%esp)
  8088d2:	e8 ea 11 00 00       	call   809ac1 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8088d7:	85 c0                	test   %eax,%eax
  8088d9:	74 13                	je     8088ee <tcp_eff_send_mss+0x2d>
  8088db:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8088df:	66 85 c0             	test   %ax,%ax
  8088e2:	74 0a                	je     8088ee <tcp_eff_send_mss+0x2d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8088e4:	83 e8 28             	sub    $0x28,%eax
  8088e7:	66 39 c3             	cmp    %ax,%bx
  8088ea:	76 02                	jbe    8088ee <tcp_eff_send_mss+0x2d>
  8088ec:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
}
  8088ee:	89 d8                	mov    %ebx,%eax
  8088f0:	83 c4 14             	add    $0x14,%esp
  8088f3:	5b                   	pop    %ebx
  8088f4:	5d                   	pop    %ebp
  8088f5:	c3                   	ret    

008088f6 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  8088f6:	55                   	push   %ebp
  8088f7:	89 e5                	mov    %esp,%ebp
  8088f9:	83 ec 18             	sub    $0x18,%esp
  8088fc:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8088ff:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808902:	8b 45 08             	mov    0x8(%ebp),%eax
  808905:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  808909:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  80890d:	0f b7 f1             	movzwl %cx,%esi
  808910:	0f b7 da             	movzwl %dx,%ebx
  808913:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  808916:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  80891c:	76 0e                	jbe    80892c <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  80891e:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  808924:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  80892a:	eb 11                	jmp    80893d <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  80892c:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  80892f:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  808933:	66 3b 50 34          	cmp    0x34(%eax),%dx
  808937:	72 04                	jb     80893d <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  808939:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80893d:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  808941:	f6 c2 03             	test   $0x3,%dl
  808944:	75 20                	jne    808966 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  808946:	f6 c2 01             	test   $0x1,%dl
  808949:	74 13                	je     80895e <tcp_recved+0x68>
  80894b:	83 e2 fe             	and    $0xfffffffe,%edx
  80894e:	83 ca 02             	or     $0x2,%edx
  808951:	88 50 20             	mov    %dl,0x20(%eax)
  808954:	89 04 24             	mov    %eax,(%esp)
  808957:	e8 ff 29 00 00       	call   80b35b <tcp_output>
  80895c:	eb 23                	jmp    808981 <tcp_recved+0x8b>
  80895e:	83 ca 01             	or     $0x1,%edx
  808961:	88 50 20             	mov    %dl,0x20(%eax)
  808964:	eb 1b                	jmp    808981 <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  808966:	f6 c2 01             	test   $0x1,%dl
  808969:	74 16                	je     808981 <tcp_recved+0x8b>
  80896b:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  808971:	76 0e                	jbe    808981 <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  808973:	83 ca 02             	or     $0x2,%edx
  808976:	88 50 20             	mov    %dl,0x20(%eax)
  808979:	89 04 24             	mov    %eax,(%esp)
  80897c:	e8 da 29 00 00       	call   80b35b <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808981:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808984:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808987:	89 ec                	mov    %ebp,%esp
  808989:	5d                   	pop    %ebp
  80898a:	c3                   	ret    

0080898b <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80898b:	55                   	push   %ebp
  80898c:	89 e5                	mov    %esp,%ebp
  80898e:	53                   	push   %ebx
  80898f:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808992:	8b 1d 08 e6 b3 00    	mov    0xb3e608,%ebx
  808998:	85 db                	test   %ebx,%ebx
  80899a:	74 6c                	je     808a08 <tcp_fasttmr+0x7d>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80899c:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8089a2:	85 c0                	test   %eax,%eax
  8089a4:	74 41                	je     8089e7 <tcp_fasttmr+0x5c>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8089a6:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8089ac:	85 d2                	test   %edx,%edx
  8089ae:	74 1e                	je     8089ce <tcp_fasttmr+0x43>
  8089b0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8089b7:	00 
  8089b8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8089bc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8089c0:	8b 43 18             	mov    0x18(%ebx),%eax
  8089c3:	89 04 24             	mov    %eax,(%esp)
  8089c6:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8089c8:	84 c0                	test   %al,%al
  8089ca:	75 1b                	jne    8089e7 <tcp_fasttmr+0x5c>
  8089cc:	eb 0f                	jmp    8089dd <tcp_fasttmr+0x52>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8089ce:	89 04 24             	mov    %eax,(%esp)
  8089d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8089d8:	e8 fb f4 ff ff       	call   807ed8 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8089dd:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8089e4:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8089e7:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8089eb:	a8 01                	test   $0x1,%al
  8089ed:	74 12                	je     808a01 <tcp_fasttmr+0x76>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8089ef:	83 c8 02             	or     $0x2,%eax
  8089f2:	88 43 20             	mov    %al,0x20(%ebx)
  8089f5:	89 1c 24             	mov    %ebx,(%esp)
  8089f8:	e8 5e 29 00 00       	call   80b35b <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8089fd:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808a01:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808a04:	85 db                	test   %ebx,%ebx
  808a06:	75 94                	jne    80899c <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  808a08:	83 c4 14             	add    $0x14,%esp
  808a0b:	5b                   	pop    %ebx
  808a0c:	5d                   	pop    %ebp
  808a0d:	c3                   	ret    

00808a0e <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  808a0e:	55                   	push   %ebp
  808a0f:	89 e5                	mov    %esp,%ebp
  808a11:	53                   	push   %ebx
  808a12:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  808a15:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808a1c:	e8 63 ed ff ff       	call   807784 <memp_malloc>
  808a21:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  808a23:	85 c0                	test   %eax,%eax
  808a25:	74 22                	je     808a49 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  808a27:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  808a2e:	00 
  808a2f:	8b 45 08             	mov    0x8(%ebp),%eax
  808a32:	89 44 24 04          	mov    %eax,0x4(%esp)
  808a36:	89 1c 24             	mov    %ebx,(%esp)
  808a39:	e8 13 89 ff ff       	call   801351 <memcpy>
  pbuf_ref(cseg->p);
  808a3e:	8b 43 04             	mov    0x4(%ebx),%eax
  808a41:	89 04 24             	mov    %eax,(%esp)
  808a44:	e8 41 f0 ff ff       	call   807a8a <pbuf_ref>
  return cseg;
}
  808a49:	89 d8                	mov    %ebx,%eax
  808a4b:	83 c4 14             	add    $0x14,%esp
  808a4e:	5b                   	pop    %ebx
  808a4f:	5d                   	pop    %ebp
  808a50:	c3                   	ret    

00808a51 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  808a51:	55                   	push   %ebp
  808a52:	89 e5                	mov    %esp,%ebp
  808a54:	83 ec 18             	sub    $0x18,%esp
  808a57:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808a5a:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808a5d:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  808a60:	bb 00 00 00 00       	mov    $0x0,%ebx
  808a65:	85 f6                	test   %esi,%esi
  808a67:	74 21                	je     808a8a <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  808a69:	8b 46 04             	mov    0x4(%esi),%eax
  808a6c:	85 c0                	test   %eax,%eax
  808a6e:	74 0a                	je     808a7a <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  808a70:	89 04 24             	mov    %eax,(%esp)
  808a73:	e8 60 f4 ff ff       	call   807ed8 <pbuf_free>
  808a78:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  808a7a:	89 74 24 04          	mov    %esi,0x4(%esp)
  808a7e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808a85:	e8 b6 ec ff ff       	call   807740 <memp_free>
  }
  return count;
}
  808a8a:	89 d8                	mov    %ebx,%eax
  808a8c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808a8f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808a92:	89 ec                	mov    %ebp,%esp
  808a94:	5d                   	pop    %ebp
  808a95:	c3                   	ret    

00808a96 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808a96:	55                   	push   %ebp
  808a97:	89 e5                	mov    %esp,%ebp
  808a99:	56                   	push   %esi
  808a9a:	53                   	push   %ebx
  808a9b:	83 ec 10             	sub    $0x10,%esp
  808a9e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808aa1:	be 00 00 00 00       	mov    $0x0,%esi
  808aa6:	85 c0                	test   %eax,%eax
  808aa8:	74 14                	je     808abe <tcp_segs_free+0x28>
    next = seg->next;
  808aaa:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  808aac:	89 04 24             	mov    %eax,(%esp)
  808aaf:	e8 9d ff ff ff       	call   808a51 <tcp_seg_free>
  808ab4:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808ab6:	85 db                	test   %ebx,%ebx
  808ab8:	74 04                	je     808abe <tcp_segs_free+0x28>
  808aba:	89 d8                	mov    %ebx,%eax
  808abc:	eb ec                	jmp    808aaa <tcp_segs_free+0x14>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  808abe:	89 f0                	mov    %esi,%eax
  808ac0:	83 c4 10             	add    $0x10,%esp
  808ac3:	5b                   	pop    %ebx
  808ac4:	5e                   	pop    %esi
  808ac5:	5d                   	pop    %ebp
  808ac6:	c3                   	ret    

00808ac7 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808ac7:	55                   	push   %ebp
  808ac8:	89 e5                	mov    %esp,%ebp
  808aca:	53                   	push   %ebx
  808acb:	83 ec 14             	sub    $0x14,%esp
  808ace:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  808ad1:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  808ad4:	85 c0                	test   %eax,%eax
  808ad6:	74 62                	je     808b3a <tcp_pcb_purge+0x73>
  808ad8:	83 f8 0a             	cmp    $0xa,%eax
  808adb:	74 5d                	je     808b3a <tcp_pcb_purge+0x73>
  808add:	83 f8 01             	cmp    $0x1,%eax
  808ae0:	74 58                	je     808b3a <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808ae2:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808ae8:	85 c0                	test   %eax,%eax
  808aea:	74 12                	je     808afe <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  808aec:	89 04 24             	mov    %eax,(%esp)
  808aef:	e8 e4 f3 ff ff       	call   807ed8 <pbuf_free>
      pcb->refused_data = NULL;
  808af4:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808afb:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  808afe:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  808b04:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808b07:	89 04 24             	mov    %eax,(%esp)
  808b0a:	e8 87 ff ff ff       	call   808a96 <tcp_segs_free>
    pcb->ooseq = NULL;
  808b0f:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  808b16:	8b 43 74             	mov    0x74(%ebx),%eax
  808b19:	89 04 24             	mov    %eax,(%esp)
  808b1c:	e8 75 ff ff ff       	call   808a96 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  808b21:	8b 43 78             	mov    0x78(%ebx),%eax
  808b24:	89 04 24             	mov    %eax,(%esp)
  808b27:	e8 6a ff ff ff       	call   808a96 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  808b2c:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  808b33:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  808b3a:	83 c4 14             	add    $0x14,%esp
  808b3d:	5b                   	pop    %ebx
  808b3e:	5d                   	pop    %ebp
  808b3f:	c3                   	ret    

00808b40 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  808b40:	55                   	push   %ebp
  808b41:	89 e5                	mov    %esp,%ebp
  808b43:	53                   	push   %ebx
  808b44:	83 ec 14             	sub    $0x14,%esp
  808b47:	8b 45 08             	mov    0x8(%ebp),%eax
  808b4a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  808b4d:	8b 10                	mov    (%eax),%edx
  808b4f:	39 da                	cmp    %ebx,%edx
  808b51:	75 07                	jne    808b5a <tcp_pcb_remove+0x1a>
  808b53:	8b 52 0c             	mov    0xc(%edx),%edx
  808b56:	89 10                	mov    %edx,(%eax)
  808b58:	eb 2a                	jmp    808b84 <tcp_pcb_remove+0x44>
  808b5a:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  808b60:	85 d2                	test   %edx,%edx
  808b62:	74 20                	je     808b84 <tcp_pcb_remove+0x44>
  808b64:	8b 42 0c             	mov    0xc(%edx),%eax
  808b67:	85 c0                	test   %eax,%eax
  808b69:	0f 84 c0 00 00 00    	je     808c2f <tcp_pcb_remove+0xef>
  808b6f:	39 c3                	cmp    %eax,%ebx
  808b71:	75 08                	jne    808b7b <tcp_pcb_remove+0x3b>
  808b73:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b76:	89 42 0c             	mov    %eax,0xc(%edx)
  808b79:	eb 09                	jmp    808b84 <tcp_pcb_remove+0x44>
  808b7b:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808b80:	89 c2                	mov    %eax,%edx
  808b82:	eb e0                	jmp    808b64 <tcp_pcb_remove+0x24>
  808b84:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  808b8b:	89 1c 24             	mov    %ebx,(%esp)
  808b8e:	e8 34 ff ff ff       	call   808ac7 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  808b93:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808b96:	83 f8 0a             	cmp    $0xa,%eax
  808b99:	74 1b                	je     808bb6 <tcp_pcb_remove+0x76>
  808b9b:	83 f8 01             	cmp    $0x1,%eax
  808b9e:	74 16                	je     808bb6 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  808ba0:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808ba4:	a8 01                	test   $0x1,%al
  808ba6:	74 0e                	je     808bb6 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808ba8:	83 c8 02             	or     $0x2,%eax
  808bab:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  808bae:	89 1c 24             	mov    %ebx,(%esp)
  808bb1:	e8 a5 27 00 00       	call   80b35b <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808bb6:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808bba:	74 66                	je     808c22 <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  808bbc:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808bc0:	74 1c                	je     808bde <tcp_pcb_remove+0x9e>
  808bc2:	c7 44 24 08 97 38 81 	movl   $0x813897,0x8(%esp)
  808bc9:	00 
  808bca:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  808bd1:	00 
  808bd2:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808bd9:	e8 9e 7d ff ff       	call   80097c <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  808bde:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808be2:	74 1c                	je     808c00 <tcp_pcb_remove+0xc0>
  808be4:	c7 44 24 08 c3 38 81 	movl   $0x8138c3,0x8(%esp)
  808beb:	00 
  808bec:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  808bf3:	00 
  808bf4:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808bfb:	e8 7c 7d ff ff       	call   80097c <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  808c00:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  808c04:	74 1c                	je     808c22 <tcp_pcb_remove+0xe2>
  808c06:	c7 44 24 08 dc 38 81 	movl   $0x8138dc,0x8(%esp)
  808c0d:	00 
  808c0e:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  808c15:	00 
  808c16:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808c1d:	e8 5a 7d ff ff       	call   80097c <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  808c22:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  808c29:	83 c4 14             	add    $0x14,%esp
  808c2c:	5b                   	pop    %ebx
  808c2d:	5d                   	pop    %ebp
  808c2e:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  808c2f:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808c34:	e9 4b ff ff ff       	jmp    808b84 <tcp_pcb_remove+0x44>

00808c39 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  808c39:	55                   	push   %ebp
  808c3a:	89 e5                	mov    %esp,%ebp
  808c3c:	83 ec 18             	sub    $0x18,%esp
  808c3f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808c42:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808c45:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  808c48:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808c4c:	74 1c                	je     808c6a <tcp_listen_with_backlog+0x31>
  808c4e:	c7 44 24 08 f4 38 81 	movl   $0x8138f4,0x8(%esp)
  808c55:	00 
  808c56:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  808c5d:	00 
  808c5e:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808c65:	e8 12 7d ff ff       	call   80097c <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  808c6a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808c71:	e8 0e eb ff ff       	call   807784 <memp_malloc>
  808c76:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  808c78:	b8 00 00 00 00       	mov    $0x0,%eax
  808c7d:	85 f6                	test   %esi,%esi
  808c7f:	0f 84 a8 00 00 00    	je     808d2d <tcp_listen_with_backlog+0xf4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  808c85:	8b 43 18             	mov    0x18(%ebx),%eax
  808c88:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  808c8b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808c8f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  808c93:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  808c9a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808c9e:	83 c8 02             	or     $0x2,%eax
  808ca1:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808ca5:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808ca9:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  808cac:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808cb0:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808cb3:	b8 00 00 00 00       	mov    $0x0,%eax
  808cb8:	85 db                	test   %ebx,%ebx
  808cba:	74 02                	je     808cbe <tcp_listen_with_backlog+0x85>
  808cbc:	8b 03                	mov    (%ebx),%eax
  808cbe:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808cc0:	8b 15 18 e6 b3 00    	mov    0xb3e618,%edx
  808cc6:	39 da                	cmp    %ebx,%edx
  808cc8:	75 0a                	jne    808cd4 <tcp_listen_with_backlog+0x9b>
  808cca:	8b 42 0c             	mov    0xc(%edx),%eax
  808ccd:	a3 18 e6 b3 00       	mov    %eax,0xb3e618
  808cd2:	eb 26                	jmp    808cfa <tcp_listen_with_backlog+0xc1>
  808cd4:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  808cda:	85 d2                	test   %edx,%edx
  808cdc:	74 1c                	je     808cfa <tcp_listen_with_backlog+0xc1>
  808cde:	8b 42 0c             	mov    0xc(%edx),%eax
  808ce1:	85 c0                	test   %eax,%eax
  808ce3:	74 52                	je     808d37 <tcp_listen_with_backlog+0xfe>
  808ce5:	39 c3                	cmp    %eax,%ebx
  808ce7:	75 08                	jne    808cf1 <tcp_listen_with_backlog+0xb8>
  808ce9:	8b 43 0c             	mov    0xc(%ebx),%eax
  808cec:	89 42 0c             	mov    %eax,0xc(%edx)
  808cef:	eb 09                	jmp    808cfa <tcp_listen_with_backlog+0xc1>
  808cf1:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808cf6:	89 c2                	mov    %eax,%edx
  808cf8:	eb e4                	jmp    808cde <tcp_listen_with_backlog+0xa5>
  808cfa:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  808d01:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808d05:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808d0c:	e8 2f ea ff ff       	call   807740 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  808d11:	c7 46 20 80 87 80 00 	movl   $0x808780,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  808d18:	a1 10 e6 b3 00       	mov    0xb3e610,%eax
  808d1d:	89 46 0c             	mov    %eax,0xc(%esi)
  808d20:	89 35 10 e6 b3 00    	mov    %esi,0xb3e610
  808d26:	e8 52 c2 ff ff       	call   804f7d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  808d2b:	89 f0                	mov    %esi,%eax
}
  808d2d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808d30:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808d33:	89 ec                	mov    %ebp,%esp
  808d35:	5d                   	pop    %ebp
  808d36:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808d37:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808d3c:	eb bc                	jmp    808cfa <tcp_listen_with_backlog+0xc1>

00808d3e <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808d3e:	55                   	push   %ebp
  808d3f:	89 e5                	mov    %esp,%ebp
  808d41:	57                   	push   %edi
  808d42:	56                   	push   %esi
  808d43:	53                   	push   %ebx
  808d44:	83 ec 1c             	sub    $0x1c,%esp
  808d47:	8b 75 08             	mov    0x8(%ebp),%esi
  808d4a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  808d4d:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808d51:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808d55:	74 1c                	je     808d73 <tcp_bind+0x35>
  808d57:	c7 44 24 08 18 39 81 	movl   $0x813918,0x8(%esp)
  808d5e:	00 
  808d5f:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  808d66:	00 
  808d67:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808d6e:	e8 09 7c ff ff       	call   80097c <_panic>

  if (port == 0) {
  808d73:	66 85 c0             	test   %ax,%ax
  808d76:	75 05                	jne    808d7d <tcp_bind+0x3f>
    port = tcp_new_port();
  808d78:	e8 0d fa ff ff       	call   80878a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808d7d:	8b 15 10 e6 b3 00    	mov    0xb3e610,%edx
  808d83:	85 d2                	test   %edx,%edx
  808d85:	74 39                	je     808dc0 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808d87:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808d8b:	75 2c                	jne    808db9 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808d8d:	85 d2                	test   %edx,%edx
  808d8f:	0f 84 e1 00 00 00    	je     808e76 <tcp_bind+0x138>
  808d95:	8b 0a                	mov    (%edx),%ecx
  808d97:	85 c9                	test   %ecx,%ecx
  808d99:	0f 84 d7 00 00 00    	je     808e76 <tcp_bind+0x138>
  808d9f:	85 db                	test   %ebx,%ebx
  808da1:	0f 84 cf 00 00 00    	je     808e76 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808da7:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808da9:	85 ff                	test   %edi,%edi
  808dab:	0f 84 c5 00 00 00    	je     808e76 <tcp_bind+0x138>
  808db1:	39 f9                	cmp    %edi,%ecx
  808db3:	0f 84 bd 00 00 00    	je     808e76 <tcp_bind+0x138>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808db9:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808dbc:	85 d2                	test   %edx,%edx
  808dbe:	75 c7                	jne    808d87 <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808dc0:	8b 15 08 e6 b3 00    	mov    0xb3e608,%edx
  808dc6:	85 d2                	test   %edx,%edx
  808dc8:	74 35                	je     808dff <tcp_bind+0xc1>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808dca:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808dce:	75 28                	jne    808df8 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808dd0:	85 d2                	test   %edx,%edx
  808dd2:	0f 84 9e 00 00 00    	je     808e76 <tcp_bind+0x138>
  808dd8:	8b 0a                	mov    (%edx),%ecx
  808dda:	85 c9                	test   %ecx,%ecx
  808ddc:	0f 84 94 00 00 00    	je     808e76 <tcp_bind+0x138>
  808de2:	85 db                	test   %ebx,%ebx
  808de4:	0f 84 8c 00 00 00    	je     808e76 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808dea:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808dec:	85 ff                	test   %edi,%edi
  808dee:	0f 84 82 00 00 00    	je     808e76 <tcp_bind+0x138>
  808df4:	39 f9                	cmp    %edi,%ecx
  808df6:	74 7e                	je     808e76 <tcp_bind+0x138>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808df8:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808dfb:	85 d2                	test   %edx,%edx
  808dfd:	75 cb                	jne    808dca <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808dff:	8b 15 18 e6 b3 00    	mov    0xb3e618,%edx
  808e05:	85 d2                	test   %edx,%edx
  808e07:	74 25                	je     808e2e <tcp_bind+0xf0>
    if (cpcb->local_port == port) {
  808e09:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808e0d:	75 18                	jne    808e27 <tcp_bind+0xe9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e0f:	85 d2                	test   %edx,%edx
  808e11:	74 63                	je     808e76 <tcp_bind+0x138>
  808e13:	8b 0a                	mov    (%edx),%ecx
  808e15:	85 c9                	test   %ecx,%ecx
  808e17:	74 5d                	je     808e76 <tcp_bind+0x138>
  808e19:	85 db                	test   %ebx,%ebx
  808e1b:	74 59                	je     808e76 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808e1d:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e1f:	85 ff                	test   %edi,%edi
  808e21:	74 53                	je     808e76 <tcp_bind+0x138>
  808e23:	39 f9                	cmp    %edi,%ecx
  808e25:	74 4f                	je     808e76 <tcp_bind+0x138>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808e27:	8b 52 0c             	mov    0xc(%edx),%edx
  808e2a:	85 d2                	test   %edx,%edx
  808e2c:	75 db                	jne    808e09 <tcp_bind+0xcb>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808e2e:	8b 15 1c e6 b3 00    	mov    0xb3e61c,%edx
  808e34:	85 d2                	test   %edx,%edx
  808e36:	74 13                	je     808e4b <tcp_bind+0x10d>
    if (cpcb->local_port == port) {
  808e38:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808e3c:	75 06                	jne    808e44 <tcp_bind+0x106>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  808e3e:	8b 0a                	mov    (%edx),%ecx
  808e40:	3b 0b                	cmp    (%ebx),%ecx
  808e42:	74 32                	je     808e76 <tcp_bind+0x138>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808e44:	8b 52 0c             	mov    0xc(%edx),%edx
  808e47:	85 d2                	test   %edx,%edx
  808e49:	75 ed                	jne    808e38 <tcp_bind+0xfa>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  808e4b:	85 db                	test   %ebx,%ebx
  808e4d:	74 09                	je     808e58 <tcp_bind+0x11a>
  808e4f:	83 3b 00             	cmpl   $0x0,(%ebx)
  808e52:	74 04                	je     808e58 <tcp_bind+0x11a>
    pcb->local_ip = *ipaddr;
  808e54:	8b 13                	mov    (%ebx),%edx
  808e56:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  808e58:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  808e5c:	a1 18 e6 b3 00       	mov    0xb3e618,%eax
  808e61:	89 46 0c             	mov    %eax,0xc(%esi)
  808e64:	89 35 18 e6 b3 00    	mov    %esi,0xb3e618
  808e6a:	e8 0e c1 ff ff       	call   804f7d <tcp_timer_needed>
  808e6f:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808e74:	eb 05                	jmp    808e7b <tcp_bind+0x13d>
  808e76:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  808e7b:	83 c4 1c             	add    $0x1c,%esp
  808e7e:	5b                   	pop    %ebx
  808e7f:	5e                   	pop    %esi
  808e80:	5f                   	pop    %edi
  808e81:	5d                   	pop    %ebp
  808e82:	c3                   	ret    

00808e83 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808e83:	55                   	push   %ebp
  808e84:	89 e5                	mov    %esp,%ebp
  808e86:	57                   	push   %edi
  808e87:	56                   	push   %esi
  808e88:	53                   	push   %ebx
  808e89:	83 ec 3c             	sub    $0x3c,%esp
  808e8c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808e8f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808e92:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808e96:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808e9a:	74 1c                	je     808eb8 <tcp_connect+0x35>
  808e9c:	c7 44 24 08 44 39 81 	movl   $0x813944,0x8(%esp)
  808ea3:	00 
  808ea4:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  808eab:	00 
  808eac:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  808eb3:	e8 c4 7a ff ff       	call   80097c <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808eb8:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  808ebd:	85 ff                	test   %edi,%edi
  808ebf:	0f 84 28 01 00 00    	je     808fed <tcp_connect+0x16a>
    pcb->remote_ip = *ipaddr;
  808ec5:	8b 17                	mov    (%edi),%edx
  808ec7:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  808eca:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  808ece:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808ed3:	75 09                	jne    808ede <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  808ed5:	e8 b0 f8 ff ff       	call   80878a <tcp_new_port>
  808eda:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  808ede:	e8 c9 f9 ff ff       	call   8088ac <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808ee3:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  808eea:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  808eed:	83 e8 01             	sub    $0x1,%eax
  808ef0:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  808ef3:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  808ef6:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  808efc:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  808f02:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808f08:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  808f0e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808f12:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  808f19:	e8 a3 f9 ff ff       	call   8088c1 <tcp_eff_send_mss>
  808f1e:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  808f22:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  808f28:	8d 04 80             	lea    (%eax,%eax,4),%eax
  808f2b:	01 c0                	add    %eax,%eax
  808f2d:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  808f31:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  808f38:	8b 45 14             	mov    0x14(%ebp),%eax
  808f3b:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808f41:	8b 15 18 e6 b3 00    	mov    0xb3e618,%edx
  808f47:	39 da                	cmp    %ebx,%edx
  808f49:	75 0a                	jne    808f55 <tcp_connect+0xd2>
  808f4b:	8b 42 0c             	mov    0xc(%edx),%eax
  808f4e:	a3 18 e6 b3 00       	mov    %eax,0xb3e618
  808f53:	eb 2a                	jmp    808f7f <tcp_connect+0xfc>
  808f55:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  808f5b:	85 d2                	test   %edx,%edx
  808f5d:	74 20                	je     808f7f <tcp_connect+0xfc>
  808f5f:	8b 42 0c             	mov    0xc(%edx),%eax
  808f62:	85 c0                	test   %eax,%eax
  808f64:	0f 84 8d 00 00 00    	je     808ff7 <tcp_connect+0x174>
  808f6a:	39 c3                	cmp    %eax,%ebx
  808f6c:	75 08                	jne    808f76 <tcp_connect+0xf3>
  808f6e:	8b 43 0c             	mov    0xc(%ebx),%eax
  808f71:	89 42 0c             	mov    %eax,0xc(%edx)
  808f74:	eb 09                	jmp    808f7f <tcp_connect+0xfc>
  808f76:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808f7b:	89 c2                	mov    %eax,%edx
  808f7d:	eb e0                	jmp    808f5f <tcp_connect+0xdc>
  808f7f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  808f86:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  808f8b:	89 43 0c             	mov    %eax,0xc(%ebx)
  808f8e:	89 1d 08 e6 b3 00    	mov    %ebx,0xb3e608
  808f94:	e8 e4 bf ff ff       	call   804f7d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  808f99:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  808fa0:	e8 50 1d 00 00       	call   80acf5 <htonl>
  808fa5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  808fa8:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  808faf:	00 
  808fb0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808fb3:	89 44 24 14          	mov    %eax,0x14(%esp)
  808fb7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808fbe:	00 
  808fbf:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  808fc6:	00 
  808fc7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808fce:	00 
  808fcf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808fd6:	00 
  808fd7:	89 1c 24             	mov    %ebx,(%esp)
  808fda:	e8 c9 28 00 00       	call   80b8a8 <tcp_enqueue>
  808fdf:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  808fe1:	84 c0                	test   %al,%al
  808fe3:	75 08                	jne    808fed <tcp_connect+0x16a>
    tcp_output(pcb);
  808fe5:	89 1c 24             	mov    %ebx,(%esp)
  808fe8:	e8 6e 23 00 00       	call   80b35b <tcp_output>
  }
  return ret;
} 
  808fed:	89 f0                	mov    %esi,%eax
  808fef:	83 c4 3c             	add    $0x3c,%esp
  808ff2:	5b                   	pop    %ebx
  808ff3:	5e                   	pop    %esi
  808ff4:	5f                   	pop    %edi
  808ff5:	5d                   	pop    %ebp
  808ff6:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808ff7:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  808ffc:	eb 81                	jmp    808f7f <tcp_connect+0xfc>

00808ffe <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808ffe:	55                   	push   %ebp
  808fff:	89 e5                	mov    %esp,%ebp
  809001:	57                   	push   %edi
  809002:	56                   	push   %esi
  809003:	53                   	push   %ebx
  809004:	83 ec 4c             	sub    $0x4c,%esp
  809007:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80900a:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80900e:	75 25                	jne    809035 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  809010:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809014:	c7 04 24 1c e6 b3 00 	movl   $0xb3e61c,(%esp)
  80901b:	e8 20 fb ff ff       	call   808b40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  809020:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809024:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80902b:	e8 10 e7 ff ff       	call   807740 <memp_free>
  809030:	e9 d1 00 00 00       	jmp    809106 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  809035:	8b 43 54             	mov    0x54(%ebx),%eax
  809038:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  80903b:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80903e:	b8 00 00 00 00       	mov    $0x0,%eax
  809043:	85 db                	test   %ebx,%ebx
  809045:	74 02                	je     809049 <tcp_abort+0x4b>
  809047:	8b 03                	mov    (%ebx),%eax
  809049:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80904c:	b8 00 00 00 00       	mov    $0x0,%eax
  809051:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809054:	74 03                	je     809059 <tcp_abort+0x5b>
  809056:	8b 43 04             	mov    0x4(%ebx),%eax
  809059:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80905c:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  809060:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  809064:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  809068:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80906c:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  809072:	8b 43 18             	mov    0x18(%ebx),%eax
  809075:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  809078:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80907c:	c7 04 24 08 e6 b3 00 	movl   $0xb3e608,(%esp)
  809083:	e8 b8 fa ff ff       	call   808b40 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  809088:	8b 43 78             	mov    0x78(%ebx),%eax
  80908b:	85 c0                	test   %eax,%eax
  80908d:	74 08                	je     809097 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  80908f:	89 04 24             	mov    %eax,(%esp)
  809092:	e8 ff f9 ff ff       	call   808a96 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  809097:	8b 43 74             	mov    0x74(%ebx),%eax
  80909a:	85 c0                	test   %eax,%eax
  80909c:	74 08                	je     8090a6 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  80909e:	89 04 24             	mov    %eax,(%esp)
  8090a1:	e8 f0 f9 ff ff       	call   808a96 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  8090a6:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8090a9:	85 c0                	test   %eax,%eax
  8090ab:	74 08                	je     8090b5 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  8090ad:	89 04 24             	mov    %eax,(%esp)
  8090b0:	e8 e1 f9 ff ff       	call   808a96 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  8090b5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8090b9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8090c0:	e8 7b e6 ff ff       	call   807740 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  8090c5:	85 f6                	test   %esi,%esi
  8090c7:	74 10                	je     8090d9 <tcp_abort+0xdb>
  8090c9:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8090d0:	ff 
  8090d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8090d4:	89 04 24             	mov    %eax,(%esp)
  8090d7:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  8090d9:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  8090dd:	89 44 24 14          	mov    %eax,0x14(%esp)
  8090e1:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  8090e5:	89 44 24 10          	mov    %eax,0x10(%esp)
  8090e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8090ec:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8090f0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8090f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8090f7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8090fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8090fe:	89 04 24             	mov    %eax,(%esp)
  809101:	e8 f6 20 00 00       	call   80b1fc <tcp_rst>
  }
}
  809106:	83 c4 4c             	add    $0x4c,%esp
  809109:	5b                   	pop    %ebx
  80910a:	5e                   	pop    %esi
  80910b:	5f                   	pop    %edi
  80910c:	5d                   	pop    %ebp
  80910d:	c3                   	ret    

0080910e <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80910e:	55                   	push   %ebp
  80910f:	89 e5                	mov    %esp,%ebp
  809111:	83 ec 38             	sub    $0x38,%esp
  809114:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809117:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80911a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80911d:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  809121:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809128:	e8 57 e6 ff ff       	call   807784 <memp_malloc>
  80912d:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80912f:	85 c0                	test   %eax,%eax
  809131:	0f 85 c9 00 00 00    	jne    809200 <tcp_alloc+0xf2>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  809137:	a1 1c e6 b3 00       	mov    0xb3e61c,%eax
  80913c:	85 c0                	test   %eax,%eax
  80913e:	74 36                	je     809176 <tcp_alloc+0x68>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809140:	8b 1d 0c e6 b3 00    	mov    0xb3e60c,%ebx
  809146:	bf 00 00 00 00       	mov    $0x0,%edi
  80914b:	b9 00 00 00 00       	mov    $0x0,%ecx
  809150:	89 da                	mov    %ebx,%edx
  809152:	2b 50 2c             	sub    0x2c(%eax),%edx
  809155:	39 ca                	cmp    %ecx,%edx
  809157:	72 04                	jb     80915d <tcp_alloc+0x4f>
  809159:	89 c7                	mov    %eax,%edi
  80915b:	eb 02                	jmp    80915f <tcp_alloc+0x51>
  80915d:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80915f:	8b 40 0c             	mov    0xc(%eax),%eax
  809162:	85 c0                	test   %eax,%eax
  809164:	74 04                	je     80916a <tcp_alloc+0x5c>
  809166:	89 d1                	mov    %edx,%ecx
  809168:	eb e6                	jmp    809150 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  80916a:	85 ff                	test   %edi,%edi
  80916c:	74 08                	je     809176 <tcp_alloc+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80916e:	89 3c 24             	mov    %edi,(%esp)
  809171:	e8 88 fe ff ff       	call   808ffe <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  809176:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80917d:	e8 02 e6 ff ff       	call   807784 <memp_malloc>
  809182:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  809184:	85 c0                	test   %eax,%eax
  809186:	75 78                	jne    809200 <tcp_alloc+0xf2>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809188:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  80918d:	85 c0                	test   %eax,%eax
  80918f:	74 59                	je     8091ea <tcp_alloc+0xdc>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809191:	8b 15 0c e6 b3 00    	mov    0xb3e60c,%edx
  809197:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80919a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8091a1:	bf 00 00 00 00       	mov    $0x0,%edi
  8091a6:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8091ab:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  8091af:	89 f3                	mov    %esi,%ebx
  8091b1:	38 d3                	cmp    %dl,%bl
  8091b3:	72 13                	jb     8091c8 <tcp_alloc+0xba>
  8091b5:	38 ca                	cmp    %cl,%dl
  8091b7:	77 0f                	ja     8091c8 <tcp_alloc+0xba>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8091b9:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  8091bc:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8091bf:	39 df                	cmp    %ebx,%edi
  8091c1:	77 05                	ja     8091c8 <tcp_alloc+0xba>
  8091c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8091c6:	eb 04                	jmp    8091cc <tcp_alloc+0xbe>
  8091c8:	89 ca                	mov    %ecx,%edx
  8091ca:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8091cc:	8b 40 0c             	mov    0xc(%eax),%eax
  8091cf:	85 c0                	test   %eax,%eax
  8091d1:	74 06                	je     8091d9 <tcp_alloc+0xcb>
  8091d3:	89 df                	mov    %ebx,%edi
  8091d5:	89 d1                	mov    %edx,%ecx
  8091d7:	eb d2                	jmp    8091ab <tcp_alloc+0x9d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  8091d9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8091dd:	74 0b                	je     8091ea <tcp_alloc+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8091df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8091e2:	89 04 24             	mov    %eax,(%esp)
  8091e5:	e8 14 fe ff ff       	call   808ffe <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  8091ea:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8091f1:	e8 8e e5 ff ff       	call   807784 <memp_malloc>
  8091f6:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  8091f8:	85 c0                	test   %eax,%eax
  8091fa:	0f 84 9b 00 00 00    	je     80929b <tcp_alloc+0x18d>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  809200:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  809207:	00 
  809208:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80920f:	00 
  809210:	89 1c 24             	mov    %ebx,(%esp)
  809213:	e8 5e 80 ff ff       	call   801276 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  809218:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80921c:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  809222:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  809228:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80922e:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  809234:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  809238:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80923c:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  809242:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  809248:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80924e:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  809254:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  80925a:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  809260:	e8 47 f6 ff ff       	call   8088ac <tcp_next_iss>
    pcb->snd_wl2 = iss;
  809265:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  809268:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80926b:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80926e:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  809271:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  809274:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  809279:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  80927c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  809280:	c7 83 88 00 00 00 8f 	movl   $0x80988f,0x88(%ebx)
  809287:	98 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80928a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  809291:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  809294:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  80929b:	89 d8                	mov    %ebx,%eax
  80929d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8092a0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8092a3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8092a6:	89 ec                	mov    %ebp,%esp
  8092a8:	5d                   	pop    %ebp
  8092a9:	c3                   	ret    

008092aa <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8092aa:	55                   	push   %ebp
  8092ab:	89 e5                	mov    %esp,%ebp
  8092ad:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8092b0:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8092b7:	e8 52 fe ff ff       	call   80910e <tcp_alloc>
}
  8092bc:	c9                   	leave  
  8092bd:	c3                   	ret    

008092be <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  8092be:	55                   	push   %ebp
  8092bf:	89 e5                	mov    %esp,%ebp
  8092c1:	57                   	push   %edi
  8092c2:	56                   	push   %esi
  8092c3:	53                   	push   %ebx
  8092c4:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  8092c7:	83 05 0c e6 b3 00 01 	addl   $0x1,0xb3e60c

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  8092ce:	8b 1d 08 e6 b3 00    	mov    0xb3e608,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8092d4:	85 db                	test   %ebx,%ebx
  8092d6:	0f 84 5f 03 00 00    	je     80963b <tcp_slowtmr+0x37d>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  8092dc:	8b 43 10             	mov    0x10(%ebx),%eax
  8092df:	85 c0                	test   %eax,%eax
  8092e1:	74 1c                	je     8092ff <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8092e3:	83 f8 01             	cmp    $0x1,%eax
  8092e6:	74 38                	je     809320 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8092e8:	83 f8 0a             	cmp    $0xa,%eax
  8092eb:	74 54                	je     809341 <tcp_slowtmr+0x83>
  8092ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  8092f1:	bf 00 00 00 00       	mov    $0x0,%edi
  8092f6:	eb 67                	jmp    80935f <tcp_slowtmr+0xa1>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  8092f8:	8b 46 10             	mov    0x10(%esi),%eax
  8092fb:	85 c0                	test   %eax,%eax
  8092fd:	75 1c                	jne    80931b <tcp_slowtmr+0x5d>
  8092ff:	c7 44 24 08 78 39 81 	movl   $0x813978,0x8(%esp)
  809306:	00 
  809307:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  80930e:	00 
  80930f:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  809316:	e8 61 76 ff ff       	call   80097c <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80931b:	83 f8 01             	cmp    $0x1,%eax
  80931e:	75 1c                	jne    80933c <tcp_slowtmr+0x7e>
  809320:	c7 44 24 08 a4 39 81 	movl   $0x8139a4,0x8(%esp)
  809327:	00 
  809328:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  80932f:	00 
  809330:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  809337:	e8 40 76 ff ff       	call   80097c <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80933c:	83 f8 0a             	cmp    $0xa,%eax
  80933f:	75 1c                	jne    80935d <tcp_slowtmr+0x9f>
  809341:	c7 44 24 08 d0 39 81 	movl   $0x8139d0,0x8(%esp)
  809348:	00 
  809349:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  809350:	00 
  809351:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  809358:	e8 1f 76 ff ff       	call   80097c <_panic>
  80935d:	89 f3                	mov    %esi,%ebx

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80935f:	83 f8 02             	cmp    $0x2,%eax
  809362:	75 0a                	jne    80936e <tcp_slowtmr+0xb0>
  809364:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  809368:	0f 84 f1 00 00 00    	je     80945f <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80936e:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  809372:	0f 84 e7 00 00 00    	je     80945f <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  809378:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80937f:	90                   	nop
  809380:	74 55                	je     8093d7 <tcp_slowtmr+0x119>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  809382:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  809388:	83 c0 01             	add    $0x1,%eax
  80938b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  809391:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  809398:	0f b6 92 04 3b 81 00 	movzbl 0x813b04(%edx),%edx
  80939f:	39 d0                	cmp    %edx,%eax
  8093a1:	0f 82 bf 00 00 00    	jb     809466 <tcp_slowtmr+0x1a8>
          pcb->persist_cnt = 0;
  8093a7:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  8093ae:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  8093b1:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  8093b8:	3c 06                	cmp    $0x6,%al
  8093ba:	77 09                	ja     8093c5 <tcp_slowtmr+0x107>
            pcb->persist_backoff++;
  8093bc:	83 c0 01             	add    $0x1,%eax
  8093bf:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  8093c5:	89 1c 24             	mov    %ebx,(%esp)
  8093c8:	e8 63 1b 00 00       	call   80af30 <tcp_zero_window_probe>
  8093cd:	be 00 00 00 00       	mov    $0x0,%esi
  8093d2:	e9 94 00 00 00       	jmp    80946b <tcp_slowtmr+0x1ad>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  8093d7:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  8093db:	66 85 c0             	test   %ax,%ax
  8093de:	78 07                	js     8093e7 <tcp_slowtmr+0x129>
          ++pcb->rtime;
  8093e0:	83 c0 01             	add    $0x1,%eax
  8093e3:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  8093e7:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8093eb:	74 79                	je     809466 <tcp_slowtmr+0x1a8>
  8093ed:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  8093f1:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  8093f5:	7c 6f                	jl     809466 <tcp_slowtmr+0x1a8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  8093f7:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  8093fb:	74 20                	je     80941d <tcp_slowtmr+0x15f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  8093fd:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  809401:	66 c1 f8 03          	sar    $0x3,%ax
  809405:	98                   	cwtl   
  809406:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  80940a:	01 d0                	add    %edx,%eax
  80940c:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  809410:	0f b6 8a f8 3a 81 00 	movzbl 0x813af8(%edx),%ecx
  809417:	d3 e0                	shl    %cl,%eax
  809419:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80941d:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  809423:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  809427:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80942b:	66 39 d0             	cmp    %dx,%ax
  80942e:	76 02                	jbe    809432 <tcp_slowtmr+0x174>
  809430:	89 d0                	mov    %edx,%eax
  809432:	66 d1 e8             	shr    %ax
  809435:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  809439:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80943d:	66 39 d0             	cmp    %dx,%ax
  809440:	73 06                	jae    809448 <tcp_slowtmr+0x18a>
            pcb->ssthresh = pcb->mss * 2;
  809442:	01 d2                	add    %edx,%edx
  809444:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  809448:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80944c:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  809450:	89 1c 24             	mov    %ebx,(%esp)
  809453:	e8 fb 23 00 00       	call   80b853 <tcp_rexmit_rto>
  809458:	be 00 00 00 00       	mov    $0x0,%esi
  80945d:	eb 0c                	jmp    80946b <tcp_slowtmr+0x1ad>
  80945f:	be 01 00 00 00       	mov    $0x1,%esi
  809464:	eb 05                	jmp    80946b <tcp_slowtmr+0x1ad>
  809466:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80946b:	8b 43 10             	mov    0x10(%ebx),%eax
  80946e:	83 f8 06             	cmp    $0x6,%eax
  809471:	75 13                	jne    809486 <tcp_slowtmr+0x1c8>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  809473:	8b 15 0c e6 b3 00    	mov    0xb3e60c,%edx
  809479:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80947c:	83 fa 29             	cmp    $0x29,%edx
  80947f:	89 f2                	mov    %esi,%edx
  809481:	80 da ff             	sbb    $0xff,%dl
  809484:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  809486:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80948a:	74 6a                	je     8094f6 <tcp_slowtmr+0x238>
  80948c:	83 f8 04             	cmp    $0x4,%eax
  80948f:	74 05                	je     809496 <tcp_slowtmr+0x1d8>
  809491:	83 f8 07             	cmp    $0x7,%eax
  809494:	75 60                	jne    8094f6 <tcp_slowtmr+0x238>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809496:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  80949b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80949e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  8094a1:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  8094a7:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  8094ad:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8094b2:	f7 e2                	mul    %edx
  8094b4:	c1 ea 05             	shr    $0x5,%edx
  8094b7:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8094ba:	76 0a                	jbe    8094c6 <tcp_slowtmr+0x208>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  8094bc:	89 1c 24             	mov    %ebx,(%esp)
  8094bf:	e8 3a fb ff ff       	call   808ffe <tcp_abort>
  8094c4:	eb 30                	jmp    8094f6 <tcp_slowtmr+0x238>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  8094c6:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  8094cd:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  8094d3:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
  8094d6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8094db:	89 c8                	mov    %ecx,%eax
  8094dd:	f7 e2                	mul    %edx
  8094df:	c1 ea 05             	shr    $0x5,%edx
  8094e2:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8094e5:	76 0f                	jbe    8094f6 <tcp_slowtmr+0x238>
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  8094e7:	89 1c 24             	mov    %ebx,(%esp)
  8094ea:	e8 b8 1b 00 00       	call   80b0a7 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  8094ef:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  8094f6:	8b 53 7c             	mov    0x7c(%ebx),%edx
  8094f9:	85 d2                	test   %edx,%edx
  8094fb:	74 25                	je     809522 <tcp_slowtmr+0x264>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  8094fd:	8b 0d 0c e6 b3 00    	mov    0xb3e60c,%ecx
  809503:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  809506:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  80950a:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80950d:	01 c0                	add    %eax,%eax
  80950f:	39 c1                	cmp    %eax,%ecx
  809511:	72 0f                	jb     809522 <tcp_slowtmr+0x264>
      tcp_segs_free(pcb->ooseq);
  809513:	89 14 24             	mov    %edx,(%esp)
  809516:	e8 7b f5 ff ff       	call   808a96 <tcp_segs_free>
      pcb->ooseq = NULL;
  80951b:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  809522:	8b 43 10             	mov    0x10(%ebx),%eax
  809525:	83 f8 03             	cmp    $0x3,%eax
  809528:	75 13                	jne    80953d <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80952a:	8b 15 0c e6 b3 00    	mov    0xb3e60c,%edx
  809530:	2b 53 2c             	sub    0x2c(%ebx),%edx
  809533:	83 fa 28             	cmp    $0x28,%edx
  809536:	76 05                	jbe    80953d <tcp_slowtmr+0x27f>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  809538:	83 c6 01             	add    $0x1,%esi
  80953b:	eb 19                	jmp    809556 <tcp_slowtmr+0x298>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80953d:	83 f8 09             	cmp    $0x9,%eax
  809540:	75 14                	jne    809556 <tcp_slowtmr+0x298>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  809542:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  809547:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  80954a:	3d f1 00 00 00       	cmp    $0xf1,%eax
  80954f:	89 f2                	mov    %esi,%edx
  809551:	80 da ff             	sbb    $0xff,%dl
  809554:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  809556:	89 f0                	mov    %esi,%eax
  809558:	84 c0                	test   %al,%al
  80955a:	0f 84 94 00 00 00    	je     8095f4 <tcp_slowtmr+0x336>
      tcp_pcb_purge(pcb);      
  809560:	89 1c 24             	mov    %ebx,(%esp)
  809563:	e8 5f f5 ff ff       	call   808ac7 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  809568:	85 ff                	test   %edi,%edi
  80956a:	74 2c                	je     809598 <tcp_slowtmr+0x2da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80956c:	3b 1d 08 e6 b3 00    	cmp    0xb3e608,%ebx
  809572:	75 1c                	jne    809590 <tcp_slowtmr+0x2d2>
  809574:	c7 44 24 08 00 3a 81 	movl   $0x813a00,0x8(%esp)
  80957b:	00 
  80957c:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809583:	00 
  809584:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  80958b:	e8 ec 73 ff ff       	call   80097c <_panic>
        prev->next = pcb->next;
  809590:	8b 43 0c             	mov    0xc(%ebx),%eax
  809593:	89 47 0c             	mov    %eax,0xc(%edi)
  809596:	eb 2d                	jmp    8095c5 <tcp_slowtmr+0x307>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  809598:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  80959d:	39 d8                	cmp    %ebx,%eax
  80959f:	74 1c                	je     8095bd <tcp_slowtmr+0x2ff>
  8095a1:	c7 44 24 08 2c 3a 81 	movl   $0x813a2c,0x8(%esp)
  8095a8:	00 
  8095a9:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  8095b0:	00 
  8095b1:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  8095b8:	e8 bf 73 ff ff       	call   80097c <_panic>
        tcp_active_pcbs = pcb->next;
  8095bd:	8b 40 0c             	mov    0xc(%eax),%eax
  8095c0:	a3 08 e6 b3 00       	mov    %eax,0xb3e608
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8095c5:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  8095cb:	85 c0                	test   %eax,%eax
  8095cd:	74 10                	je     8095df <tcp_slowtmr+0x321>
  8095cf:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8095d6:	ff 
  8095d7:	8b 53 18             	mov    0x18(%ebx),%edx
  8095da:	89 14 24             	mov    %edx,(%esp)
  8095dd:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  8095df:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  8095e2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8095e6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8095ed:	e8 4e e1 ff ff       	call   807740 <memp_free>
  8095f2:	eb 3f                	jmp    809633 <tcp_slowtmr+0x375>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  8095f4:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  8095f8:	83 c0 01             	add    $0x1,%eax
  8095fb:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  8095fe:	3a 43 31             	cmp    0x31(%ebx),%al
  809601:	72 2b                	jb     80962e <tcp_slowtmr+0x370>
        pcb->polltmr = 0;
  809603:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  809607:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80960d:	85 c0                	test   %eax,%eax
  80960f:	74 0f                	je     809620 <tcp_slowtmr+0x362>
  809611:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809615:	8b 53 18             	mov    0x18(%ebx),%edx
  809618:	89 14 24             	mov    %edx,(%esp)
  80961b:	ff d0                	call   *%eax
  80961d:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  809620:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  809624:	75 08                	jne    80962e <tcp_slowtmr+0x370>
          tcp_output(pcb);
  809626:	89 1c 24             	mov    %ebx,(%esp)
  809629:	e8 2d 1d 00 00       	call   80b35b <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  80962e:	8b 73 0c             	mov    0xc(%ebx),%esi
  809631:	89 df                	mov    %ebx,%edi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  809633:	85 f6                	test   %esi,%esi
  809635:	0f 85 bd fc ff ff    	jne    8092f8 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  80963b:	8b 1d 1c e6 b3 00    	mov    0xb3e61c,%ebx
  while (pcb != NULL) {
  809641:	85 db                	test   %ebx,%ebx
  809643:	0f 84 c7 00 00 00    	je     809710 <tcp_slowtmr+0x452>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  809649:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80964d:	75 0d                	jne    80965c <tcp_slowtmr+0x39e>
  80964f:	be 00 00 00 00       	mov    $0x0,%esi
  809654:	eb 24                	jmp    80967a <tcp_slowtmr+0x3bc>
  809656:	83 7f 10 0a          	cmpl   $0xa,0x10(%edi)
  80965a:	74 1c                	je     809678 <tcp_slowtmr+0x3ba>
  80965c:	c7 44 24 08 58 3a 81 	movl   $0x813a58,0x8(%esp)
  809663:	00 
  809664:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  80966b:	00 
  80966c:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  809673:	e8 04 73 ff ff       	call   80097c <_panic>
  809678:	89 fb                	mov    %edi,%ebx
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80967a:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  80967f:	2b 43 2c             	sub    0x2c(%ebx),%eax
  809682:	3d f0 00 00 00       	cmp    $0xf0,%eax
  809687:	76 7a                	jbe    809703 <tcp_slowtmr+0x445>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  809689:	89 1c 24             	mov    %ebx,(%esp)
  80968c:	e8 36 f4 ff ff       	call   808ac7 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  809691:	85 f6                	test   %esi,%esi
  809693:	74 2c                	je     8096c1 <tcp_slowtmr+0x403>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809695:	3b 1d 1c e6 b3 00    	cmp    0xb3e61c,%ebx
  80969b:	75 1c                	jne    8096b9 <tcp_slowtmr+0x3fb>
  80969d:	c7 44 24 08 88 3a 81 	movl   $0x813a88,0x8(%esp)
  8096a4:	00 
  8096a5:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  8096ac:	00 
  8096ad:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  8096b4:	e8 c3 72 ff ff       	call   80097c <_panic>
        prev->next = pcb->next;
  8096b9:	8b 43 0c             	mov    0xc(%ebx),%eax
  8096bc:	89 46 0c             	mov    %eax,0xc(%esi)
  8096bf:	eb 2d                	jmp    8096ee <tcp_slowtmr+0x430>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8096c1:	a1 1c e6 b3 00       	mov    0xb3e61c,%eax
  8096c6:	39 d8                	cmp    %ebx,%eax
  8096c8:	74 1c                	je     8096e6 <tcp_slowtmr+0x428>
  8096ca:	c7 44 24 08 b0 3a 81 	movl   $0x813ab0,0x8(%esp)
  8096d1:	00 
  8096d2:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  8096d9:	00 
  8096da:	c7 04 24 af 38 81 00 	movl   $0x8138af,(%esp)
  8096e1:	e8 96 72 ff ff       	call   80097c <_panic>
        tcp_tw_pcbs = pcb->next;
  8096e6:	8b 40 0c             	mov    0xc(%eax),%eax
  8096e9:	a3 1c e6 b3 00       	mov    %eax,0xb3e61c
      }
      pcb2 = pcb->next;
  8096ee:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8096f1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8096f5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8096fc:	e8 3f e0 ff ff       	call   807740 <memp_free>
  809701:	eb 05                	jmp    809708 <tcp_slowtmr+0x44a>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  809703:	8b 7b 0c             	mov    0xc(%ebx),%edi
  809706:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  809708:	85 ff                	test   %edi,%edi
  80970a:	0f 85 46 ff ff ff    	jne    809656 <tcp_slowtmr+0x398>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  809710:	83 c4 2c             	add    $0x2c,%esp
  809713:	5b                   	pop    %ebx
  809714:	5e                   	pop    %esi
  809715:	5f                   	pop    %edi
  809716:	5d                   	pop    %ebp
  809717:	c3                   	ret    

00809718 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  809718:	55                   	push   %ebp
  809719:	89 e5                	mov    %esp,%ebp
  80971b:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80971e:	e8 68 f2 ff ff       	call   80898b <tcp_fasttmr>

  if (++tcp_timer & 1) {
  809723:	0f b6 05 a8 77 b3 00 	movzbl 0xb377a8,%eax
  80972a:	83 c0 01             	add    $0x1,%eax
  80972d:	a2 a8 77 b3 00       	mov    %al,0xb377a8
  809732:	a8 01                	test   $0x1,%al
  809734:	74 05                	je     80973b <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  809736:	e8 83 fb ff ff       	call   8092be <tcp_slowtmr>
  }
}
  80973b:	c9                   	leave  
  80973c:	c3                   	ret    

0080973d <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80973d:	55                   	push   %ebp
  80973e:	89 e5                	mov    %esp,%ebp
  809740:	53                   	push   %ebx
  809741:	83 ec 14             	sub    $0x14,%esp
  809744:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  809747:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80974b:	77 0a                	ja     809757 <tcp_close+0x1a>
  80974d:	8b 43 10             	mov    0x10(%ebx),%eax
  809750:	ff 24 85 d8 3a 81 00 	jmp    *0x813ad8(,%eax,4)
  809757:	bb 00 00 00 00       	mov    $0x0,%ebx
  80975c:	e9 05 01 00 00       	jmp    809866 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809761:	8b 15 18 e6 b3 00    	mov    0xb3e618,%edx
  809767:	39 da                	cmp    %ebx,%edx
  809769:	75 0a                	jne    809775 <tcp_close+0x38>
  80976b:	8b 42 0c             	mov    0xc(%edx),%eax
  80976e:	a3 18 e6 b3 00       	mov    %eax,0xb3e618
  809773:	eb 2a                	jmp    80979f <tcp_close+0x62>
  809775:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  80977b:	85 d2                	test   %edx,%edx
  80977d:	74 20                	je     80979f <tcp_close+0x62>
  80977f:	8b 42 0c             	mov    0xc(%edx),%eax
  809782:	85 c0                	test   %eax,%eax
  809784:	0f 84 fb 00 00 00    	je     809885 <tcp_close+0x148>
  80978a:	39 c3                	cmp    %eax,%ebx
  80978c:	75 08                	jne    809796 <tcp_close+0x59>
  80978e:	8b 43 0c             	mov    0xc(%ebx),%eax
  809791:	89 42 0c             	mov    %eax,0xc(%edx)
  809794:	eb 09                	jmp    80979f <tcp_close+0x62>
  809796:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  80979b:	89 c2                	mov    %eax,%edx
  80979d:	eb e0                	jmp    80977f <tcp_close+0x42>
  80979f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  8097a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097aa:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8097b1:	e8 8a df ff ff       	call   807740 <memp_free>
  8097b6:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  8097bb:	e9 bf 00 00 00       	jmp    80987f <tcp_close+0x142>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  8097c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097c4:	c7 04 24 10 e6 b3 00 	movl   $0xb3e610,(%esp)
  8097cb:	e8 70 f3 ff ff       	call   808b40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  8097d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097d4:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8097db:	e8 60 df ff ff       	call   807740 <memp_free>
  8097e0:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  8097e5:	e9 95 00 00 00       	jmp    80987f <tcp_close+0x142>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8097ea:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097ee:	c7 04 24 08 e6 b3 00 	movl   $0xb3e608,(%esp)
  8097f5:	e8 46 f3 ff ff       	call   808b40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8097fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097fe:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809805:	e8 36 df ff ff       	call   807740 <memp_free>
  80980a:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  80980f:	eb 6e                	jmp    80987f <tcp_close+0x142>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  809811:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809818:	00 
  809819:	89 1c 24             	mov    %ebx,(%esp)
  80981c:	e8 f7 27 00 00       	call   80c018 <tcp_send_ctrl>
    if (err == ERR_OK) {
  809821:	84 c0                	test   %al,%al
  809823:	75 5a                	jne    80987f <tcp_close+0x142>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  809825:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  80982c:	eb 38                	jmp    809866 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80982e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809835:	00 
  809836:	89 1c 24             	mov    %ebx,(%esp)
  809839:	e8 da 27 00 00       	call   80c018 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80983e:	84 c0                	test   %al,%al
  809840:	75 3d                	jne    80987f <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  809842:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  809849:	eb 1b                	jmp    809866 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80984b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809852:	00 
  809853:	89 1c 24             	mov    %ebx,(%esp)
  809856:	e8 bd 27 00 00       	call   80c018 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80985b:	84 c0                	test   %al,%al
  80985d:	75 20                	jne    80987f <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80985f:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  809866:	85 db                	test   %ebx,%ebx
  809868:	75 08                	jne    809872 <tcp_close+0x135>
  80986a:	b8 00 00 00 00       	mov    $0x0,%eax
  80986f:	90                   	nop
  809870:	eb 0d                	jmp    80987f <tcp_close+0x142>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  809872:	89 1c 24             	mov    %ebx,(%esp)
  809875:	e8 e1 1a 00 00       	call   80b35b <tcp_output>
  80987a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80987f:	83 c4 14             	add    $0x14,%esp
  809882:	5b                   	pop    %ebx
  809883:	5d                   	pop    %ebp
  809884:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809885:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  80988a:	e9 10 ff ff ff       	jmp    80979f <tcp_close+0x62>

0080988f <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80988f:	55                   	push   %ebp
  809890:	89 e5                	mov    %esp,%ebp
  809892:	83 ec 18             	sub    $0x18,%esp
  809895:	8b 45 10             	mov    0x10(%ebp),%eax
  809898:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80989c:	85 c0                	test   %eax,%eax
  80989e:	74 0f                	je     8098af <tcp_recv_null+0x20>
    pbuf_free(p);
  8098a0:	89 04 24             	mov    %eax,(%esp)
  8098a3:	e8 30 e6 ff ff       	call   807ed8 <pbuf_free>
  8098a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8098ad:	eb 14                	jmp    8098c3 <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  8098af:	b8 00 00 00 00       	mov    $0x0,%eax
  8098b4:	84 d2                	test   %dl,%dl
  8098b6:	75 0b                	jne    8098c3 <tcp_recv_null+0x34>
    return tcp_close(pcb);
  8098b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8098bb:	89 04 24             	mov    %eax,(%esp)
  8098be:	e8 7a fe ff ff       	call   80973d <tcp_close>
  }
  return ERR_OK;
}
  8098c3:	c9                   	leave  
  8098c4:	c3                   	ret    
  8098c5:	00 00                	add    %al,(%eax)
	...

008098c8 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8098c8:	55                   	push   %ebp
  8098c9:	89 e5                	mov    %esp,%ebp
  8098cb:	53                   	push   %ebx
  8098cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8098cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8098d2:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8098d4:	8d 5a ff             	lea    -0x1(%edx),%ebx
  8098d7:	b8 01 00 00 00       	mov    $0x1,%eax
  8098dc:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8098df:	77 26                	ja     809907 <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8098e1:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  8098e5:	74 1b                	je     809902 <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8098e7:	8b 41 04             	mov    0x4(%ecx),%eax
  8098ea:	39 d0                	cmp    %edx,%eax
  8098ec:	74 14                	je     809902 <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8098ee:	8b 49 08             	mov    0x8(%ecx),%ecx
  8098f1:	31 d0                	xor    %edx,%eax
  8098f3:	85 c8                	test   %ecx,%eax
  8098f5:	75 0b                	jne    809902 <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8098f7:	f7 d1                	not    %ecx
  8098f9:	21 ca                	and    %ecx,%edx
  8098fb:	39 d1                	cmp    %edx,%ecx
  8098fd:	0f 94 c0             	sete   %al
  809900:	eb 05                	jmp    809907 <ip_addr_isbroadcast+0x3f>
  809902:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  809907:	5b                   	pop    %ebx
  809908:	5d                   	pop    %ebp
  809909:	c3                   	ret    
  80990a:	00 00                	add    %al,(%eax)
  80990c:	00 00                	add    %al,(%eax)
	...

00809910 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  809910:	55                   	push   %ebp
  809911:	89 e5                	mov    %esp,%ebp
  809913:	83 ec 48             	sub    $0x48,%esp
  809916:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809919:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80991c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80991f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809922:	8b 7d 10             	mov    0x10(%ebp),%edi
  809925:	8b 75 20             	mov    0x20(%ebp),%esi
  809928:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80992c:	88 45 d8             	mov    %al,-0x28(%ebp)
  80992f:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  809933:	88 55 d7             	mov    %dl,-0x29(%ebp)
  809936:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  80993a:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80993d:	85 ff                	test   %edi,%edi
  80993f:	0f 84 3a 01 00 00    	je     809a7f <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  809945:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80994c:	00 
  80994d:	89 1c 24             	mov    %ebx,(%esp)
  809950:	e8 0e e2 ff ff       	call   807b63 <pbuf_header>
  809955:	89 c2                	mov    %eax,%edx
  809957:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80995c:	84 d2                	test   %dl,%dl
  80995e:	0f 85 50 01 00 00    	jne    809ab4 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809964:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  809967:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  80996c:	77 1c                	ja     80998a <ip_output_if+0x7a>
  80996e:	c7 44 24 08 14 3b 81 	movl   $0x813b14,0x8(%esp)
  809975:	00 
  809976:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  80997d:	00 
  80997e:	c7 04 24 41 3b 81 00 	movl   $0x813b41,(%esp)
  809985:	e8 f2 6f ff ff       	call   80097c <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80998a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80998d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809991:	89 04 24             	mov    %eax,(%esp)
  809994:	e8 48 13 00 00       	call   80ace1 <ntohs>
  809999:	0f b6 d0             	movzbl %al,%edx
  80999c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  8099a0:	c1 e0 08             	shl    $0x8,%eax
  8099a3:	09 d0                	or     %edx,%eax
  8099a5:	0f b7 c0             	movzwl %ax,%eax
  8099a8:	89 04 24             	mov    %eax,(%esp)
  8099ab:	e8 24 13 00 00       	call   80acd4 <htons>
  8099b0:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099b3:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  8099b7:	0f b7 c0             	movzwl %ax,%eax
  8099ba:	89 04 24             	mov    %eax,(%esp)
  8099bd:	e8 1f 13 00 00       	call   80ace1 <ntohs>
  8099c2:	89 c2                	mov    %eax,%edx
  8099c4:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8099ca:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  8099ce:	09 d0                	or     %edx,%eax
  8099d0:	0f b7 c0             	movzwl %ax,%eax
  8099d3:	89 04 24             	mov    %eax,(%esp)
  8099d6:	e8 f9 12 00 00       	call   80acd4 <htons>
  8099db:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099de:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  8099e2:	8b 07                	mov    (%edi),%eax
  8099e4:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8099e7:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  8099eb:	80 cc 45             	or     $0x45,%ah
  8099ee:	89 04 24             	mov    %eax,(%esp)
  8099f1:	e8 de 12 00 00       	call   80acd4 <htons>
  8099f6:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099f9:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8099fc:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809a00:	89 04 24             	mov    %eax,(%esp)
  809a03:	e8 cc 12 00 00       	call   80acd4 <htons>
  809a08:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a0b:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  809a0f:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  809a15:	0f b7 05 ac 77 b3 00 	movzwl 0xb377ac,%eax
  809a1c:	89 04 24             	mov    %eax,(%esp)
  809a1f:	e8 b0 12 00 00       	call   80acd4 <htons>
  809a24:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a27:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  809a2b:	66 83 05 ac 77 b3 00 	addw   $0x1,0xb377ac
  809a32:	01 

    if (ip_addr_isany(src)) {
  809a33:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  809a37:	74 09                	je     809a42 <ip_output_if+0x132>
  809a39:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a3c:	8b 02                	mov    (%edx),%eax
  809a3e:	85 c0                	test   %eax,%eax
  809a40:	75 15                	jne    809a57 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  809a42:	b8 00 00 00 00       	mov    $0x0,%eax
  809a47:	83 fe fc             	cmp    $0xfffffffc,%esi
  809a4a:	74 03                	je     809a4f <ip_output_if+0x13f>
  809a4c:	8b 46 04             	mov    0x4(%esi),%eax
  809a4f:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a52:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  809a55:	eb 06                	jmp    809a5d <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  809a57:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a5a:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  809a5d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  809a60:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809a66:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809a6d:	00 
  809a6e:	89 04 24             	mov    %eax,(%esp)
  809a71:	e8 44 0f 00 00       	call   80a9ba <inet_chksum>
  809a76:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a79:	66 89 42 0a          	mov    %ax,0xa(%edx)
  809a7d:	eb 06                	jmp    809a85 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  809a7f:	8b 7b 04             	mov    0x4(%ebx),%edi
  809a82:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  809a85:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  809a89:	66 85 c0             	test   %ax,%ax
  809a8c:	74 18                	je     809aa6 <ip_output_if+0x196>
  809a8e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  809a92:	73 12                	jae    809aa6 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  809a94:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809a98:	89 74 24 04          	mov    %esi,0x4(%esp)
  809a9c:	89 1c 24             	mov    %ebx,(%esp)
  809a9f:	e8 ac 03 00 00       	call   809e50 <ip_frag>
  809aa4:	eb 0e                	jmp    809ab4 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809aa6:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809aaa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809aae:	89 34 24             	mov    %esi,(%esp)
  809ab1:	ff 56 14             	call   *0x14(%esi)
  }
}
  809ab4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809ab7:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809aba:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809abd:	89 ec                	mov    %ebp,%esp
  809abf:	5d                   	pop    %ebp
  809ac0:	c3                   	ret    

00809ac1 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809ac1:	55                   	push   %ebp
  809ac2:	89 e5                	mov    %esp,%ebp
  809ac4:	56                   	push   %esi
  809ac5:	53                   	push   %ebx
  809ac6:	83 ec 10             	sub    $0x10,%esp
  809ac9:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809acc:	8b 1d 00 e6 b3 00    	mov    0xb3e600,%ebx
  809ad2:	85 db                	test   %ebx,%ebx
  809ad4:	74 1c                	je     809af2 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809ad6:	89 1c 24             	mov    %ebx,(%esp)
  809ad9:	e8 01 de ff ff       	call   8078df <netif_is_up>
  809ade:	84 c0                	test   %al,%al
  809ae0:	74 0a                	je     809aec <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809ae2:	8b 43 04             	mov    0x4(%ebx),%eax
  809ae5:	33 06                	xor    (%esi),%eax
  809ae7:	85 43 08             	test   %eax,0x8(%ebx)
  809aea:	74 28                	je     809b14 <ip_route+0x53>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809aec:	8b 1b                	mov    (%ebx),%ebx
  809aee:	85 db                	test   %ebx,%ebx
  809af0:	75 e4                	jne    809ad6 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  809af2:	a1 04 e6 b3 00       	mov    0xb3e604,%eax
  809af7:	85 c0                	test   %eax,%eax
  809af9:	74 14                	je     809b0f <ip_route+0x4e>
  809afb:	89 04 24             	mov    %eax,(%esp)
  809afe:	e8 dc dd ff ff       	call   8078df <netif_is_up>
  809b03:	84 c0                	test   %al,%al
  809b05:	74 08                	je     809b0f <ip_route+0x4e>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  809b07:	8b 1d 04 e6 b3 00    	mov    0xb3e604,%ebx
  809b0d:	eb 05                	jmp    809b14 <ip_route+0x53>
  809b0f:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  809b14:	89 d8                	mov    %ebx,%eax
  809b16:	83 c4 10             	add    $0x10,%esp
  809b19:	5b                   	pop    %ebx
  809b1a:	5e                   	pop    %esi
  809b1b:	5d                   	pop    %ebp
  809b1c:	c3                   	ret    

00809b1d <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  809b1d:	55                   	push   %ebp
  809b1e:	89 e5                	mov    %esp,%ebp
  809b20:	83 ec 48             	sub    $0x48,%esp
  809b23:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809b26:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809b29:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809b2c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  809b2f:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  809b33:	88 45 e7             	mov    %al,-0x19(%ebp)
  809b36:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  809b3a:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  809b3e:	89 1c 24             	mov    %ebx,(%esp)
  809b41:	e8 7b ff ff ff       	call   809ac1 <ip_route>
  809b46:	89 c2                	mov    %eax,%edx
  809b48:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809b4d:	85 d2                	test   %edx,%edx
  809b4f:	74 36                	je     809b87 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809b51:	89 54 24 18          	mov    %edx,0x18(%esp)
  809b55:	81 e6 ff 00 00 00    	and    $0xff,%esi
  809b5b:	89 74 24 14          	mov    %esi,0x14(%esp)
  809b5f:	81 e7 ff 00 00 00    	and    $0xff,%edi
  809b65:	89 7c 24 10          	mov    %edi,0x10(%esp)
  809b69:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  809b6d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809b71:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809b75:	8b 45 0c             	mov    0xc(%ebp),%eax
  809b78:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b7c:	8b 45 08             	mov    0x8(%ebp),%eax
  809b7f:	89 04 24             	mov    %eax,(%esp)
  809b82:	e8 89 fd ff ff       	call   809910 <ip_output_if>
}
  809b87:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809b8a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809b8d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809b90:	89 ec                	mov    %ebp,%esp
  809b92:	5d                   	pop    %ebp
  809b93:	c3                   	ret    

00809b94 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  809b94:	55                   	push   %ebp
  809b95:	89 e5                	mov    %esp,%ebp
  809b97:	83 ec 48             	sub    $0x48,%esp
  809b9a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809b9d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809ba0:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809ba3:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809ba6:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  809ba9:	0f b7 03             	movzwl (%ebx),%eax
  809bac:	89 04 24             	mov    %eax,(%esp)
  809baf:	e8 2d 11 00 00       	call   80ace1 <ntohs>
  809bb4:	66 c1 e8 0c          	shr    $0xc,%ax
  809bb8:	66 83 f8 04          	cmp    $0x4,%ax
  809bbc:	74 0d                	je     809bcb <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  809bbe:	89 34 24             	mov    %esi,(%esp)
  809bc1:	e8 12 e3 ff ff       	call   807ed8 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809bc6:	e9 72 02 00 00       	jmp    809e3d <ip_input+0x2a9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  809bcb:	0f b7 03             	movzwl (%ebx),%eax
  809bce:	89 04 24             	mov    %eax,(%esp)
  809bd1:	e8 0b 11 00 00       	call   80ace1 <ntohs>
  809bd6:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  809bda:	83 e0 3c             	and    $0x3c,%eax
  809bdd:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  809be1:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809be5:	89 04 24             	mov    %eax,(%esp)
  809be8:	e8 f4 10 00 00       	call   80ace1 <ntohs>
  809bed:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  809bef:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809bf3:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  809bf7:	77 06                	ja     809bff <ip_input+0x6b>
  809bf9:	66 3b 7e 08          	cmp    0x8(%esi),%di
  809bfd:	76 0d                	jbe    809c0c <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  809bff:	89 34 24             	mov    %esi,(%esp)
  809c02:	e8 d1 e2 ff ff       	call   807ed8 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  809c07:	e9 31 02 00 00       	jmp    809e3d <ip_input+0x2a9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  809c0c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809c10:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c14:	89 1c 24             	mov    %ebx,(%esp)
  809c17:	e8 9e 0d 00 00       	call   80a9ba <inet_chksum>
  809c1c:	66 85 c0             	test   %ax,%ax
  809c1f:	74 0d                	je     809c2e <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  809c21:	89 34 24             	mov    %esi,(%esp)
  809c24:	e8 af e2 ff ff       	call   807ed8 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809c29:	e9 0f 02 00 00       	jmp    809e3d <ip_input+0x2a9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  809c2e:	0f b7 ff             	movzwl %di,%edi
  809c31:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809c35:	89 34 24             	mov    %esi,(%esp)
  809c38:	e8 23 e4 ff ff       	call   808060 <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809c3d:	8d 43 10             	lea    0x10(%ebx),%eax
  809c40:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809c43:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809c46:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  809c4d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809c50:	89 de                	mov    %ebx,%esi
  809c52:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  809c57:	89 3c 24             	mov    %edi,(%esp)
  809c5a:	e8 80 dc ff ff       	call   8078df <netif_is_up>
  809c5f:	84 c0                	test   %al,%al
  809c61:	74 27                	je     809c8a <ip_input+0xf6>
  809c63:	83 ff fc             	cmp    $0xfffffffc,%edi
  809c66:	74 22                	je     809c8a <ip_input+0xf6>
  809c68:	8b 47 04             	mov    0x4(%edi),%eax
  809c6b:	85 c0                	test   %eax,%eax
  809c6d:	8d 76 00             	lea    0x0(%esi),%esi
  809c70:	74 18                	je     809c8a <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809c72:	3b 46 10             	cmp    0x10(%esi),%eax
  809c75:	74 36                	je     809cad <ip_input+0x119>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809c77:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809c7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  809c7e:	89 04 24             	mov    %eax,(%esp)
  809c81:	e8 42 fc ff ff       	call   8098c8 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809c86:	84 c0                	test   %al,%al
  809c88:	75 23                	jne    809cad <ip_input+0x119>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  809c8a:	85 db                	test   %ebx,%ebx
  809c8c:	74 08                	je     809c96 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  809c8e:	8b 3d 00 e6 b3 00    	mov    0xb3e600,%edi
  809c94:	eb 02                	jmp    809c98 <ip_input+0x104>
      } else {
        netif = netif->next;
  809c96:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  809c98:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  809c9b:	75 05                	jne    809ca2 <ip_input+0x10e>
        netif = netif->next;
  809c9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809ca0:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809ca2:	85 ff                	test   %edi,%edi
  809ca4:	74 12                	je     809cb8 <ip_input+0x124>
  809ca6:	bb 00 00 00 00       	mov    $0x0,%ebx
  809cab:	eb aa                	jmp    809c57 <ip_input+0xc3>
  809cad:	89 f3                	mov    %esi,%ebx
  809caf:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809cb2:	85 ff                	test   %edi,%edi
  809cb4:	75 2e                	jne    809ce4 <ip_input+0x150>
  809cb6:	eb 05                	jmp    809cbd <ip_input+0x129>
  809cb8:	89 f3                	mov    %esi,%ebx
  809cba:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  809cbd:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809cc1:	89 04 24             	mov    %eax,(%esp)
  809cc4:	e8 18 10 00 00       	call   80ace1 <ntohs>
  809cc9:	3c 11                	cmp    $0x11,%al
  809ccb:	75 17                	jne    809ce4 <ip_input+0x150>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  809ccd:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809cd1:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  809cd6:	89 04 24             	mov    %eax,(%esp)
  809cd9:	e8 03 10 00 00       	call   80ace1 <ntohs>
  809cde:	66 83 f8 44          	cmp    $0x44,%ax
  809ce2:	74 4e                	je     809d32 <ip_input+0x19e>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
  809ce7:	89 44 24 04          	mov    %eax,0x4(%esp)
  809ceb:	8d 43 0c             	lea    0xc(%ebx),%eax
  809cee:	89 04 24             	mov    %eax,(%esp)
  809cf1:	e8 d2 fb ff ff       	call   8098c8 <ip_addr_isbroadcast>
  809cf6:	84 c0                	test   %al,%al
  809cf8:	75 2b                	jne    809d25 <ip_input+0x191>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  809cfa:	8b 43 0c             	mov    0xc(%ebx),%eax
  809cfd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809d00:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809d07:	e8 0e 12 00 00       	call   80af1a <ntohl>
  809d0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809d0f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809d16:	e8 ff 11 00 00       	call   80af1a <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809d1b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809d1e:	23 55 dc             	and    -0x24(%ebp),%edx
  809d21:	39 c2                	cmp    %eax,%edx
  809d23:	75 10                	jne    809d35 <ip_input+0x1a1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  809d25:	89 34 24             	mov    %esi,(%esp)
  809d28:	e8 ab e1 ff ff       	call   807ed8 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  809d2d:	e9 0b 01 00 00       	jmp    809e3d <ip_input+0x2a9>
  809d32:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  809d35:	85 ff                	test   %edi,%edi
  809d37:	75 11                	jne    809d4a <ip_input+0x1b6>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  809d39:	89 34 24             	mov    %esi,(%esp)
  809d3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809d40:	e8 93 e1 ff ff       	call   807ed8 <pbuf_free>
    return ERR_OK;
  809d45:	e9 f3 00 00 00       	jmp    809e3d <ip_input+0x2a9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  809d4a:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  809d4e:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  809d55:	e8 7a 0f 00 00       	call   80acd4 <htons>
  809d5a:	66 85 f8             	test   %di,%ax
  809d5d:	74 15                	je     809d74 <ip_input+0x1e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  809d5f:	89 34 24             	mov    %esi,(%esp)
  809d62:	e8 4a 05 00 00       	call   80a2b1 <ip_reass>
  809d67:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809d69:	85 c0                	test   %eax,%eax
  809d6b:	0f 84 cc 00 00 00    	je     809e3d <ip_input+0x2a9>
      return ERR_OK;
    }
    iphdr = p->payload;
  809d71:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809d74:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d77:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d7b:	89 34 24             	mov    %esi,(%esp)
  809d7e:	e8 20 7e 00 00       	call   811ba3 <raw_input>
  809d83:	84 c0                	test   %al,%al
  809d85:	0f 85 b2 00 00 00    	jne    809e3d <ip_input+0x2a9>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  809d8b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809d8f:	89 04 24             	mov    %eax,(%esp)
  809d92:	e8 4a 0f 00 00       	call   80ace1 <ntohs>
  809d97:	0f b6 c0             	movzbl %al,%eax
  809d9a:	83 f8 06             	cmp    $0x6,%eax
  809d9d:	74 24                	je     809dc3 <ip_input+0x22f>
  809d9f:	83 f8 11             	cmp    $0x11,%eax
  809da2:	74 0e                	je     809db2 <ip_input+0x21e>
  809da4:	83 f8 01             	cmp    $0x1,%eax
  809da7:	75 3c                	jne    809de5 <ip_input+0x251>
  809da9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  809db0:	eb 22                	jmp    809dd4 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809db2:	8b 45 0c             	mov    0xc(%ebp),%eax
  809db5:	89 44 24 04          	mov    %eax,0x4(%esp)
  809db9:	89 34 24             	mov    %esi,(%esp)
  809dbc:	e8 c6 26 00 00       	call   80c487 <udp_input>
      break;
  809dc1:	eb 7a                	jmp    809e3d <ip_input+0x2a9>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809dc3:	8b 45 0c             	mov    0xc(%ebp),%eax
  809dc6:	89 44 24 04          	mov    %eax,0x4(%esp)
  809dca:	89 34 24             	mov    %esi,(%esp)
  809dcd:	e8 95 6d 00 00       	call   810b67 <tcp_input>
      break;
  809dd2:	eb 69                	jmp    809e3d <ip_input+0x2a9>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  809dd4:	8b 45 0c             	mov    0xc(%ebp),%eax
  809dd7:	89 44 24 04          	mov    %eax,0x4(%esp)
  809ddb:	89 34 24             	mov    %esi,(%esp)
  809dde:	e8 91 80 00 00       	call   811e74 <icmp_input>
      break;
  809de3:	eb 58                	jmp    809e3d <ip_input+0x2a9>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809de5:	8b 45 0c             	mov    0xc(%ebp),%eax
  809de8:	89 44 24 04          	mov    %eax,0x4(%esp)
  809dec:	8d 43 10             	lea    0x10(%ebx),%eax
  809def:	89 04 24             	mov    %eax,(%esp)
  809df2:	e8 d1 fa ff ff       	call   8098c8 <ip_addr_isbroadcast>
  809df7:	84 c0                	test   %al,%al
  809df9:	75 3a                	jne    809e35 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  809dfb:	8b 43 10             	mov    0x10(%ebx),%eax
  809dfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809e01:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809e08:	e8 0d 11 00 00       	call   80af1a <ntohl>
  809e0d:	89 c7                	mov    %eax,%edi
  809e0f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809e16:	e8 ff 10 00 00       	call   80af1a <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809e1b:	23 7d e4             	and    -0x1c(%ebp),%edi
  809e1e:	39 c7                	cmp    %eax,%edi
  809e20:	74 13                	je     809e35 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  809e22:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  809e25:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  809e2c:	00 
  809e2d:	89 34 24             	mov    %esi,(%esp)
  809e30:	e8 2d 7f 00 00       	call   811d62 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  809e35:	89 34 24             	mov    %esi,(%esp)
  809e38:	e8 9b e0 ff ff       	call   807ed8 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  809e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  809e42:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809e45:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809e48:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809e4b:	89 ec                	mov    %ebp,%esp
  809e4d:	5d                   	pop    %ebp
  809e4e:	c3                   	ret    
	...

00809e50 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809e50:	55                   	push   %ebp
  809e51:	89 e5                	mov    %esp,%ebp
  809e53:	57                   	push   %edi
  809e54:	56                   	push   %esi
  809e55:	53                   	push   %ebx
  809e56:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809e59:	8b 45 0c             	mov    0xc(%ebp),%eax
  809e5c:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809e60:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809e67:	00 
  809e68:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809e6f:	00 
  809e70:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809e77:	e8 17 e3 ff ff       	call   808193 <pbuf_alloc>
  809e7c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  809e7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e84:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  809e88:	0f 84 ca 01 00 00    	je     80a058 <ip_frag+0x208>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  809e8e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809e91:	66 89 72 0a          	mov    %si,0xa(%edx)
  809e95:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809e99:	bb e3 77 b3 00       	mov    $0xb377e3,%ebx
  809e9e:	83 e3 fc             	and    $0xfffffffc,%ebx
  809ea1:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809ea4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809eab:	00 
  809eac:	8b 55 08             	mov    0x8(%ebp),%edx
  809eaf:	8b 42 04             	mov    0x4(%edx),%eax
  809eb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  809eb6:	89 1c 24             	mov    %ebx,(%esp)
  809eb9:	e8 93 74 ff ff       	call   801351 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  809ebe:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809ec2:	89 04 24             	mov    %eax,(%esp)
  809ec5:	e8 17 0e 00 00       	call   80ace1 <ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  809eca:	89 c2                	mov    %eax,%edx
  809ecc:	66 81 e2 00 20       	and    $0x2000,%dx
  809ed1:	66 89 55 d2          	mov    %dx,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  809ed5:	8b 55 08             	mov    0x8(%ebp),%edx
  809ed8:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  809edc:	0f b7 f6             	movzwl %si,%esi
  809edf:	83 ee 14             	sub    $0x14,%esi
  809ee2:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809ee5:	89 f2                	mov    %esi,%edx
  809ee7:	c1 fa 1f             	sar    $0x1f,%edx
  809eea:	c1 ea 1d             	shr    $0x1d,%edx
  809eed:	01 f2                	add    %esi,%edx
  809eef:	c1 ea 03             	shr    $0x3,%edx
  809ef2:	66 89 55 b8          	mov    %dx,-0x48(%ebp)

  while (left) {
  809ef6:	66 83 e9 14          	sub    $0x14,%cx
  809efa:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  809efe:	0f 84 44 01 00 00    	je     80a048 <ip_frag+0x1f8>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  809f04:	66 25 ff 1f          	and    $0x1fff,%ax
  809f08:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  809f0c:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  809f12:	c1 e2 03             	shl    $0x3,%edx
  809f15:	66 89 55 b2          	mov    %dx,-0x4e(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809f19:	8d 43 14             	lea    0x14(%ebx),%eax
  809f1c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  809f1f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809f23:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  809f26:	0f 9d c0             	setge  %al
  809f29:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  809f2c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809f30:	66 25 ff 1f          	and    $0x1fff,%ax
  809f34:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  809f38:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  809f3c:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  809f40:	66 85 f6             	test   %si,%si
  809f43:	75 0a                	jne    809f4f <ip_frag+0xff>
      tmp = tmp | IP_MF;
  809f45:	66 81 4d e4 00 20    	orw    $0x2000,-0x1c(%ebp)
  809f4b:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809f4f:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  809f53:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809f57:	0f b7 c7             	movzwl %di,%eax
  809f5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  809f5e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  809f61:	89 54 24 04          	mov    %edx,0x4(%esp)
  809f65:	8b 45 08             	mov    0x8(%ebp),%eax
  809f68:	89 04 24             	mov    %eax,(%esp)
  809f6b:	e8 e6 dc ff ff       	call   807c56 <pbuf_copy_partial>
  809f70:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809f74:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809f78:	89 04 24             	mov    %eax,(%esp)
  809f7b:	e8 54 0d 00 00       	call   80acd4 <htons>
  809f80:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  809f84:	8d 47 14             	lea    0x14(%edi),%eax
  809f87:	0f b7 c0             	movzwl %ax,%eax
  809f8a:	89 04 24             	mov    %eax,(%esp)
  809f8d:	e8 42 0d 00 00       	call   80acd4 <htons>
  809f92:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  809f96:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809f9c:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809fa3:	00 
  809fa4:	89 1c 24             	mov    %ebx,(%esp)
  809fa7:	e8 0e 0a 00 00       	call   80a9ba <inet_chksum>
  809fac:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  809fb0:	66 85 f6             	test   %si,%si
  809fb3:	74 19                	je     809fce <ip_frag+0x17e>
      pbuf_realloc(rambuf, left + IP_HLEN);
  809fb5:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809fb9:	83 c0 14             	add    $0x14,%eax
  809fbc:	0f b7 c0             	movzwl %ax,%eax
  809fbf:	89 44 24 04          	mov    %eax,0x4(%esp)
  809fc3:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809fc6:	89 14 24             	mov    %edx,(%esp)
  809fc9:	e8 92 e0 ff ff       	call   808060 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  809fce:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809fd5:	00 
  809fd6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809fdd:	00 
  809fde:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809fe5:	e8 a9 e1 ff ff       	call   808193 <pbuf_alloc>
  809fea:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  809fec:	85 c0                	test   %eax,%eax
  809fee:	74 46                	je     80a036 <ip_frag+0x1e6>
      pbuf_chain(header, rambuf);
  809ff0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809ff3:	89 44 24 04          	mov    %eax,0x4(%esp)
  809ff7:	89 34 24             	mov    %esi,(%esp)
  809ffa:	e8 3d db ff ff       	call   807b3c <pbuf_chain>
      netif->output(netif, header, dest);
  809fff:	8b 55 10             	mov    0x10(%ebp),%edx
  80a002:	89 54 24 08          	mov    %edx,0x8(%esp)
  80a006:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a00a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a00d:	89 04 24             	mov    %eax,(%esp)
  80a010:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80a013:	89 34 24             	mov    %esi,(%esp)
  80a016:	e8 bd de ff ff       	call   807ed8 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80a01b:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  80a01f:	74 27                	je     80a048 <ip_frag+0x1f8>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80a021:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80a025:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  80a029:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  80a02d:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  80a031:	e9 e9 fe ff ff       	jmp    809f1f <ip_frag+0xcf>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80a036:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a039:	89 04 24             	mov    %eax,(%esp)
  80a03c:	e8 97 de ff ff       	call   807ed8 <pbuf_free>
  80a041:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  80a046:	eb 10                	jmp    80a058 <ip_frag+0x208>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80a048:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a04b:	89 14 24             	mov    %edx,(%esp)
  80a04e:	e8 85 de ff ff       	call   807ed8 <pbuf_free>
  80a053:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  80a058:	83 c4 5c             	add    $0x5c,%esp
  80a05b:	5b                   	pop    %ebx
  80a05c:	5e                   	pop    %esi
  80a05d:	5f                   	pop    %edi
  80a05e:	5d                   	pop    %ebp
  80a05f:	c3                   	ret    

0080a060 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a060:	55                   	push   %ebp
  80a061:	89 e5                	mov    %esp,%ebp
  80a063:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  80a066:	8b 0d c0 77 b3 00    	mov    0xb377c0,%ecx
  80a06c:	39 c1                	cmp    %eax,%ecx
  80a06e:	75 0a                	jne    80a07a <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  80a070:	8b 11                	mov    (%ecx),%edx
  80a072:	89 15 c0 77 b3 00    	mov    %edx,0xb377c0
  80a078:	eb 24                	jmp    80a09e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80a07a:	85 d2                	test   %edx,%edx
  80a07c:	75 1c                	jne    80a09a <ip_reass_dequeue_datagram+0x3a>
  80a07e:	c7 44 24 08 59 3b 81 	movl   $0x813b59,0x8(%esp)
  80a085:	00 
  80a086:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80a08d:	00 
  80a08e:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a095:	e8 e2 68 ff ff       	call   80097c <_panic>
    prev->next = ipr->next;
  80a09a:	8b 08                	mov    (%eax),%ecx
  80a09c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80a09e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a0a2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a0a9:	e8 92 d6 ff ff       	call   807740 <memp_free>
}
  80a0ae:	c9                   	leave  
  80a0af:	c3                   	ret    

0080a0b0 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a0b0:	55                   	push   %ebp
  80a0b1:	89 e5                	mov    %esp,%ebp
  80a0b3:	57                   	push   %edi
  80a0b4:	56                   	push   %esi
  80a0b5:	53                   	push   %ebx
  80a0b6:	83 ec 2c             	sub    $0x2c,%esp
  80a0b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a0bc:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80a0bf:	39 c2                	cmp    %eax,%edx
  80a0c1:	75 1c                	jne    80a0df <ip_reass_free_complete_datagram+0x2f>
  80a0c3:	c7 44 24 08 8f 3b 81 	movl   $0x813b8f,0x8(%esp)
  80a0ca:	00 
  80a0cb:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80a0d2:	00 
  80a0d3:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a0da:	e8 9d 68 ff ff       	call   80097c <_panic>
  if (prev != NULL) {
  80a0df:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80a0e3:	74 26                	je     80a10b <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  80a0e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a0e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a0eb:	39 10                	cmp    %edx,(%eax)
  80a0ed:	74 1c                	je     80a10b <ip_reass_free_complete_datagram+0x5b>
  80a0ef:	c7 44 24 08 9b 3b 81 	movl   $0x813b9b,0x8(%esp)
  80a0f6:	00 
  80a0f7:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80a0fe:	00 
  80a0ff:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a106:	e8 71 68 ff ff       	call   80097c <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  80a10b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a10e:	8b 58 04             	mov    0x4(%eax),%ebx
  80a111:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  80a114:	bf 00 00 00 00       	mov    $0x0,%edi
  80a119:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a11e:	75 47                	jne    80a167 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80a120:	8b 00                	mov    (%eax),%eax
  80a122:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a125:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  80a128:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a12f:	00 
  80a130:	89 d0                	mov    %edx,%eax
  80a132:	83 c0 08             	add    $0x8,%eax
  80a135:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a139:	8b 43 04             	mov    0x4(%ebx),%eax
  80a13c:	89 04 24             	mov    %eax,(%esp)
  80a13f:	e8 0d 72 ff ff       	call   801351 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  80a144:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80a14b:	00 
  80a14c:	89 1c 24             	mov    %ebx,(%esp)
  80a14f:	e8 fc 7a 00 00       	call   811c50 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  80a154:	89 1c 24             	mov    %ebx,(%esp)
  80a157:	e8 14 d9 ff ff       	call   807a70 <pbuf_clen>
  80a15c:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  80a15f:	89 1c 24             	mov    %ebx,(%esp)
  80a162:	e8 71 dd ff ff       	call   807ed8 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  80a167:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a16a:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  80a16d:	85 db                	test   %ebx,%ebx
  80a16f:	74 22                	je     80a193 <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80a171:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80a174:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  80a176:	89 1c 24             	mov    %ebx,(%esp)
  80a179:	e8 f2 d8 ff ff       	call   807a70 <pbuf_clen>
  80a17e:	0f b6 c0             	movzbl %al,%eax
  80a181:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  80a183:	89 1c 24             	mov    %ebx,(%esp)
  80a186:	e8 4d dd ff ff       	call   807ed8 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  80a18b:	85 f6                	test   %esi,%esi
  80a18d:	74 04                	je     80a193 <ip_reass_free_complete_datagram+0xe3>
  80a18f:	89 f3                	mov    %esi,%ebx
  80a191:	eb de                	jmp    80a171 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80a193:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a196:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a199:	e8 c2 fe ff ff       	call   80a060 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  80a19e:	0f b7 05 c4 77 b3 00 	movzwl 0xb377c4,%eax
  80a1a5:	0f b7 d0             	movzwl %ax,%edx
  80a1a8:	39 fa                	cmp    %edi,%edx
  80a1aa:	7d 1c                	jge    80a1c8 <ip_reass_free_complete_datagram+0x118>
  80a1ac:	c7 44 24 08 ad 3b 81 	movl   $0x813bad,0x8(%esp)
  80a1b3:	00 
  80a1b4:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80a1bb:	00 
  80a1bc:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a1c3:	e8 b4 67 ff ff       	call   80097c <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  80a1c8:	66 29 f8             	sub    %di,%ax
  80a1cb:	66 a3 c4 77 b3 00    	mov    %ax,0xb377c4

  return pbufs_freed;
}
  80a1d1:	89 f8                	mov    %edi,%eax
  80a1d3:	83 c4 2c             	add    $0x2c,%esp
  80a1d6:	5b                   	pop    %ebx
  80a1d7:	5e                   	pop    %esi
  80a1d8:	5f                   	pop    %edi
  80a1d9:	5d                   	pop    %ebp
  80a1da:	c3                   	ret    

0080a1db <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80a1db:	55                   	push   %ebp
  80a1dc:	89 e5                	mov    %esp,%ebp
  80a1de:	57                   	push   %edi
  80a1df:	56                   	push   %esi
  80a1e0:	53                   	push   %ebx
  80a1e1:	83 ec 2c             	sub    $0x2c,%esp
  80a1e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a1e7:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80a1ea:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80a1f1:	8b 0d c0 77 b3 00    	mov    0xb377c0,%ecx
    while (r != NULL) {
  80a1f7:	85 c9                	test   %ecx,%ecx
  80a1f9:	74 6f                	je     80a26a <ip_reass_remove_oldest_datagram+0x8f>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80a1fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a1fe:	8b 78 0c             	mov    0xc(%eax),%edi
  80a201:	ba 00 00 00 00       	mov    $0x0,%edx
  80a206:	b8 00 00 00 00       	mov    $0x0,%eax
  80a20b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a210:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80a213:	39 79 14             	cmp    %edi,0x14(%ecx)
  80a216:	75 15                	jne    80a22d <ip_reass_remove_oldest_datagram+0x52>
  80a218:	8b 51 18             	mov    0x18(%ecx),%edx
  80a21b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80a21e:	3b 56 10             	cmp    0x10(%esi),%edx
  80a221:	75 0a                	jne    80a22d <ip_reass_remove_oldest_datagram+0x52>
  80a223:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80a227:	66 3b 56 04          	cmp    0x4(%esi),%dx
  80a22b:	74 14                	je     80a241 <ip_reass_remove_oldest_datagram+0x66>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80a22d:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  80a230:	85 c0                	test   %eax,%eax
  80a232:	74 0b                	je     80a23f <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  80a234:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  80a238:	89 f2                	mov    %esi,%edx
  80a23a:	3a 50 1f             	cmp    0x1f(%eax),%dl
  80a23d:	77 02                	ja     80a241 <ip_reass_remove_oldest_datagram+0x66>
  80a23f:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  80a241:	8b 31                	mov    (%ecx),%esi
  80a243:	85 f6                	test   %esi,%esi
  80a245:	74 07                	je     80a24e <ip_reass_remove_oldest_datagram+0x73>
  80a247:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a24a:	89 f1                	mov    %esi,%ecx
  80a24c:	eb c5                	jmp    80a213 <ip_reass_remove_oldest_datagram+0x38>
  80a24e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  80a251:	85 c0                	test   %eax,%eax
  80a253:	74 08                	je     80a25d <ip_reass_remove_oldest_datagram+0x82>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  80a255:	e8 56 fe ff ff       	call   80a0b0 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  80a25a:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  80a25d:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80a260:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  80a263:	7d 05                	jge    80a26a <ip_reass_remove_oldest_datagram+0x8f>
  80a265:	83 fb 01             	cmp    $0x1,%ebx
  80a268:	7f 87                	jg     80a1f1 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  80a26a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a26d:	83 c4 2c             	add    $0x2c,%esp
  80a270:	5b                   	pop    %ebx
  80a271:	5e                   	pop    %esi
  80a272:	5f                   	pop    %edi
  80a273:	5d                   	pop    %ebp
  80a274:	c3                   	ret    

0080a275 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  80a275:	55                   	push   %ebp
  80a276:	89 e5                	mov    %esp,%ebp
  80a278:	56                   	push   %esi
  80a279:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80a27a:	a1 c0 77 b3 00       	mov    0xb377c0,%eax
  while (r != NULL) {
  80a27f:	85 c0                	test   %eax,%eax
  80a281:	74 2a                	je     80a2ad <ip_reass_tmr+0x38>
  80a283:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  80a288:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  80a28c:	84 d2                	test   %dl,%dl
  80a28e:	74 0c                	je     80a29c <ip_reass_tmr+0x27>
      r->timer--;
  80a290:	83 ea 01             	sub    $0x1,%edx
  80a293:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  80a296:	8b 18                	mov    (%eax),%ebx
  80a298:	89 c6                	mov    %eax,%esi
  80a29a:	eb 09                	jmp    80a2a5 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80a29c:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80a29e:	89 f2                	mov    %esi,%edx
  80a2a0:	e8 0b fe ff ff       	call   80a0b0 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80a2a5:	85 db                	test   %ebx,%ebx
  80a2a7:	74 04                	je     80a2ad <ip_reass_tmr+0x38>
  80a2a9:	89 d8                	mov    %ebx,%eax
  80a2ab:	eb db                	jmp    80a288 <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80a2ad:	5b                   	pop    %ebx
  80a2ae:	5e                   	pop    %esi
  80a2af:	5d                   	pop    %ebp
  80a2b0:	c3                   	ret    

0080a2b1 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80a2b1:	55                   	push   %ebp
  80a2b2:	89 e5                	mov    %esp,%ebp
  80a2b4:	57                   	push   %edi
  80a2b5:	56                   	push   %esi
  80a2b6:	53                   	push   %ebx
  80a2b7:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  80a2ba:	8b 45 08             	mov    0x8(%ebp),%eax
  80a2bd:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80a2c0:	0f b7 03             	movzwl (%ebx),%eax
  80a2c3:	89 04 24             	mov    %eax,(%esp)
  80a2c6:	e8 16 0a 00 00       	call   80ace1 <ntohs>
  80a2cb:	c1 e8 06             	shr    $0x6,%eax
  80a2ce:	83 e0 3c             	and    $0x3c,%eax
  80a2d1:	83 f8 14             	cmp    $0x14,%eax
  80a2d4:	0f 85 f3 04 00 00    	jne    80a7cd <ip_reass+0x51c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a2da:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a2de:	89 04 24             	mov    %eax,(%esp)
  80a2e1:	e8 fb 09 00 00       	call   80ace1 <ntohs>
  80a2e6:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a2ea:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a2ee:	89 04 24             	mov    %eax,(%esp)
  80a2f1:	e8 eb 09 00 00       	call   80ace1 <ntohs>
  80a2f6:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  80a2fa:	0f b7 03             	movzwl (%ebx),%eax
  80a2fd:	89 04 24             	mov    %eax,(%esp)
  80a300:	e8 dc 09 00 00       	call   80ace1 <ntohs>
  80a305:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  80a309:	8b 55 08             	mov    0x8(%ebp),%edx
  80a30c:	89 14 24             	mov    %edx,(%esp)
  80a30f:	e8 5c d7 ff ff       	call   807a70 <pbuf_clen>
  80a314:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  80a316:	0f b6 c8             	movzbl %al,%ecx
  80a319:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a31c:	0f b7 05 c4 77 b3 00 	movzwl 0xb377c4,%eax
  80a323:	01 c8                	add    %ecx,%eax
  80a325:	83 f8 0a             	cmp    $0xa,%eax
  80a328:	7e 24                	jle    80a34e <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  80a32a:	89 ca                	mov    %ecx,%edx
  80a32c:	89 d8                	mov    %ebx,%eax
  80a32e:	e8 a8 fe ff ff       	call   80a1db <ip_reass_remove_oldest_datagram>
  80a333:	85 c0                	test   %eax,%eax
  80a335:	0f 84 92 04 00 00    	je     80a7cd <ip_reass+0x51c>
  80a33b:	0f b7 05 c4 77 b3 00 	movzwl 0xb377c4,%eax
  80a342:	03 45 e0             	add    -0x20(%ebp),%eax
  80a345:	83 f8 0a             	cmp    $0xa,%eax
  80a348:	0f 8f 7f 04 00 00    	jg     80a7cd <ip_reass+0x51c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a34e:	8b 35 c0 77 b3 00    	mov    0xb377c0,%esi
  80a354:	85 f6                	test   %esi,%esi
  80a356:	0f 84 97 04 00 00    	je     80a7f3 <ip_reass+0x542>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80a35c:	8b 53 0c             	mov    0xc(%ebx),%edx
  80a35f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a366:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a36b:	39 56 14             	cmp    %edx,0x14(%esi)
  80a36e:	75 12                	jne    80a382 <ip_reass+0xd1>
  80a370:	8b 46 18             	mov    0x18(%esi),%eax
  80a373:	3b 43 10             	cmp    0x10(%ebx),%eax
  80a376:	75 0a                	jne    80a382 <ip_reass+0xd1>
  80a378:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80a37c:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a380:	74 11                	je     80a393 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a382:	8b 06                	mov    (%esi),%eax
  80a384:	85 c0                	test   %eax,%eax
  80a386:	75 05                	jne    80a38d <ip_reass+0xdc>
  80a388:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80a38b:	eb 10                	jmp    80a39d <ip_reass+0xec>
  80a38d:	89 f1                	mov    %esi,%ecx
  80a38f:	89 c6                	mov    %eax,%esi
  80a391:	eb d8                	jmp    80a36b <ip_reass+0xba>
  80a393:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a396:	89 75 cc             	mov    %esi,-0x34(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  80a399:	85 f6                	test   %esi,%esi
  80a39b:	75 7d                	jne    80a41a <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80a39d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a3a4:	e8 db d3 ff ff       	call   807784 <memp_malloc>
  80a3a9:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  80a3ab:	85 c0                	test   %eax,%eax
  80a3ad:	75 29                	jne    80a3d8 <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80a3af:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a3b2:	89 d8                	mov    %ebx,%eax
  80a3b4:	e8 22 fe ff ff       	call   80a1db <ip_reass_remove_oldest_datagram>
  80a3b9:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80a3bc:	0f 8f 0b 04 00 00    	jg     80a7cd <ip_reass+0x51c>
      ipr = memp_malloc(MEMP_REASSDATA);
  80a3c2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a3c9:	e8 b6 d3 ff ff       	call   807784 <memp_malloc>
  80a3ce:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80a3d0:	85 c0                	test   %eax,%eax
  80a3d2:	0f 84 f5 03 00 00    	je     80a7cd <ip_reass+0x51c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80a3d8:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80a3df:	00 
  80a3e0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a3e7:	00 
  80a3e8:	89 34 24             	mov    %esi,(%esp)
  80a3eb:	e8 86 6e ff ff       	call   801276 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80a3f0:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80a3f4:	a1 c0 77 b3 00       	mov    0xb377c0,%eax
  80a3f9:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80a3fb:	89 35 c0 77 b3 00    	mov    %esi,0xb377c0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80a401:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a408:	00 
  80a409:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a40d:	8d 46 08             	lea    0x8(%esi),%eax
  80a410:	89 04 24             	mov    %eax,(%esp)
  80a413:	e8 39 6f ff ff       	call   801351 <memcpy>
  80a418:	eb 41                	jmp    80a45b <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a41a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a41e:	89 04 24             	mov    %eax,(%esp)
  80a421:	e8 bb 08 00 00       	call   80ace1 <ntohs>
  80a426:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a42a:	75 2f                	jne    80a45b <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80a42c:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80a42f:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  80a433:	89 04 24             	mov    %eax,(%esp)
  80a436:	e8 a6 08 00 00       	call   80ace1 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a43b:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a43f:	74 1a                	je     80a45b <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  80a441:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a448:	00 
  80a449:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a44d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80a450:	83 c0 08             	add    $0x8,%eax
  80a453:	89 04 24             	mov    %eax,(%esp)
  80a456:	e8 f6 6e ff ff       	call   801351 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  80a45b:	66 81 e7 ff 00       	and    $0xff,%di
  80a460:	66 01 3d c4 77 b3 00 	add    %di,0xb377c4

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  80a467:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a46b:	89 04 24             	mov    %eax,(%esp)
  80a46e:	e8 6e 08 00 00       	call   80ace1 <ntohs>
  80a473:	f6 c4 20             	test   $0x20,%ah
  80a476:	75 21                	jne    80a499 <ip_reass+0x1e8>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  80a478:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  80a47c:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  80a480:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
  80a484:	8d 04 cb             	lea    (%ebx,%ecx,8),%eax
  80a487:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a48b:	66 c1 ea 06          	shr    $0x6,%dx
  80a48f:	83 e2 3c             	and    $0x3c,%edx
  80a492:	66 29 d0             	sub    %dx,%ax
  80a495:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  80a499:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a49c:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a49f:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a4a3:	89 04 24             	mov    %eax,(%esp)
  80a4a6:	e8 36 08 00 00       	call   80ace1 <ntohs>
  80a4ab:	89 c7                	mov    %eax,%edi
  80a4ad:	0f b7 03             	movzwl (%ebx),%eax
  80a4b0:	89 04 24             	mov    %eax,(%esp)
  80a4b3:	e8 29 08 00 00       	call   80ace1 <ntohs>
  80a4b8:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a4bc:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a4c0:	89 04 24             	mov    %eax,(%esp)
  80a4c3:	e8 19 08 00 00       	call   80ace1 <ntohs>
  80a4c8:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80a4cb:	8b 55 08             	mov    0x8(%ebp),%edx
  80a4ce:	8b 52 04             	mov    0x4(%edx),%edx
  80a4d1:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  80a4d4:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80a4da:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  80a4de:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  80a4e1:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a4e5:	66 c1 ea 06          	shr    $0x6,%dx
  80a4e9:	83 e2 3c             	and    $0x3c,%edx
  80a4ec:	66 29 d1             	sub    %dx,%cx
  80a4ef:	66 89 4d da          	mov    %cx,-0x26(%ebp)
  80a4f3:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a4f6:	66 89 4b 06          	mov    %cx,0x6(%ebx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a4fa:	8b 7e 04             	mov    0x4(%esi),%edi
  80a4fd:	85 ff                	test   %edi,%edi
  80a4ff:	0f 84 10 03 00 00    	je     80a815 <ip_reass+0x564>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a505:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  80a508:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80a50c:	66 39 c8             	cmp    %cx,%ax
  80a50f:	0f 82 ea 02 00 00    	jb     80a7ff <ip_reass+0x54e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a515:	66 39 c8             	cmp    %cx,%ax
  80a518:	0f 84 23 02 00 00    	je     80a741 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a51e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a525:	66 39 42 06          	cmp    %ax,0x6(%edx)
  80a529:	0f 86 8e 00 00 00    	jbe    80a5bd <ip_reass+0x30c>
  80a52f:	90                   	nop
  80a530:	e9 0c 02 00 00       	jmp    80a741 <ip_reass+0x490>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a535:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  80a538:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  80a53c:	66 39 d8             	cmp    %bx,%ax
  80a53f:	73 49                	jae    80a58a <ip_reass+0x2d9>
  80a541:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80a544:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a547:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80a54a:	89 d3                	mov    %edx,%ebx
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a54c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a54f:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  80a551:	85 d2                	test   %edx,%edx
  80a553:	74 25                	je     80a57a <ip_reass+0x2c9>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80a555:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80a559:	0f 82 e2 01 00 00    	jb     80a741 <ip_reass+0x490>
  80a55f:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80a563:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a566:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a56a:	0f 87 d1 01 00 00    	ja     80a741 <ip_reass+0x490>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a570:	8b 55 08             	mov    0x8(%ebp),%edx
  80a573:	89 13                	mov    %edx,(%ebx)
  80a575:	e9 cc 00 00 00       	jmp    80a646 <ip_reass+0x395>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a57a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a57d:	89 4e 04             	mov    %ecx,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80a580:	85 ff                	test   %edi,%edi
  80a582:	0f 85 be 00 00 00    	jne    80a646 <ip_reass+0x395>
  80a588:	eb 49                	jmp    80a5d3 <ip_reass+0x322>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a58a:	66 39 d8             	cmp    %bx,%ax
  80a58d:	8d 76 00             	lea    0x0(%esi),%esi
  80a590:	0f 84 ab 01 00 00    	je     80a741 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a596:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80a59a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a5a0:	0f 82 9b 01 00 00    	jb     80a741 <ip_reass+0x490>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a5a6:	85 d2                	test   %edx,%edx
  80a5a8:	74 0f                	je     80a5b9 <ip_reass+0x308>
        if (iprh_prev->end != iprh_tmp->start) {
  80a5aa:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80a5ae:	0f 95 c2             	setne  %dl
  80a5b1:	0f b6 d2             	movzbl %dl,%edx
  80a5b4:	83 ea 01             	sub    $0x1,%edx
  80a5b7:	21 d6                	and    %edx,%esi
  80a5b9:	89 ca                	mov    %ecx,%edx
  80a5bb:	eb 06                	jmp    80a5c3 <ip_reass+0x312>
  80a5bd:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80a5c0:	8b 75 dc             	mov    -0x24(%ebp),%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a5c3:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a5c5:	85 ff                	test   %edi,%edi
  80a5c7:	0f 85 68 ff ff ff    	jne    80a535 <ip_reass+0x284>
  80a5cd:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a5d0:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a5d3:	85 d2                	test   %edx,%edx
  80a5d5:	74 47                	je     80a61e <ip_reass+0x36d>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a5d7:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a5db:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a5de:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a5e2:	76 1c                	jbe    80a600 <ip_reass+0x34f>
  80a5e4:	c7 44 24 08 c8 3b 81 	movl   $0x813bc8,0x8(%esp)
  80a5eb:	00 
  80a5ec:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a5f3:	00 
  80a5f4:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a5fb:	e8 7c 63 ff ff       	call   80097c <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a600:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a603:	89 3a                	mov    %edi,(%edx)
      if (iprh_prev->end != iprh->start) {
  80a605:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a609:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a60c:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a610:	0f 95 c0             	setne  %al
  80a613:	0f b6 c0             	movzbl %al,%eax
  80a616:	83 e8 01             	sub    $0x1,%eax
  80a619:	21 45 dc             	and    %eax,-0x24(%ebp)
  80a61c:	eb 28                	jmp    80a646 <ip_reass+0x395>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a61e:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80a622:	74 1c                	je     80a640 <ip_reass+0x38f>
  80a624:	c7 44 24 08 f4 3b 81 	movl   $0x813bf4,0x8(%esp)
  80a62b:	00 
  80a62c:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a633:	00 
  80a634:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a63b:	e8 3c 63 ff ff       	call   80097c <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a640:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a643:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a646:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a64a:	0f 84 91 01 00 00    	je     80a7e1 <ip_reass+0x530>
    /* and had no wholes so far */
    if (valid) {
  80a650:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80a654:	0f 84 87 01 00 00    	je     80a7e1 <ip_reass+0x530>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a65a:	8b 56 04             	mov    0x4(%esi),%edx
  80a65d:	8b 42 04             	mov    0x4(%edx),%eax
  80a660:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a665:	0f 85 76 01 00 00    	jne    80a7e1 <ip_reass+0x530>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a66b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a66e:	8b 0b                	mov    (%ebx),%ecx
        while (q != NULL) {
  80a670:	85 c9                	test   %ecx,%ecx
  80a672:	0f 84 ae 01 00 00    	je     80a826 <ip_reass+0x575>
          iprh = (struct ip_reass_helper*)q->payload;
  80a678:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a67b:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a67f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a682:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a686:	74 1a                	je     80a6a2 <ip_reass+0x3f1>
  80a688:	e9 54 01 00 00       	jmp    80a7e1 <ip_reass+0x530>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a68d:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a690:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a694:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a698:	0f 85 43 01 00 00    	jne    80a7e1 <ip_reass+0x530>
  80a69e:	89 cb                	mov    %ecx,%ebx
  80a6a0:	eb 03                	jmp    80a6a5 <ip_reass+0x3f4>
  80a6a2:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a6a5:	8b 0b                	mov    (%ebx),%ecx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a6a7:	85 c9                	test   %ecx,%ecx
  80a6a9:	75 e2                	jne    80a68d <ip_reass+0x3dc>
  80a6ab:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  80a6ae:	e9 73 01 00 00       	jmp    80a826 <ip_reass+0x575>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a6b3:	c7 44 24 08 e6 3b 81 	movl   $0x813be6,0x8(%esp)
  80a6ba:	00 
  80a6bb:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a6c2:	00 
  80a6c3:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a6ca:	e8 ad 62 ff ff       	call   80097c <_panic>
          LWIP_ASSERT("sanity check",
  80a6cf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80a6d2:	75 1c                	jne    80a6f0 <ip_reass+0x43f>
  80a6d4:	c7 44 24 08 e6 3b 81 	movl   $0x813be6,0x8(%esp)
  80a6db:	00 
  80a6dc:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a6e3:	00 
  80a6e4:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a6eb:	e8 8c 62 ff ff       	call   80097c <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a6f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a6f3:	83 38 00             	cmpl   $0x0,(%eax)
  80a6f6:	74 1c                	je     80a714 <ip_reass+0x463>
  80a6f8:	c7 44 24 08 2c 3c 81 	movl   $0x813c2c,0x8(%esp)
  80a6ff:	00 
  80a700:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a707:	00 
  80a708:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a70f:	e8 68 62 ff ff       	call   80097c <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a714:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a717:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a71b:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a71f:	0f 84 10 01 00 00    	je     80a835 <ip_reass+0x584>
  80a725:	c7 44 24 08 50 3c 81 	movl   $0x813c50,0x8(%esp)
  80a72c:	00 
  80a72d:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a734:	00 
  80a735:	c7 04 24 72 3b 81 00 	movl   $0x813b72,(%esp)
  80a73c:	e8 3b 62 ff ff       	call   80097c <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a741:	0f b7 1d c4 77 b3 00 	movzwl 0xb377c4,%ebx
  80a748:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a74b:	89 0c 24             	mov    %ecx,(%esp)
  80a74e:	e8 1d d3 ff ff       	call   807a70 <pbuf_clen>
  80a753:	0f b6 c0             	movzbl %al,%eax
  80a756:	66 29 c3             	sub    %ax,%bx
  80a759:	66 89 1d c4 77 b3 00 	mov    %bx,0xb377c4
  pbuf_free(new_p);
  80a760:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a763:	89 1c 24             	mov    %ebx,(%esp)
  80a766:	e8 6d d7 ff ff       	call   807ed8 <pbuf_free>
  80a76b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a772:	eb 74                	jmp    80a7e8 <ip_reass+0x537>
  80a774:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80a777:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a77a:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a77d:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a784:	ff 
  80a785:	89 3c 24             	mov    %edi,(%esp)
  80a788:	e8 d6 d3 ff ff       	call   807b63 <pbuf_header>
      pbuf_cat(p, r);
  80a78d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a791:	89 34 24             	mov    %esi,(%esp)
  80a794:	e8 02 d3 ff ff       	call   807a9b <pbuf_cat>
      r = iprh->next_pbuf;
  80a799:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a79b:	85 ff                	test   %edi,%edi
  80a79d:	75 db                	jne    80a77a <ip_reass+0x4c9>
  80a79f:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a7a2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a7a5:	89 f0                	mov    %esi,%eax
  80a7a7:	e8 b4 f8 ff ff       	call   80a060 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a7ac:	0f b7 1d c4 77 b3 00 	movzwl 0xb377c4,%ebx
  80a7b3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a7b6:	89 3c 24             	mov    %edi,(%esp)
  80a7b9:	e8 b2 d2 ff ff       	call   807a70 <pbuf_clen>
  80a7be:	0f b6 c0             	movzbl %al,%eax
  80a7c1:	66 29 c3             	sub    %ax,%bx
  80a7c4:	66 89 1d c4 77 b3 00 	mov    %bx,0xb377c4

    /* Return the pbuf chain */
    return p;
  80a7cb:	eb 1b                	jmp    80a7e8 <ip_reass+0x537>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a7cd:	8b 45 08             	mov    0x8(%ebp),%eax
  80a7d0:	89 04 24             	mov    %eax,(%esp)
  80a7d3:	e8 00 d7 ff ff       	call   807ed8 <pbuf_free>
  80a7d8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  80a7df:	eb 07                	jmp    80a7e8 <ip_reass+0x537>
  80a7e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80a7e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a7eb:	83 c4 3c             	add    $0x3c,%esp
  80a7ee:	5b                   	pop    %ebx
  80a7ef:	5e                   	pop    %esi
  80a7f0:	5f                   	pop    %edi
  80a7f1:	5d                   	pop    %ebp
  80a7f2:	c3                   	ret    

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
  80a7f3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a7fa:	e9 9e fb ff ff       	jmp    80a39d <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a7ff:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a802:	89 3a                	mov    %edi,(%edx)
  80a804:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a80b:	ba 00 00 00 00       	mov    $0x0,%edx
  80a810:	e9 65 fd ff ff       	jmp    80a57a <ip_reass+0x2c9>
  80a815:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a81c:	ba 00 00 00 00       	mov    $0x0,%edx
  80a821:	e9 ad fd ff ff       	jmp    80a5d3 <ip_reass+0x322>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a826:	85 d2                	test   %edx,%edx
  80a828:	0f 85 a1 fe ff ff    	jne    80a6cf <ip_reass+0x41e>
  80a82e:	66 90                	xchg   %ax,%ax
  80a830:	e9 7e fe ff ff       	jmp    80a6b3 <ip_reass+0x402>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a835:	83 c0 14             	add    $0x14,%eax
  80a838:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a83c:	8b 46 04             	mov    0x4(%esi),%eax
  80a83f:	8b 58 04             	mov    0x4(%eax),%ebx
  80a842:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a844:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a84b:	00 
  80a84c:	8d 46 08             	lea    0x8(%esi),%eax
  80a84f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a853:	89 1c 24             	mov    %ebx,(%esp)
  80a856:	e8 f6 6a ff ff       	call   801351 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a85b:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a85f:	89 04 24             	mov    %eax,(%esp)
  80a862:	e8 6d 04 00 00       	call   80acd4 <htons>
  80a867:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a86b:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a871:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a877:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a87e:	00 
  80a87f:	89 1c 24             	mov    %ebx,(%esp)
  80a882:	e8 33 01 00 00       	call   80a9ba <inet_chksum>
  80a887:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a88b:	8b 4e 04             	mov    0x4(%esi),%ecx
  80a88e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a891:	85 ff                	test   %edi,%edi
  80a893:	0f 85 db fe ff ff    	jne    80a774 <ip_reass+0x4c3>
  80a899:	e9 04 ff ff ff       	jmp    80a7a2 <ip_reass+0x4f1>
	...

0080a8a0 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a8a0:	55                   	push   %ebp
  80a8a1:	89 e5                	mov    %esp,%ebp
  80a8a3:	57                   	push   %edi
  80a8a4:	56                   	push   %esi
  80a8a5:	53                   	push   %ebx
  80a8a6:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a8a9:	89 c7                	mov    %eax,%edi
  while (len > 1) {
  80a8ab:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a8b0:	66 83 fa 01          	cmp    $0x1,%dx
  80a8b4:	76 3a                	jbe    80a8f0 <lwip_standard_chksum+0x50>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a8b6:	83 ea 02             	sub    $0x2,%edx
  80a8b9:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80a8bd:	66 d1 ea             	shr    %dx
  80a8c0:	0f b7 d2             	movzwl %dx,%edx
  80a8c3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a8c6:	8d 74 50 02          	lea    0x2(%eax,%edx,2),%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a8ca:	0f b6 18             	movzbl (%eax),%ebx
  80a8cd:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a8d0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80a8d4:	09 da                	or     %ebx,%edx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a8d6:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80a8d9:	0f b7 d2             	movzwl %dx,%edx
  80a8dc:	01 d1                	add    %edx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a8de:	39 c6                	cmp    %eax,%esi
  80a8e0:	75 e8                	jne    80a8ca <lwip_standard_chksum+0x2a>
  80a8e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a8e5:	8d 7c 47 02          	lea    0x2(%edi,%eax,2),%edi
  80a8e9:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80a8ed:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a8f0:	66 85 d2             	test   %dx,%dx
  80a8f3:	74 0b                	je     80a900 <lwip_standard_chksum+0x60>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a8f5:	0f b6 07             	movzbl (%edi),%eax
  80a8f8:	c1 e0 08             	shl    $0x8,%eax
  80a8fb:	0f b7 c0             	movzwl %ax,%eax
  80a8fe:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a900:	89 c8                	mov    %ecx,%eax
  80a902:	c1 e8 10             	shr    $0x10,%eax
  80a905:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a90b:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  80a90d:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  80a913:	74 0d                	je     80a922 <lwip_standard_chksum+0x82>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a915:	89 c8                	mov    %ecx,%eax
  80a917:	c1 e8 10             	shr    $0x10,%eax
  80a91a:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a920:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a922:	0f b7 c9             	movzwl %cx,%ecx
  80a925:	89 0c 24             	mov    %ecx,(%esp)
  80a928:	e8 a7 03 00 00       	call   80acd4 <htons>
}
  80a92d:	83 c4 2c             	add    $0x2c,%esp
  80a930:	5b                   	pop    %ebx
  80a931:	5e                   	pop    %esi
  80a932:	5f                   	pop    %edi
  80a933:	5d                   	pop    %ebp
  80a934:	c3                   	ret    

0080a935 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a935:	55                   	push   %ebp
  80a936:	89 e5                	mov    %esp,%ebp
  80a938:	57                   	push   %edi
  80a939:	56                   	push   %esi
  80a93a:	53                   	push   %ebx
  80a93b:	83 ec 0c             	sub    $0xc,%esp
  80a93e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a941:	be 00 00 00 00       	mov    $0x0,%esi
  80a946:	85 db                	test   %ebx,%ebx
  80a948:	74 64                	je     80a9ae <inet_chksum_pbuf+0x79>
  80a94a:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a94f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a953:	8b 43 04             	mov    0x4(%ebx),%eax
  80a956:	e8 45 ff ff ff       	call   80a8a0 <lwip_standard_chksum>
  80a95b:	0f b7 c0             	movzwl %ax,%eax
  80a95e:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80a961:	89 f0                	mov    %esi,%eax
  80a963:	c1 e8 10             	shr    $0x10,%eax
  80a966:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a96c:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a96e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a972:	74 1c                	je     80a990 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80a974:	b8 01 00 00 00       	mov    $0x1,%eax
  80a979:	89 fa                	mov    %edi,%edx
  80a97b:	28 d0                	sub    %dl,%al
  80a97d:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a97f:	89 f0                	mov    %esi,%eax
  80a981:	c1 e0 08             	shl    $0x8,%eax
  80a984:	25 ff ff 00 00       	and    $0xffff,%eax
  80a989:	89 f2                	mov    %esi,%edx
  80a98b:	0f b6 f6             	movzbl %dh,%esi
  80a98e:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a990:	8b 1b                	mov    (%ebx),%ebx
  80a992:	85 db                	test   %ebx,%ebx
  80a994:	75 b9                	jne    80a94f <inet_chksum_pbuf+0x1a>
  80a996:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80a998:	89 fa                	mov    %edi,%edx
  80a99a:	84 d2                	test   %dl,%dl
  80a99c:	74 10                	je     80a9ae <inet_chksum_pbuf+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a99e:	89 f2                	mov    %esi,%edx
  80a9a0:	c1 e2 08             	shl    $0x8,%edx
  80a9a3:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a9a9:	0f b6 f4             	movzbl %ah,%esi
  80a9ac:	09 d6                	or     %edx,%esi
  80a9ae:	89 f0                	mov    %esi,%eax
  80a9b0:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80a9b2:	83 c4 0c             	add    $0xc,%esp
  80a9b5:	5b                   	pop    %ebx
  80a9b6:	5e                   	pop    %esi
  80a9b7:	5f                   	pop    %edi
  80a9b8:	5d                   	pop    %ebp
  80a9b9:	c3                   	ret    

0080a9ba <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a9ba:	55                   	push   %ebp
  80a9bb:	89 e5                	mov    %esp,%ebp
  80a9bd:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a9c0:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80a9c4:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9c7:	e8 d4 fe ff ff       	call   80a8a0 <lwip_standard_chksum>
  80a9cc:	f7 d0                	not    %eax
}
  80a9ce:	c9                   	leave  
  80a9cf:	c3                   	ret    

0080a9d0 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a9d0:	55                   	push   %ebp
  80a9d1:	89 e5                	mov    %esp,%ebp
  80a9d3:	57                   	push   %edi
  80a9d4:	56                   	push   %esi
  80a9d5:	53                   	push   %ebx
  80a9d6:	83 ec 2c             	sub    $0x2c,%esp
  80a9d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a9dc:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a9e0:	88 45 e7             	mov    %al,-0x19(%ebp)
  80a9e3:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a9e7:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a9eb:	be 00 00 00 00       	mov    $0x0,%esi
  80a9f0:	85 db                	test   %ebx,%ebx
  80a9f2:	74 64                	je     80aa58 <inet_chksum_pseudo+0x88>
  80a9f4:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a9f9:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a9fd:	8b 43 04             	mov    0x4(%ebx),%eax
  80aa00:	e8 9b fe ff ff       	call   80a8a0 <lwip_standard_chksum>
  80aa05:	0f b7 c0             	movzwl %ax,%eax
  80aa08:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80aa0b:	89 f0                	mov    %esi,%eax
  80aa0d:	c1 e8 10             	shr    $0x10,%eax
  80aa10:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80aa16:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80aa18:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80aa1c:	74 1c                	je     80aa3a <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80aa1e:	b8 01 00 00 00       	mov    $0x1,%eax
  80aa23:	89 fa                	mov    %edi,%edx
  80aa25:	28 d0                	sub    %dl,%al
  80aa27:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80aa29:	89 f0                	mov    %esi,%eax
  80aa2b:	c1 e0 08             	shl    $0x8,%eax
  80aa2e:	25 ff ff 00 00       	and    $0xffff,%eax
  80aa33:	89 f2                	mov    %esi,%edx
  80aa35:	0f b6 f6             	movzbl %dh,%esi
  80aa38:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80aa3a:	8b 1b                	mov    (%ebx),%ebx
  80aa3c:	85 db                	test   %ebx,%ebx
  80aa3e:	75 b9                	jne    80a9f9 <inet_chksum_pseudo+0x29>
  80aa40:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80aa42:	89 fa                	mov    %edi,%edx
  80aa44:	84 d2                	test   %dl,%dl
  80aa46:	74 10                	je     80aa58 <inet_chksum_pseudo+0x88>
    acc = SWAP_BYTES_IN_WORD(acc);
  80aa48:	89 f2                	mov    %esi,%edx
  80aa4a:	c1 e2 08             	shl    $0x8,%edx
  80aa4d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aa53:	0f b6 f4             	movzbl %ah,%esi
  80aa56:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80aa58:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aa5b:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80aa5d:	8b 45 10             	mov    0x10(%ebp),%eax
  80aa60:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80aa62:	89 d1                	mov    %edx,%ecx
  80aa64:	c1 e9 10             	shr    $0x10,%ecx
  80aa67:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aa6d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80aa70:	0f b7 c8             	movzwl %ax,%ecx
  80aa73:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80aa75:	c1 e8 10             	shr    $0x10,%eax
  80aa78:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80aa7b:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80aa7e:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80aa82:	89 04 24             	mov    %eax,(%esp)
  80aa85:	e8 4a 02 00 00       	call   80acd4 <htons>
  80aa8a:	0f b7 c0             	movzwl %ax,%eax
  80aa8d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80aa8f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80aa93:	89 04 24             	mov    %eax,(%esp)
  80aa96:	e8 39 02 00 00       	call   80acd4 <htons>
  80aa9b:	0f b7 c0             	movzwl %ax,%eax
  80aa9e:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80aaa0:	89 f0                	mov    %esi,%eax
  80aaa2:	c1 e8 10             	shr    $0x10,%eax
  80aaa5:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80aaab:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80aaad:	89 f0                	mov    %esi,%eax
  80aaaf:	c1 e8 10             	shr    $0x10,%eax
  80aab2:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80aab5:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80aab7:	83 c4 2c             	add    $0x2c,%esp
  80aaba:	5b                   	pop    %ebx
  80aabb:	5e                   	pop    %esi
  80aabc:	5f                   	pop    %edi
  80aabd:	5d                   	pop    %ebp
  80aabe:	c3                   	ret    

0080aabf <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80aabf:	55                   	push   %ebp
  80aac0:	89 e5                	mov    %esp,%ebp
  80aac2:	57                   	push   %edi
  80aac3:	56                   	push   %esi
  80aac4:	53                   	push   %ebx
  80aac5:	83 ec 2c             	sub    $0x2c,%esp
  80aac8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aacb:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80aacf:	88 45 e2             	mov    %al,-0x1e(%ebp)
  80aad2:	0f b7 4d 18          	movzwl 0x18(%ebp),%ecx
  80aad6:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  80aada:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80aade:	85 db                	test   %ebx,%ebx
  80aae0:	74 05                	je     80aae7 <inet_chksum_pseudo_partial+0x28>
  80aae2:	66 85 f6             	test   %si,%si
  80aae5:	75 0c                	jne    80aaf3 <inet_chksum_pseudo_partial+0x34>
  80aae7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80aaee:	e9 ad 00 00 00       	jmp    80aba0 <inet_chksum_pseudo_partial+0xe1>
  80aaf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  80aaf7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80aafe:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ab02:	89 f7                	mov    %esi,%edi
  80ab04:	66 39 c6             	cmp    %ax,%si
  80ab07:	76 02                	jbe    80ab0b <inet_chksum_pseudo_partial+0x4c>
  80ab09:	89 c7                	mov    %eax,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80ab0b:	0f b7 d7             	movzwl %di,%edx
  80ab0e:	8b 43 04             	mov    0x4(%ebx),%eax
  80ab11:	e8 8a fd ff ff       	call   80a8a0 <lwip_standard_chksum>
    chksum_len -= chklen;
  80ab16:	66 29 fe             	sub    %di,%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80ab19:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80ab1e:	76 1c                	jbe    80ab3c <inet_chksum_pseudo_partial+0x7d>
  80ab20:	c7 44 24 08 7d 3c 81 	movl   $0x813c7d,0x8(%esp)
  80ab27:	00 
  80ab28:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80ab2f:	00 
  80ab30:	c7 04 24 88 3c 81 00 	movl   $0x813c88,(%esp)
  80ab37:	e8 40 5e ff ff       	call   80097c <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80ab3c:	0f b7 c0             	movzwl %ax,%eax
  80ab3f:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80ab42:	89 c2                	mov    %eax,%edx
  80ab44:	c1 ea 10             	shr    $0x10,%edx
  80ab47:	25 ff ff 00 00       	and    $0xffff,%eax
  80ab4c:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80ab4f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80ab52:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80ab56:	74 1d                	je     80ab75 <inet_chksum_pseudo_partial+0xb6>
      swapped = 1 - swapped;
  80ab58:	b8 01 00 00 00       	mov    $0x1,%eax
  80ab5d:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80ab60:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80ab63:	89 d0                	mov    %edx,%eax
  80ab65:	c1 e0 08             	shl    $0x8,%eax
  80ab68:	25 ff ff 00 00       	and    $0xffff,%eax
  80ab6d:	0f b6 d6             	movzbl %dh,%edx
  80ab70:	09 c2                	or     %eax,%edx
  80ab72:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80ab75:	8b 1b                	mov    (%ebx),%ebx
  80ab77:	85 db                	test   %ebx,%ebx
  80ab79:	74 09                	je     80ab84 <inet_chksum_pseudo_partial+0xc5>
  80ab7b:	66 85 f6             	test   %si,%si
  80ab7e:	0f 85 7a ff ff ff    	jne    80aafe <inet_chksum_pseudo_partial+0x3f>
  80ab84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80ab87:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80ab8b:	74 13                	je     80aba0 <inet_chksum_pseudo_partial+0xe1>
    acc = SWAP_BYTES_IN_WORD(acc);
  80ab8d:	89 c2                	mov    %eax,%edx
  80ab8f:	c1 e2 08             	shl    $0x8,%edx
  80ab92:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80ab98:	0f b6 c4             	movzbl %ah,%eax
  80ab9b:	09 d0                	or     %edx,%eax
  80ab9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  80aba0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aba3:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80aba5:	8b 55 10             	mov    0x10(%ebp),%edx
  80aba8:	8b 1a                	mov    (%edx),%ebx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80abaa:	89 c2                	mov    %eax,%edx
  80abac:	c1 ea 10             	shr    $0x10,%edx
  80abaf:	25 ff ff 00 00       	and    $0xffff,%eax
  80abb4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  80abb7:	0f b7 d3             	movzwl %bx,%edx
  80abba:	01 d0                	add    %edx,%eax
  acc += (dest->addr & 0xffffUL);
  80abbc:	c1 eb 10             	shr    $0x10,%ebx
  80abbf:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80abc2:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  80abc5:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  80abc9:	89 04 24             	mov    %eax,(%esp)
  80abcc:	e8 03 01 00 00       	call   80acd4 <htons>
  80abd1:	0f b7 c0             	movzwl %ax,%eax
  80abd4:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80abd6:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80abda:	89 04 24             	mov    %eax,(%esp)
  80abdd:	e8 f2 00 00 00       	call   80acd4 <htons>
  80abe2:	0f b7 c0             	movzwl %ax,%eax
  80abe5:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80abe7:	89 d8                	mov    %ebx,%eax
  80abe9:	c1 e8 10             	shr    $0x10,%eax
  80abec:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  80abf2:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80abf5:	89 c2                	mov    %eax,%edx
  80abf7:	c1 ea 10             	shr    $0x10,%edx
  80abfa:	01 d0                	add    %edx,%eax
  80abfc:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80abfe:	83 c4 2c             	add    $0x2c,%esp
  80ac01:	5b                   	pop    %ebx
  80ac02:	5e                   	pop    %esi
  80ac03:	5f                   	pop    %edi
  80ac04:	5d                   	pop    %ebp
  80ac05:	c3                   	ret    
	...

0080ac10 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80ac10:	55                   	push   %ebp
  80ac11:	89 e5                	mov    %esp,%ebp
  80ac13:	57                   	push   %edi
  80ac14:	56                   	push   %esi
  80ac15:	53                   	push   %ebx
  80ac16:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80ac19:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80ac1f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ac22:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80ac25:	8d 45 f3             	lea    -0xd(%ebp),%eax
  80ac28:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ac2b:	b9 bc 7d b3 00       	mov    $0xb37dbc,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80ac30:	ba cd ff ff ff       	mov    $0xffffffcd,%edx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80ac35:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ac38:	0f b6 18             	movzbl (%eax),%ebx
  80ac3b:	be 00 00 00 00       	mov    $0x0,%esi
  80ac40:	89 f0                	mov    %esi,%eax
  80ac42:	89 ce                	mov    %ecx,%esi
  80ac44:	89 c1                	mov    %eax,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80ac46:	89 d8                	mov    %ebx,%eax
  80ac48:	f6 e2                	mul    %dl
  80ac4a:	66 c1 e8 08          	shr    $0x8,%ax
  80ac4e:	c0 e8 03             	shr    $0x3,%al
  80ac51:	89 c7                	mov    %eax,%edi
  80ac53:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80ac56:	01 c0                	add    %eax,%eax
  80ac58:	28 c3                	sub    %al,%bl
  80ac5a:	89 d8                	mov    %ebx,%eax
      *ap /= (u8_t)10;
  80ac5c:	89 fb                	mov    %edi,%ebx
      inv[i++] = '0' + rem;
  80ac5e:	0f b6 f9             	movzbl %cl,%edi
  80ac61:	83 c0 30             	add    $0x30,%eax
  80ac64:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
  80ac68:	83 c1 01             	add    $0x1,%ecx
    } while(*ap);
  80ac6b:	84 db                	test   %bl,%bl
  80ac6d:	75 d7                	jne    80ac46 <inet_ntoa+0x36>
  80ac6f:	89 c8                	mov    %ecx,%eax
  80ac71:	89 f1                	mov    %esi,%ecx
  80ac73:	89 c6                	mov    %eax,%esi
  80ac75:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ac78:	88 18                	mov    %bl,(%eax)
    while(i--)
  80ac7a:	89 f0                	mov    %esi,%eax
  80ac7c:	84 c0                	test   %al,%al
  80ac7e:	74 2c                	je     80acac <inet_ntoa+0x9c>
  80ac80:	8d 5e ff             	lea    -0x1(%esi),%ebx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80ac83:	0f b6 c3             	movzbl %bl,%eax
  80ac86:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80ac89:	8d 7c 01 01          	lea    0x1(%ecx,%eax,1),%edi
  80ac8d:	89 c8                	mov    %ecx,%eax
  80ac8f:	89 ce                	mov    %ecx,%esi
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80ac91:	0f b6 cb             	movzbl %bl,%ecx
  80ac94:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  80ac99:	88 08                	mov    %cl,(%eax)
  80ac9b:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80ac9e:	83 eb 01             	sub    $0x1,%ebx
  80aca1:	39 f8                	cmp    %edi,%eax
  80aca3:	75 ec                	jne    80ac91 <inet_ntoa+0x81>
  80aca5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aca8:	8d 4c 06 01          	lea    0x1(%esi,%eax,1),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  80acac:	c6 01 2e             	movb   $0x2e,(%ecx)
  80acaf:	83 c1 01             	add    $0x1,%ecx
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80acb2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80acb5:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80acb8:	74 09                	je     80acc3 <inet_ntoa+0xb3>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80acba:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  80acbe:	e9 72 ff ff ff       	jmp    80ac35 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80acc3:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
  return str;
}
  80acc7:	b8 bc 7d b3 00       	mov    $0xb37dbc,%eax
  80accc:	83 c4 1c             	add    $0x1c,%esp
  80accf:	5b                   	pop    %ebx
  80acd0:	5e                   	pop    %esi
  80acd1:	5f                   	pop    %edi
  80acd2:	5d                   	pop    %ebp
  80acd3:	c3                   	ret    

0080acd4 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80acd4:	55                   	push   %ebp
  80acd5:	89 e5                	mov    %esp,%ebp
  80acd7:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80acdb:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  80acdf:	5d                   	pop    %ebp
  80ace0:	c3                   	ret    

0080ace1 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80ace1:	55                   	push   %ebp
  80ace2:	89 e5                	mov    %esp,%ebp
  80ace4:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80ace7:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80aceb:	89 04 24             	mov    %eax,(%esp)
  80acee:	e8 e1 ff ff ff       	call   80acd4 <htons>
}
  80acf3:	c9                   	leave  
  80acf4:	c3                   	ret    

0080acf5 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80acf5:	55                   	push   %ebp
  80acf6:	89 e5                	mov    %esp,%ebp
  80acf8:	8b 55 08             	mov    0x8(%ebp),%edx
  80acfb:	89 d1                	mov    %edx,%ecx
  80acfd:	c1 e9 18             	shr    $0x18,%ecx
  80ad00:	89 d0                	mov    %edx,%eax
  80ad02:	c1 e0 18             	shl    $0x18,%eax
  80ad05:	09 c8                	or     %ecx,%eax
  80ad07:	89 d1                	mov    %edx,%ecx
  80ad09:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80ad0f:	c1 e1 08             	shl    $0x8,%ecx
  80ad12:	09 c8                	or     %ecx,%eax
  80ad14:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80ad1a:	c1 ea 08             	shr    $0x8,%edx
  80ad1d:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80ad1f:	5d                   	pop    %ebp
  80ad20:	c3                   	ret    

0080ad21 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80ad21:	55                   	push   %ebp
  80ad22:	89 e5                	mov    %esp,%ebp
  80ad24:	57                   	push   %edi
  80ad25:	56                   	push   %esi
  80ad26:	53                   	push   %ebx
  80ad27:	83 ec 28             	sub    $0x28,%esp
  80ad2a:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80ad2d:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80ad30:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80ad33:	80 f9 09             	cmp    $0x9,%cl
  80ad36:	0f 87 af 01 00 00    	ja     80aeeb <inet_aton+0x1ca>
  80ad3c:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  80ad3f:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80ad42:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80ad45:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80ad48:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  80ad4f:	83 fa 30             	cmp    $0x30,%edx
  80ad52:	75 24                	jne    80ad78 <inet_aton+0x57>
      c = *++cp;
  80ad54:	83 c0 01             	add    $0x1,%eax
  80ad57:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  80ad5a:	83 fa 78             	cmp    $0x78,%edx
  80ad5d:	74 0c                	je     80ad6b <inet_aton+0x4a>
  80ad5f:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  80ad66:	83 fa 58             	cmp    $0x58,%edx
  80ad69:	75 0d                	jne    80ad78 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  80ad6b:	83 c0 01             	add    $0x1,%eax
  80ad6e:	0f be 10             	movsbl (%eax),%edx
  80ad71:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  80ad78:	83 c0 01             	add    $0x1,%eax
  80ad7b:	be 00 00 00 00       	mov    $0x0,%esi
  80ad80:	eb 03                	jmp    80ad85 <inet_aton+0x64>
  80ad82:	83 c0 01             	add    $0x1,%eax
  80ad85:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80ad88:	89 d1                	mov    %edx,%ecx
  80ad8a:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80ad8d:	80 fb 09             	cmp    $0x9,%bl
  80ad90:	77 0d                	ja     80ad9f <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  80ad92:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  80ad96:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80ad9a:	0f be 10             	movsbl (%eax),%edx
  80ad9d:	eb e3                	jmp    80ad82 <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  80ad9f:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  80ada3:	75 2b                	jne    80add0 <inet_aton+0xaf>
  80ada5:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80ada8:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80adab:	80 fb 05             	cmp    $0x5,%bl
  80adae:	76 08                	jbe    80adb8 <inet_aton+0x97>
  80adb0:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80adb3:	80 fb 05             	cmp    $0x5,%bl
  80adb6:	77 18                	ja     80add0 <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80adb8:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80adbc:	19 c9                	sbb    %ecx,%ecx
  80adbe:	83 e1 20             	and    $0x20,%ecx
  80adc1:	c1 e6 04             	shl    $0x4,%esi
  80adc4:	29 ca                	sub    %ecx,%edx
  80adc6:	8d 52 c9             	lea    -0x37(%edx),%edx
  80adc9:	09 d6                	or     %edx,%esi
        c = *++cp;
  80adcb:	0f be 10             	movsbl (%eax),%edx
  80adce:	eb b2                	jmp    80ad82 <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  80add0:	83 fa 2e             	cmp    $0x2e,%edx
  80add3:	75 2c                	jne    80ae01 <inet_aton+0xe0>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80add5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80add8:	39 55 d8             	cmp    %edx,-0x28(%ebp)
  80addb:	0f 83 0a 01 00 00    	jae    80aeeb <inet_aton+0x1ca>
        return (0);
      *pp++ = val;
  80ade1:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80ade4:	89 31                	mov    %esi,(%ecx)
      c = *++cp;
  80ade6:	8d 47 01             	lea    0x1(%edi),%eax
  80ade9:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80adec:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80adef:	80 f9 09             	cmp    $0x9,%cl
  80adf2:	0f 87 f3 00 00 00    	ja     80aeeb <inet_aton+0x1ca>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80adf8:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80adfc:	e9 47 ff ff ff       	jmp    80ad48 <inet_aton+0x27>
  80ae01:	89 f3                	mov    %esi,%ebx
  80ae03:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80ae05:	85 d2                	test   %edx,%edx
  80ae07:	74 37                	je     80ae40 <inet_aton+0x11f>
  80ae09:	80 f9 1f             	cmp    $0x1f,%cl
  80ae0c:	0f 86 d9 00 00 00    	jbe    80aeeb <inet_aton+0x1ca>
  80ae12:	84 d2                	test   %dl,%dl
  80ae14:	0f 88 d1 00 00 00    	js     80aeeb <inet_aton+0x1ca>
  80ae1a:	83 fa 20             	cmp    $0x20,%edx
  80ae1d:	8d 76 00             	lea    0x0(%esi),%esi
  80ae20:	74 1e                	je     80ae40 <inet_aton+0x11f>
  80ae22:	83 fa 0c             	cmp    $0xc,%edx
  80ae25:	74 19                	je     80ae40 <inet_aton+0x11f>
  80ae27:	83 fa 0a             	cmp    $0xa,%edx
  80ae2a:	74 14                	je     80ae40 <inet_aton+0x11f>
  80ae2c:	83 fa 0d             	cmp    $0xd,%edx
  80ae2f:	90                   	nop
  80ae30:	74 0e                	je     80ae40 <inet_aton+0x11f>
  80ae32:	83 fa 09             	cmp    $0x9,%edx
  80ae35:	74 09                	je     80ae40 <inet_aton+0x11f>
  80ae37:	83 fa 0b             	cmp    $0xb,%edx
  80ae3a:	0f 85 ab 00 00 00    	jne    80aeeb <inet_aton+0x1ca>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80ae40:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80ae43:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80ae46:	29 d1                	sub    %edx,%ecx
  80ae48:	89 ca                	mov    %ecx,%edx
  80ae4a:	c1 fa 02             	sar    $0x2,%edx
  80ae4d:	83 c2 01             	add    $0x1,%edx
  80ae50:	83 fa 02             	cmp    $0x2,%edx
  80ae53:	74 2d                	je     80ae82 <inet_aton+0x161>
  80ae55:	83 fa 02             	cmp    $0x2,%edx
  80ae58:	7f 10                	jg     80ae6a <inet_aton+0x149>
  80ae5a:	85 d2                	test   %edx,%edx
  80ae5c:	0f 84 89 00 00 00    	je     80aeeb <inet_aton+0x1ca>
  80ae62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ae68:	eb 62                	jmp    80aecc <inet_aton+0x1ab>
  80ae6a:	83 fa 03             	cmp    $0x3,%edx
  80ae6d:	8d 76 00             	lea    0x0(%esi),%esi
  80ae70:	74 22                	je     80ae94 <inet_aton+0x173>
  80ae72:	83 fa 04             	cmp    $0x4,%edx
  80ae75:	8d 76 00             	lea    0x0(%esi),%esi
  80ae78:	75 52                	jne    80aecc <inet_aton+0x1ab>
  80ae7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ae80:	eb 2b                	jmp    80aead <inet_aton+0x18c>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80ae82:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  80ae87:	90                   	nop
  80ae88:	77 61                	ja     80aeeb <inet_aton+0x1ca>
      return (0);
    val |= parts[0] << 24;
  80ae8a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80ae8d:	c1 e3 18             	shl    $0x18,%ebx
  80ae90:	09 c3                	or     %eax,%ebx
    break;
  80ae92:	eb 38                	jmp    80aecc <inet_aton+0x1ab>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80ae94:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80ae99:	77 50                	ja     80aeeb <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80ae9b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80ae9e:	c1 e3 10             	shl    $0x10,%ebx
  80aea1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80aea4:	c1 e2 18             	shl    $0x18,%edx
  80aea7:	09 d3                	or     %edx,%ebx
  80aea9:	09 c3                	or     %eax,%ebx
    break;
  80aeab:	eb 1f                	jmp    80aecc <inet_aton+0x1ab>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80aead:	3d ff 00 00 00       	cmp    $0xff,%eax
  80aeb2:	77 37                	ja     80aeeb <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80aeb4:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80aeb7:	c1 e3 10             	shl    $0x10,%ebx
  80aeba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80aebd:	c1 e2 18             	shl    $0x18,%edx
  80aec0:	09 d3                	or     %edx,%ebx
  80aec2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80aec5:	c1 e2 08             	shl    $0x8,%edx
  80aec8:	09 d3                	or     %edx,%ebx
  80aeca:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80aecc:	b8 01 00 00 00       	mov    $0x1,%eax
  80aed1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80aed5:	74 19                	je     80aef0 <inet_aton+0x1cf>
    addr->s_addr = htonl(val);
  80aed7:	89 1c 24             	mov    %ebx,(%esp)
  80aeda:	e8 16 fe ff ff       	call   80acf5 <htonl>
  80aedf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80aee2:	89 03                	mov    %eax,(%ebx)
  80aee4:	b8 01 00 00 00       	mov    $0x1,%eax
  80aee9:	eb 05                	jmp    80aef0 <inet_aton+0x1cf>
  80aeeb:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80aef0:	83 c4 28             	add    $0x28,%esp
  80aef3:	5b                   	pop    %ebx
  80aef4:	5e                   	pop    %esi
  80aef5:	5f                   	pop    %edi
  80aef6:	5d                   	pop    %ebp
  80aef7:	c3                   	ret    

0080aef8 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80aef8:	55                   	push   %ebp
  80aef9:	89 e5                	mov    %esp,%ebp
  80aefb:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80aefe:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80af01:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af05:	8b 45 08             	mov    0x8(%ebp),%eax
  80af08:	89 04 24             	mov    %eax,(%esp)
  80af0b:	e8 11 fe ff ff       	call   80ad21 <inet_aton>
  80af10:	83 f8 01             	cmp    $0x1,%eax
  80af13:	19 c0                	sbb    %eax,%eax
  80af15:	0b 45 fc             	or     -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80af18:	c9                   	leave  
  80af19:	c3                   	ret    

0080af1a <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80af1a:	55                   	push   %ebp
  80af1b:	89 e5                	mov    %esp,%ebp
  80af1d:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80af20:	8b 45 08             	mov    0x8(%ebp),%eax
  80af23:	89 04 24             	mov    %eax,(%esp)
  80af26:	e8 ca fd ff ff       	call   80acf5 <htonl>
}
  80af2b:	c9                   	leave  
  80af2c:	c3                   	ret    
  80af2d:	00 00                	add    %al,(%eax)
	...

0080af30 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80af30:	55                   	push   %ebp
  80af31:	89 e5                	mov    %esp,%ebp
  80af33:	57                   	push   %edi
  80af34:	56                   	push   %esi
  80af35:	53                   	push   %ebx
  80af36:	83 ec 3c             	sub    $0x3c,%esp
  80af39:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80af3c:	8b 46 78             	mov    0x78(%esi),%eax
  80af3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80af42:	85 c0                	test   %eax,%eax
  80af44:	75 0e                	jne    80af54 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80af46:	8b 56 74             	mov    0x74(%esi),%edx
  80af49:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80af4c:	85 d2                	test   %edx,%edx
  80af4e:	0f 84 4b 01 00 00    	je     80b09f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80af54:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80af5b:	00 
  80af5c:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80af63:	00 
  80af64:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80af6b:	e8 23 d2 ff ff       	call   808193 <pbuf_alloc>
  80af70:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80af72:	85 c0                	test   %eax,%eax
  80af74:	0f 84 25 01 00 00    	je     80b09f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80af7a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80af7f:	77 1c                	ja     80af9d <tcp_zero_window_probe+0x6d>
  80af81:	c7 44 24 08 ac 3c 81 	movl   $0x813cac,0x8(%esp)
  80af88:	00 
  80af89:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80af90:	00 
  80af91:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80af98:	e8 df 59 ff ff       	call   80097c <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80af9d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80afa0:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80afa4:	89 04 24             	mov    %eax,(%esp)
  80afa7:	e8 28 fd ff ff       	call   80acd4 <htons>
  80afac:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80afaf:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80afb3:	89 04 24             	mov    %eax,(%esp)
  80afb6:	e8 19 fd ff ff       	call   80acd4 <htons>
  80afbb:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80afbf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80afc2:	8b 41 10             	mov    0x10(%ecx),%eax
  80afc5:	8b 40 04             	mov    0x4(%eax),%eax
  80afc8:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80afcb:	8b 46 24             	mov    0x24(%esi),%eax
  80afce:	89 04 24             	mov    %eax,(%esp)
  80afd1:	e8 1f fd ff ff       	call   80acf5 <htonl>
  80afd6:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80afd9:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80afdd:	89 04 24             	mov    %eax,(%esp)
  80afe0:	e8 fc fc ff ff       	call   80ace1 <ntohs>
  80afe5:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80afea:	89 04 24             	mov    %eax,(%esp)
  80afed:	e8 e2 fc ff ff       	call   80acd4 <htons>
  80aff2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80aff6:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80affa:	89 04 24             	mov    %eax,(%esp)
  80affd:	e8 d2 fc ff ff       	call   80acd4 <htons>
  80b002:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b006:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b00c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b010:	89 04 24             	mov    %eax,(%esp)
  80b013:	e8 c9 fc ff ff       	call   80ace1 <ntohs>
  80b018:	83 e0 3f             	and    $0x3f,%eax
  80b01b:	80 cc 50             	or     $0x50,%ah
  80b01e:	89 04 24             	mov    %eax,(%esp)
  80b021:	e8 ae fc ff ff       	call   80acd4 <htons>
  80b026:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80b02a:	8b 47 04             	mov    0x4(%edi),%eax
  80b02d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b030:	8b 51 08             	mov    0x8(%ecx),%edx
  80b033:	0f b6 12             	movzbl (%edx),%edx
  80b036:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80b039:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b03f:	8d 46 04             	lea    0x4(%esi),%eax
  80b042:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b045:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b049:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b04d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b054:	00 
  80b055:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b058:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b05c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b060:	89 3c 24             	mov    %edi,(%esp)
  80b063:	e8 68 f9 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80b068:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b06c:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b073:	00 
  80b074:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b07b:	00 
  80b07c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b080:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b084:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b087:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80b08b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b08f:	89 3c 24             	mov    %edi,(%esp)
  80b092:	e8 86 ea ff ff       	call   809b1d <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b097:	89 3c 24             	mov    %edi,(%esp)
  80b09a:	e8 39 ce ff ff       	call   807ed8 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b09f:	83 c4 3c             	add    $0x3c,%esp
  80b0a2:	5b                   	pop    %ebx
  80b0a3:	5e                   	pop    %esi
  80b0a4:	5f                   	pop    %edi
  80b0a5:	5d                   	pop    %ebp
  80b0a6:	c3                   	ret    

0080b0a7 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80b0a7:	55                   	push   %ebp
  80b0a8:	89 e5                	mov    %esp,%ebp
  80b0aa:	57                   	push   %edi
  80b0ab:	56                   	push   %esi
  80b0ac:	53                   	push   %ebx
  80b0ad:	83 ec 3c             	sub    $0x3c,%esp
  80b0b0:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b0b3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b0ba:	00 
  80b0bb:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b0c2:	00 
  80b0c3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b0ca:	e8 c4 d0 ff ff       	call   808193 <pbuf_alloc>
  80b0cf:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80b0d1:	85 c0                	test   %eax,%eax
  80b0d3:	0f 84 1b 01 00 00    	je     80b1f4 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b0d9:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b0de:	77 1c                	ja     80b0fc <tcp_keepalive+0x55>
  80b0e0:	c7 44 24 08 ac 3c 81 	movl   $0x813cac,0x8(%esp)
  80b0e7:	00 
  80b0e8:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80b0ef:	00 
  80b0f0:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b0f7:	e8 80 58 ff ff       	call   80097c <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b0fc:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b0ff:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b103:	89 04 24             	mov    %eax,(%esp)
  80b106:	e8 c9 fb ff ff       	call   80acd4 <htons>
  80b10b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b10e:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b112:	89 04 24             	mov    %eax,(%esp)
  80b115:	e8 ba fb ff ff       	call   80acd4 <htons>
  80b11a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80b11e:	8b 46 54             	mov    0x54(%esi),%eax
  80b121:	83 e8 01             	sub    $0x1,%eax
  80b124:	89 04 24             	mov    %eax,(%esp)
  80b127:	e8 c9 fb ff ff       	call   80acf5 <htonl>
  80b12c:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b12f:	8b 46 24             	mov    0x24(%esi),%eax
  80b132:	89 04 24             	mov    %eax,(%esp)
  80b135:	e8 bb fb ff ff       	call   80acf5 <htonl>
  80b13a:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b13d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b141:	89 04 24             	mov    %eax,(%esp)
  80b144:	e8 98 fb ff ff       	call   80ace1 <ntohs>
  80b149:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b14e:	89 04 24             	mov    %eax,(%esp)
  80b151:	e8 7e fb ff ff       	call   80acd4 <htons>
  80b156:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b15a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b15e:	89 04 24             	mov    %eax,(%esp)
  80b161:	e8 6e fb ff ff       	call   80acd4 <htons>
  80b166:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b16a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b170:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b174:	89 04 24             	mov    %eax,(%esp)
  80b177:	e8 65 fb ff ff       	call   80ace1 <ntohs>
  80b17c:	83 e0 3f             	and    $0x3f,%eax
  80b17f:	80 cc 50             	or     $0x50,%ah
  80b182:	89 04 24             	mov    %eax,(%esp)
  80b185:	e8 4a fb ff ff       	call   80acd4 <htons>
  80b18a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b18e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b194:	8d 46 04             	lea    0x4(%esi),%eax
  80b197:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b19a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b19e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b1a2:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b1a9:	00 
  80b1aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b1ad:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b1b1:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b1b5:	89 3c 24             	mov    %edi,(%esp)
  80b1b8:	e8 13 f8 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80b1bd:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b1c1:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b1c8:	00 
  80b1c9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b1d0:	00 
  80b1d1:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b1d5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b1d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b1dc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b1e0:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b1e4:	89 3c 24             	mov    %edi,(%esp)
  80b1e7:	e8 31 e9 ff ff       	call   809b1d <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b1ec:	89 3c 24             	mov    %edi,(%esp)
  80b1ef:	e8 e4 cc ff ff       	call   807ed8 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b1f4:	83 c4 3c             	add    $0x3c,%esp
  80b1f7:	5b                   	pop    %ebx
  80b1f8:	5e                   	pop    %esi
  80b1f9:	5f                   	pop    %edi
  80b1fa:	5d                   	pop    %ebp
  80b1fb:	c3                   	ret    

0080b1fc <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80b1fc:	55                   	push   %ebp
  80b1fd:	89 e5                	mov    %esp,%ebp
  80b1ff:	57                   	push   %edi
  80b200:	56                   	push   %esi
  80b201:	53                   	push   %ebx
  80b202:	83 ec 3c             	sub    $0x3c,%esp
  80b205:	8b 7d 14             	mov    0x14(%ebp),%edi
  80b208:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80b20c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80b210:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80b214:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b218:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b21f:	00 
  80b220:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b227:	00 
  80b228:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b22f:	e8 5f cf ff ff       	call   808193 <pbuf_alloc>
  80b234:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80b236:	85 c0                	test   %eax,%eax
  80b238:	0f 84 15 01 00 00    	je     80b353 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b23e:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b243:	77 1c                	ja     80b261 <tcp_rst+0x65>
  80b245:	c7 44 24 08 ac 3c 81 	movl   $0x813cac,0x8(%esp)
  80b24c:	00 
  80b24d:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80b254:	00 
  80b255:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b25c:	e8 1b 57 ff ff       	call   80097c <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b261:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80b264:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80b268:	89 04 24             	mov    %eax,(%esp)
  80b26b:	e8 64 fa ff ff       	call   80acd4 <htons>
  80b270:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80b273:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b277:	89 04 24             	mov    %eax,(%esp)
  80b27a:	e8 55 fa ff ff       	call   80acd4 <htons>
  80b27f:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80b283:	8b 45 08             	mov    0x8(%ebp),%eax
  80b286:	89 04 24             	mov    %eax,(%esp)
  80b289:	e8 67 fa ff ff       	call   80acf5 <htonl>
  80b28e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80b291:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b294:	89 04 24             	mov    %eax,(%esp)
  80b297:	e8 59 fa ff ff       	call   80acf5 <htonl>
  80b29c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80b29f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b2a3:	89 04 24             	mov    %eax,(%esp)
  80b2a6:	e8 36 fa ff ff       	call   80ace1 <ntohs>
  80b2ab:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b2b0:	83 c8 14             	or     $0x14,%eax
  80b2b3:	89 04 24             	mov    %eax,(%esp)
  80b2b6:	e8 19 fa ff ff       	call   80acd4 <htons>
  80b2bb:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80b2bf:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80b2c6:	e8 09 fa ff ff       	call   80acd4 <htons>
  80b2cb:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b2cf:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b2d5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b2d9:	89 04 24             	mov    %eax,(%esp)
  80b2dc:	e8 00 fa ff ff       	call   80ace1 <ntohs>
  80b2e1:	83 e0 3f             	and    $0x3f,%eax
  80b2e4:	80 cc 50             	or     $0x50,%ah
  80b2e7:	89 04 24             	mov    %eax,(%esp)
  80b2ea:	e8 e5 f9 ff ff       	call   80acd4 <htons>
  80b2ef:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b2f3:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80b2f9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b2fd:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b301:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b308:	00 
  80b309:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b30d:	8b 45 10             	mov    0x10(%ebp),%eax
  80b310:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b314:	89 34 24             	mov    %esi,(%esp)
  80b317:	e8 b4 f6 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80b31c:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80b320:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b327:	00 
  80b328:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b32f:	00 
  80b330:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80b337:	00 
  80b338:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b33c:	8b 45 10             	mov    0x10(%ebp),%eax
  80b33f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b343:	89 34 24             	mov    %esi,(%esp)
  80b346:	e8 d2 e7 ff ff       	call   809b1d <ip_output>
  pbuf_free(p);
  80b34b:	89 34 24             	mov    %esi,(%esp)
  80b34e:	e8 85 cb ff ff       	call   807ed8 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80b353:	83 c4 3c             	add    $0x3c,%esp
  80b356:	5b                   	pop    %ebx
  80b357:	5e                   	pop    %esi
  80b358:	5f                   	pop    %edi
  80b359:	5d                   	pop    %ebp
  80b35a:	c3                   	ret    

0080b35b <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80b35b:	55                   	push   %ebp
  80b35c:	89 e5                	mov    %esp,%ebp
  80b35e:	57                   	push   %edi
  80b35f:	56                   	push   %esi
  80b360:	53                   	push   %ebx
  80b361:	83 ec 4c             	sub    $0x4c,%esp
  80b364:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80b367:	b8 00 00 00 00       	mov    $0x0,%eax
  80b36c:	39 35 24 e6 b3 00    	cmp    %esi,0xb3e624
  80b372:	0f 84 7e 04 00 00    	je     80b7f6 <tcp_output+0x49b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80b378:	0f b7 56 4e          	movzwl 0x4e(%esi),%edx
  80b37c:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b380:	66 39 d0             	cmp    %dx,%ax
  80b383:	76 02                	jbe    80b387 <tcp_output+0x2c>
  80b385:	89 d0                	mov    %edx,%eax
  80b387:	0f b7 c0             	movzwl %ax,%eax
  80b38a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  80b38d:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80b390:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80b393:	85 ff                	test   %edi,%edi
  80b395:	74 0a                	je     80b3a1 <tcp_output+0x46>
    for (; useg->next != NULL; useg = useg->next);
  80b397:	8b 07                	mov    (%edi),%eax
  80b399:	85 c0                	test   %eax,%eax
  80b39b:	74 04                	je     80b3a1 <tcp_output+0x46>
  80b39d:	89 c7                	mov    %eax,%edi
  80b39f:	eb f6                	jmp    80b397 <tcp_output+0x3c>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b3a1:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80b3a5:	75 0e                	jne    80b3b5 <tcp_output+0x5a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b3a7:	85 db                	test   %ebx,%ebx
  80b3a9:	75 2c                	jne    80b3d7 <tcp_output+0x7c>
  80b3ab:	90                   	nop
  80b3ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80b3b0:	e9 38 04 00 00       	jmp    80b7ed <tcp_output+0x492>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b3b5:	85 db                	test   %ebx,%ebx
  80b3b7:	90                   	nop
  80b3b8:	74 2e                	je     80b3e8 <tcp_output+0x8d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80b3ba:	8b 43 10             	mov    0x10(%ebx),%eax
  80b3bd:	8b 40 04             	mov    0x4(%eax),%eax
  80b3c0:	89 04 24             	mov    %eax,(%esp)
  80b3c3:	e8 52 fb ff ff       	call   80af1a <ntohl>
  80b3c8:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b3cc:	2b 56 48             	sub    0x48(%esi),%edx
  80b3cf:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b3d2:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b3d5:	72 11                	jb     80b3e8 <tcp_output+0x8d>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b3d7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  80b3da:	8d 46 04             	lea    0x4(%esi),%eax
  80b3dd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80b3e0:	89 7d d8             	mov    %edi,-0x28(%ebp)
  80b3e3:	e9 a7 03 00 00       	jmp    80b78f <tcp_output+0x434>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b3e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b3ef:	00 
  80b3f0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b3f7:	00 
  80b3f8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b3ff:	e8 8f cd ff ff       	call   808193 <pbuf_alloc>
  80b404:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80b406:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80b40b:	85 ff                	test   %edi,%edi
  80b40d:	0f 84 e3 03 00 00    	je     80b7f6 <tcp_output+0x49b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b413:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  80b417:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  80b41a:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b41e:	89 04 24             	mov    %eax,(%esp)
  80b421:	e8 ae f8 ff ff       	call   80acd4 <htons>
  80b426:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80b429:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b42d:	89 04 24             	mov    %eax,(%esp)
  80b430:	e8 9f f8 ff ff       	call   80acd4 <htons>
  80b435:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80b439:	8b 46 54             	mov    0x54(%esi),%eax
  80b43c:	89 04 24             	mov    %eax,(%esp)
  80b43f:	e8 b1 f8 ff ff       	call   80acf5 <htonl>
  80b444:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b447:	8b 46 24             	mov    0x24(%esi),%eax
  80b44a:	89 04 24             	mov    %eax,(%esp)
  80b44d:	e8 a3 f8 ff ff       	call   80acf5 <htonl>
  80b452:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80b455:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b459:	89 04 24             	mov    %eax,(%esp)
  80b45c:	e8 80 f8 ff ff       	call   80ace1 <ntohs>
  80b461:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b466:	83 c8 10             	or     $0x10,%eax
  80b469:	89 04 24             	mov    %eax,(%esp)
  80b46c:	e8 63 f8 ff ff       	call   80acd4 <htons>
  80b471:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b475:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b479:	89 04 24             	mov    %eax,(%esp)
  80b47c:	e8 53 f8 ff ff       	call   80acd4 <htons>
  80b481:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80b485:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80b48b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b48f:	89 04 24             	mov    %eax,(%esp)
  80b492:	e8 4a f8 ff ff       	call   80ace1 <ntohs>
  80b497:	83 e0 3f             	and    $0x3f,%eax
  80b49a:	80 cc 50             	or     $0x50,%ah
  80b49d:	89 04 24             	mov    %eax,(%esp)
  80b4a0:	e8 2f f8 ff ff       	call   80acd4 <htons>
  80b4a5:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80b4a9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80b4af:	8d 56 04             	lea    0x4(%esi),%edx
  80b4b2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80b4b5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b4b9:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b4bd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b4c4:	00 
  80b4c5:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b4c9:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b4cd:	89 3c 24             	mov    %edi,(%esp)
  80b4d0:	e8 fb f4 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80b4d5:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b4d9:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b4e0:	00 
  80b4e1:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b4e5:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b4e9:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b4ed:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b4f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b4f4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b4f8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b4fc:	89 3c 24             	mov    %edi,(%esp)
  80b4ff:	e8 19 e6 ff ff       	call   809b1d <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80b504:	89 3c 24             	mov    %edi,(%esp)
  80b507:	e8 cc c9 ff ff       	call   807ed8 <pbuf_free>
  80b50c:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  80b511:	e9 e0 02 00 00       	jmp    80b7f6 <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80b516:	8b 43 10             	mov    0x10(%ebx),%eax
  80b519:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b51d:	89 04 24             	mov    %eax,(%esp)
  80b520:	e8 bc f7 ff ff       	call   80ace1 <ntohs>
  80b525:	a8 04                	test   $0x4,%al
  80b527:	74 1c                	je     80b545 <tcp_output+0x1ea>
  80b529:	c7 44 24 08 68 3e 81 	movl   $0x813e68,0x8(%esp)
  80b530:	00 
  80b531:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80b538:	00 
  80b539:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b540:	e8 37 54 ff ff       	call   80097c <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b545:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b549:	74 1c                	je     80b567 <tcp_output+0x20c>
  80b54b:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80b54f:	a8 40                	test   $0x40,%al
  80b551:	75 14                	jne    80b567 <tcp_output+0x20c>
  80b553:	8b 56 74             	mov    0x74(%esi),%edx
  80b556:	85 d2                	test   %edx,%edx
  80b558:	0f 84 a0 02 00 00    	je     80b7fe <tcp_output+0x4a3>
  80b55e:	83 3a 00             	cmpl   $0x0,(%edx)
  80b561:	0f 84 97 02 00 00    	je     80b7fe <tcp_output+0x4a3>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b567:	8b 03                	mov    (%ebx),%eax
  80b569:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80b56c:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80b570:	74 25                	je     80b597 <tcp_output+0x23c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b572:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b575:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b579:	89 04 24             	mov    %eax,(%esp)
  80b57c:	e8 60 f7 ff ff       	call   80ace1 <ntohs>
  80b581:	83 c8 10             	or     $0x10,%eax
  80b584:	0f b7 c0             	movzwl %ax,%eax
  80b587:	89 04 24             	mov    %eax,(%esp)
  80b58a:	e8 45 f7 ff ff       	call   80acd4 <htons>
  80b58f:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b593:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b597:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b59a:	8b 46 24             	mov    0x24(%esi),%eax
  80b59d:	89 04 24             	mov    %eax,(%esp)
  80b5a0:	e8 50 f7 ff ff       	call   80acf5 <htonl>
  80b5a5:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b5a8:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b5ab:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b5af:	89 04 24             	mov    %eax,(%esp)
  80b5b2:	e8 1d f7 ff ff       	call   80acd4 <htons>
  80b5b7:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b5bb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80b5bf:	74 05                	je     80b5c6 <tcp_output+0x26b>
  80b5c1:	83 3e 00             	cmpl   $0x0,(%esi)
  80b5c4:	75 22                	jne    80b5e8 <tcp_output+0x28d>
    netif = ip_route(&(pcb->remote_ip));
  80b5c6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b5c9:	89 14 24             	mov    %edx,(%esp)
  80b5cc:	e8 f0 e4 ff ff       	call   809ac1 <ip_route>
    if (netif == NULL) {
  80b5d1:	85 c0                	test   %eax,%eax
  80b5d3:	0f 84 c3 00 00 00    	je     80b69c <tcp_output+0x341>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b5d9:	ba 00 00 00 00       	mov    $0x0,%edx
  80b5de:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b5e1:	74 03                	je     80b5e6 <tcp_output+0x28b>
  80b5e3:	8b 50 04             	mov    0x4(%eax),%edx
  80b5e6:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b5e8:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80b5ed:	75 06                	jne    80b5f5 <tcp_output+0x29a>
    pcb->rtime = 0;
  80b5ef:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80b5f5:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80b5f9:	75 19                	jne    80b614 <tcp_output+0x2b9>
    pcb->rttest = tcp_ticks;
  80b5fb:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  80b600:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b603:	8b 43 10             	mov    0x10(%ebx),%eax
  80b606:	8b 40 04             	mov    0x4(%eax),%eax
  80b609:	89 04 24             	mov    %eax,(%esp)
  80b60c:	e8 09 f9 ff ff       	call   80af1a <ntohl>
  80b611:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b614:	8b 43 04             	mov    0x4(%ebx),%eax
  80b617:	8b 53 10             	mov    0x10(%ebx),%edx
  80b61a:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b61e:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b622:	8b 43 04             	mov    0x4(%ebx),%eax
  80b625:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b629:	8b 43 04             	mov    0x4(%ebx),%eax
  80b62c:	8b 53 10             	mov    0x10(%ebx),%edx
  80b62f:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80b632:	8b 43 10             	mov    0x10(%ebx),%eax
  80b635:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b63b:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80b63e:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b641:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80b645:	89 54 24 10          	mov    %edx,0x10(%esp)
  80b649:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b650:	00 
  80b651:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b654:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b658:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b65b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b65f:	89 04 24             	mov    %eax,(%esp)
  80b662:	e8 69 f3 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80b667:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b66b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b672:	00 
  80b673:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b677:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b67b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b67f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b683:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b686:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b68a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b68d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b691:	8b 43 04             	mov    0x4(%ebx),%eax
  80b694:	89 04 24             	mov    %eax,(%esp)
  80b697:	e8 81 e4 ff ff       	call   809b1d <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b69c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b69f:	8b 40 04             	mov    0x4(%eax),%eax
  80b6a2:	89 04 24             	mov    %eax,(%esp)
  80b6a5:	e8 70 f8 ff ff       	call   80af1a <ntohl>
  80b6aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b6ad:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b6b1:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b6b8:	89 04 24             	mov    %eax,(%esp)
  80b6bb:	e8 21 f6 ff ff       	call   80ace1 <ntohs>
  80b6c0:	a8 01                	test   $0x1,%al
  80b6c2:	75 1b                	jne    80b6df <tcp_output+0x384>
  80b6c4:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6c7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b6cb:	89 04 24             	mov    %eax,(%esp)
  80b6ce:	e8 0e f6 ff ff       	call   80ace1 <ntohs>
  80b6d3:	89 c2                	mov    %eax,%edx
  80b6d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6da:	f6 c2 02             	test   $0x2,%dl
  80b6dd:	74 05                	je     80b6e4 <tcp_output+0x389>
  80b6df:	b8 01 00 00 00       	mov    $0x1,%eax
  80b6e4:	0f b7 ff             	movzwl %di,%edi
  80b6e7:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80b6ea:	03 7d dc             	add    -0x24(%ebp),%edi
  80b6ed:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b6f0:	39 7e 58             	cmp    %edi,0x58(%esi)
  80b6f3:	79 03                	jns    80b6f8 <tcp_output+0x39d>
      pcb->snd_max = pcb->snd_nxt;
  80b6f5:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b6f8:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b6fc:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6ff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b703:	89 04 24             	mov    %eax,(%esp)
  80b706:	e8 d6 f5 ff ff       	call   80ace1 <ntohs>
  80b70b:	a8 01                	test   $0x1,%al
  80b70d:	75 18                	jne    80b727 <tcp_output+0x3cc>
  80b70f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b712:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b716:	89 04 24             	mov    %eax,(%esp)
  80b719:	e8 c3 f5 ff ff       	call   80ace1 <ntohs>
  80b71e:	ba 00 00 00 00       	mov    $0x0,%edx
  80b723:	a8 02                	test   $0x2,%al
  80b725:	74 05                	je     80b72c <tcp_output+0x3d1>
  80b727:	ba 01 00 00 00       	mov    $0x1,%edx
  80b72c:	0f b7 ff             	movzwl %di,%edi
  80b72f:	01 fa                	add    %edi,%edx
  80b731:	74 4d                	je     80b780 <tcp_output+0x425>
      seg->next = NULL;
  80b733:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b739:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b73d:	75 08                	jne    80b747 <tcp_output+0x3ec>
        pcb->unacked = seg;
  80b73f:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b742:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b745:	eb 41                	jmp    80b788 <tcp_output+0x42d>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b747:	8b 43 10             	mov    0x10(%ebx),%eax
  80b74a:	8b 40 04             	mov    0x4(%eax),%eax
  80b74d:	89 04 24             	mov    %eax,(%esp)
  80b750:	e8 c5 f7 ff ff       	call   80af1a <ntohl>
  80b755:	89 c7                	mov    %eax,%edi
  80b757:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b75a:	8b 42 10             	mov    0x10(%edx),%eax
  80b75d:	8b 40 04             	mov    0x4(%eax),%eax
  80b760:	89 04 24             	mov    %eax,(%esp)
  80b763:	e8 b2 f7 ff ff       	call   80af1a <ntohl>
  80b768:	39 c7                	cmp    %eax,%edi
  80b76a:	79 0a                	jns    80b776 <tcp_output+0x41b>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b76c:	8b 46 78             	mov    0x78(%esi),%eax
  80b76f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80b771:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b774:	eb 12                	jmp    80b788 <tcp_output+0x42d>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b776:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b779:	89 18                	mov    %ebx,(%eax)
  80b77b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b77e:	eb 08                	jmp    80b788 <tcp_output+0x42d>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b780:	89 1c 24             	mov    %ebx,(%esp)
  80b783:	e8 c9 d2 ff ff       	call   808a51 <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b788:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b78b:	85 db                	test   %ebx,%ebx
  80b78d:	74 5e                	je     80b7ed <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80b78f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b792:	8b 40 04             	mov    0x4(%eax),%eax
  80b795:	89 04 24             	mov    %eax,(%esp)
  80b798:	e8 7d f7 ff ff       	call   80af1a <ntohl>
  80b79d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b7a1:	2b 56 48             	sub    0x48(%esi),%edx
  80b7a4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b7a7:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b7aa:	0f 83 66 fd ff ff    	jae    80b516 <tcp_output+0x1bb>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b7b0:	85 db                	test   %ebx,%ebx
  80b7b2:	74 39                	je     80b7ed <tcp_output+0x492>
  80b7b4:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80b7bb:	75 30                	jne    80b7ed <tcp_output+0x492>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80b7bd:	8b 43 10             	mov    0x10(%ebx),%eax
  80b7c0:	8b 40 04             	mov    0x4(%eax),%eax
  80b7c3:	89 04 24             	mov    %eax,(%esp)
  80b7c6:	e8 4f f7 ff ff       	call   80af1a <ntohl>
  80b7cb:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b7cf:	2b 56 48             	sub    0x48(%esi),%edx
  80b7d2:	01 c2                	add    %eax,%edx
  80b7d4:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b7d8:	39 c2                	cmp    %eax,%edx
  80b7da:	76 11                	jbe    80b7ed <tcp_output+0x492>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b7dc:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80b7e3:	00 00 00 
    pcb->persist_backoff = 1;
  80b7e6:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b7ed:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80b7f1:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80b7f6:	83 c4 4c             	add    $0x4c,%esp
  80b7f9:	5b                   	pop    %ebx
  80b7fa:	5e                   	pop    %esi
  80b7fb:	5f                   	pop    %edi
  80b7fc:	5d                   	pop    %ebp
  80b7fd:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b7fe:	a8 a0                	test   $0xa0,%al
  80b800:	0f 85 61 fd ff ff    	jne    80b567 <tcp_output+0x20c>
  80b806:	eb a8                	jmp    80b7b0 <tcp_output+0x455>

0080b808 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b808:	55                   	push   %ebp
  80b809:	89 e5                	mov    %esp,%ebp
  80b80b:	53                   	push   %ebx
  80b80c:	83 ec 14             	sub    $0x14,%esp
  80b80f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b812:	8b 43 78             	mov    0x78(%ebx),%eax
  80b815:	85 c0                	test   %eax,%eax
  80b817:	74 34                	je     80b84d <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b819:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80b81b:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80b81e:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80b820:	8b 43 78             	mov    0x78(%ebx),%eax
  80b823:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b826:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b829:	8b 40 10             	mov    0x10(%eax),%eax
  80b82c:	8b 40 04             	mov    0x4(%eax),%eax
  80b82f:	89 04 24             	mov    %eax,(%esp)
  80b832:	e8 e3 f6 ff ff       	call   80af1a <ntohl>
  80b837:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b83a:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b83e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b845:	89 1c 24             	mov    %ebx,(%esp)
  80b848:	e8 0e fb ff ff       	call   80b35b <tcp_output>
}
  80b84d:	83 c4 14             	add    $0x14,%esp
  80b850:	5b                   	pop    %ebx
  80b851:	5d                   	pop    %ebp
  80b852:	c3                   	ret    

0080b853 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b853:	55                   	push   %ebp
  80b854:	89 e5                	mov    %esp,%ebp
  80b856:	53                   	push   %ebx
  80b857:	83 ec 14             	sub    $0x14,%esp
  80b85a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b85d:	8b 43 78             	mov    0x78(%ebx),%eax
  80b860:	85 c0                	test   %eax,%eax
  80b862:	74 3e                	je     80b8a2 <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b864:	89 c2                	mov    %eax,%edx
  80b866:	8b 00                	mov    (%eax),%eax
  80b868:	85 c0                	test   %eax,%eax
  80b86a:	75 f8                	jne    80b864 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b86c:	8b 43 74             	mov    0x74(%ebx),%eax
  80b86f:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b871:	8b 43 78             	mov    0x78(%ebx),%eax
  80b874:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b877:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b87e:	8b 40 10             	mov    0x10(%eax),%eax
  80b881:	8b 40 04             	mov    0x4(%eax),%eax
  80b884:	89 04 24             	mov    %eax,(%esp)
  80b887:	e8 8e f6 ff ff       	call   80af1a <ntohl>
  80b88c:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b88f:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b893:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b89a:	89 1c 24             	mov    %ebx,(%esp)
  80b89d:	e8 b9 fa ff ff       	call   80b35b <tcp_output>
}
  80b8a2:	83 c4 14             	add    $0x14,%esp
  80b8a5:	5b                   	pop    %ebx
  80b8a6:	5d                   	pop    %ebp
  80b8a7:	c3                   	ret    

0080b8a8 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b8a8:	55                   	push   %ebp
  80b8a9:	89 e5                	mov    %esp,%ebp
  80b8ab:	57                   	push   %edi
  80b8ac:	56                   	push   %esi
  80b8ad:	53                   	push   %ebx
  80b8ae:	83 ec 5c             	sub    $0x5c,%esp
  80b8b1:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b8b4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b8b7:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b8bb:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  80b8bf:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b8c3:	88 4d bb             	mov    %cl,-0x45(%ebp)
  80b8c6:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b8ca:	88 45 a8             	mov    %al,-0x58(%ebp)
  80b8cd:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b8d1:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%ebp)
  80b8d6:	74 20                	je     80b8f8 <tcp_enqueue+0x50>
  80b8d8:	84 c0                	test   %al,%al
  80b8da:	74 1c                	je     80b8f8 <tcp_enqueue+0x50>
  80b8dc:	c7 44 24 08 dc 3c 81 	movl   $0x813cdc,0x8(%esp)
  80b8e3:	00 
  80b8e4:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b8eb:	00 
  80b8ec:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b8f3:	e8 84 50 ff ff       	call   80097c <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b8f8:	85 d2                	test   %edx,%edx
  80b8fa:	0f 95 45 c1          	setne  -0x3f(%ebp)
  80b8fe:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b902:	0f 95 45 cb          	setne  -0x35(%ebp)
  80b906:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80b90a:	74 22                	je     80b92e <tcp_enqueue+0x86>
  80b90c:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80b910:	74 1c                	je     80b92e <tcp_enqueue+0x86>
  80b912:	c7 44 24 08 1c 3d 81 	movl   $0x813d1c,0x8(%esp)
  80b919:	00 
  80b91a:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b921:	00 
  80b922:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b929:	e8 4e 50 ff ff       	call   80097c <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b92e:	0f b7 4d c2          	movzwl -0x3e(%ebp),%ecx
  80b932:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80b936:	76 0e                	jbe    80b946 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b938:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b93c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b941:	e9 34 06 00 00       	jmp    80bf7a <tcp_enqueue+0x6d2>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b946:	8b 4f 68             	mov    0x68(%edi),%ecx
  80b949:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b94c:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80b950:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b954:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b958:	76 0e                	jbe    80b968 <tcp_enqueue+0xc0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b95a:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b95e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b963:	e9 12 06 00 00       	jmp    80bf7a <tcp_enqueue+0x6d2>
  }
  if (queuelen != 0) {
  80b968:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80b96d:	74 74                	je     80b9e3 <tcp_enqueue+0x13b>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b96f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b973:	74 4c                	je     80b9c1 <tcp_enqueue+0x119>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b975:	89 c1                	mov    %eax,%ecx
  80b977:	c0 e9 02             	shr    $0x2,%cl
  80b97a:	c1 e1 0c             	shl    $0xc,%ecx
  80b97d:	66 81 c1 00 50       	add    $0x5000,%cx
  80b982:	66 89 4d c6          	mov    %cx,-0x3a(%ebp)
  80b986:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80b989:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  80b98d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80b991:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80b998:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b99d:	0f b6 4d a8          	movzbl -0x58(%ebp),%ecx
  80b9a1:	83 e1 01             	and    $0x1,%ecx
  80b9a4:	89 4d bc             	mov    %ecx,-0x44(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b9a7:	0f b6 d0             	movzbl %al,%edx
  80b9aa:	89 55 cc             	mov    %edx,-0x34(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b9ad:	0f b6 c0             	movzbl %al,%eax
  80b9b0:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b9b4:	0f b6 4d bb          	movzbl -0x45(%ebp),%ecx
  80b9b8:	66 89 4d c8          	mov    %cx,-0x38(%ebp)
  80b9bc:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80b9bf:	eb 55                	jmp    80ba16 <tcp_enqueue+0x16e>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b9c1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b9c5:	75 ae                	jne    80b975 <tcp_enqueue+0xcd>
  80b9c7:	c7 44 24 08 64 3d 81 	movl   $0x813d64,0x8(%esp)
  80b9ce:	00 
  80b9cf:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80b9d6:	00 
  80b9d7:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80b9de:	e8 99 4f ff ff       	call   80097c <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80b9e3:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b9e7:	75 06                	jne    80b9ef <tcp_enqueue+0x147>
  80b9e9:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b9ed:	74 86                	je     80b975 <tcp_enqueue+0xcd>
  80b9ef:	c7 44 24 08 a0 3d 81 	movl   $0x813da0,0x8(%esp)
  80b9f6:	00 
  80b9f7:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80b9fe:	00 
  80b9ff:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80ba06:	e8 71 4f ff ff       	call   80097c <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80ba0b:	0f b7 f6             	movzwl %si,%esi
  80ba0e:	01 75 d8             	add    %esi,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80ba11:	01 75 d0             	add    %esi,-0x30(%ebp)
  80ba14:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80ba16:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ba19:	0f b7 78 34          	movzwl 0x34(%eax),%edi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80ba1d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80ba24:	e8 5b bd ff ff       	call   807784 <memp_malloc>
  80ba29:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80ba2b:	85 c0                	test   %eax,%eax
  80ba2d:	0f 84 d8 04 00 00    	je     80bf0b <tcp_enqueue+0x663>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80ba33:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80ba39:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80ba40:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ba44:	75 05                	jne    80ba4b <tcp_enqueue+0x1a3>
  80ba46:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80ba49:	eb 22                	jmp    80ba6d <tcp_enqueue+0x1c5>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80ba4b:	85 f6                	test   %esi,%esi
  80ba4d:	75 1c                	jne    80ba6b <tcp_enqueue+0x1c3>
  80ba4f:	c7 44 24 08 7f 3e 81 	movl   $0x813e7f,0x8(%esp)
  80ba56:	00 
  80ba57:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80ba5e:	00 
  80ba5f:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80ba66:	e8 11 4f ff ff       	call   80097c <_panic>
      useg->next = seg;
  80ba6b:	89 06                	mov    %eax,(%esi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80ba6d:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  80ba71:	66 39 fe             	cmp    %di,%si
  80ba74:	76 02                	jbe    80ba78 <tcp_enqueue+0x1d0>
  80ba76:	89 fe                	mov    %edi,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80ba78:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80ba7c:	74 69                	je     80bae7 <tcp_enqueue+0x23f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80ba7e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ba85:	00 
  80ba86:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80ba89:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ba8d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ba94:	e8 fa c6 ff ff       	call   808193 <pbuf_alloc>
  80ba99:	89 43 04             	mov    %eax,0x4(%ebx)
  80ba9c:	85 c0                	test   %eax,%eax
  80ba9e:	0f 84 6c 04 00 00    	je     80bf10 <tcp_enqueue+0x668>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80baa4:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80baa8:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80baac:	73 1c                	jae    80baca <tcp_enqueue+0x222>
  80baae:	c7 44 24 08 d4 3d 81 	movl   $0x813dd4,0x8(%esp)
  80bab5:	00 
  80bab6:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80babd:	00 
  80babe:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80bac5:	e8 b2 4e ff ff       	call   80097c <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80baca:	89 04 24             	mov    %eax,(%esp)
  80bacd:	e8 9e bf ff ff       	call   807a70 <pbuf_clen>
  80bad2:	0f b6 c0             	movzbl %al,%eax
  80bad5:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  80bad9:	8b 43 04             	mov    0x4(%ebx),%eax
  80badc:	8b 40 04             	mov    0x4(%eax),%eax
  80badf:	89 43 08             	mov    %eax,0x8(%ebx)
  80bae2:	e9 1e 01 00 00       	jmp    80bc05 <tcp_enqueue+0x35d>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80bae7:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  80baeb:	0f 84 8b 00 00 00    	je     80bb7c <tcp_enqueue+0x2d4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80baf1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80baf8:	00 
  80baf9:	0f b7 c6             	movzwl %si,%eax
  80bafc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb07:	e8 87 c6 ff ff       	call   808193 <pbuf_alloc>
  80bb0c:	89 43 04             	mov    %eax,0x4(%ebx)
  80bb0f:	85 c0                	test   %eax,%eax
  80bb11:	0f 84 fe 03 00 00    	je     80bf15 <tcp_enqueue+0x66d>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80bb17:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80bb1b:	76 1c                	jbe    80bb39 <tcp_enqueue+0x291>
  80bb1d:	c7 44 24 08 fc 3d 81 	movl   $0x813dfc,0x8(%esp)
  80bb24:	00 
  80bb25:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80bb2c:	00 
  80bb2d:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80bb34:	e8 43 4e ff ff       	call   80097c <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bb39:	89 04 24             	mov    %eax,(%esp)
  80bb3c:	e8 2f bf ff ff       	call   807a70 <pbuf_clen>
  80bb41:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  80bb43:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80bb47:	74 1c                	je     80bb65 <tcp_enqueue+0x2bd>
        MEMCPY(seg->p->payload, ptr, seglen);
  80bb49:	0f b7 c6             	movzwl %si,%eax
  80bb4c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bb50:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80bb53:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb57:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb5a:	8b 40 04             	mov    0x4(%eax),%eax
  80bb5d:	89 04 24             	mov    %eax,(%esp)
  80bb60:	e8 ec 57 ff ff       	call   801351 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bb65:	89 fa                	mov    %edi,%edx
  80bb67:	0f b6 c2             	movzbl %dl,%eax
  80bb6a:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80bb6e:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb71:	8b 40 04             	mov    0x4(%eax),%eax
  80bb74:	89 43 08             	mov    %eax,0x8(%ebx)
  80bb77:	e9 89 00 00 00       	jmp    80bc05 <tcp_enqueue+0x35d>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80bb7c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80bb83:	00 
  80bb84:	0f b7 c6             	movzwl %si,%eax
  80bb87:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb8b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb92:	e8 fc c5 ff ff       	call   808193 <pbuf_alloc>
  80bb97:	89 c7                	mov    %eax,%edi
  80bb99:	85 c0                	test   %eax,%eax
  80bb9b:	0f 84 79 03 00 00    	je     80bf1a <tcp_enqueue+0x672>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80bba1:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80bba4:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  80bba7:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80bbaa:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bbb1:	00 
  80bbb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bbb9:	00 
  80bbba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bbc1:	e8 cd c5 ff ff       	call   808193 <pbuf_alloc>
  80bbc6:	89 43 04             	mov    %eax,0x4(%ebx)
  80bbc9:	85 c0                	test   %eax,%eax
  80bbcb:	75 12                	jne    80bbdf <tcp_enqueue+0x337>
  80bbcd:	89 fb                	mov    %edi,%ebx
  80bbcf:	8b 7d dc             	mov    -0x24(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80bbd2:	89 1c 24             	mov    %ebx,(%esp)
  80bbd5:	e8 fe c2 ff ff       	call   807ed8 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80bbda:	e9 4b 03 00 00       	jmp    80bf2a <tcp_enqueue+0x682>
      }
      queuelen += pbuf_clen(seg->p);
  80bbdf:	89 04 24             	mov    %eax,(%esp)
  80bbe2:	e8 89 be ff ff       	call   807a70 <pbuf_clen>
  80bbe7:	0f b6 c0             	movzbl %al,%eax
  80bbea:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80bbee:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80bbf2:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80bbf6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bbfa:	8b 43 04             	mov    0x4(%ebx),%eax
  80bbfd:	89 04 24             	mov    %eax,(%esp)
  80bc00:	e8 96 be ff ff       	call   807a9b <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80bc05:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  80bc0a:	0f 87 12 03 00 00    	ja     80bf22 <tcp_enqueue+0x67a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80bc10:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80bc14:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80bc1b:	00 
  80bc1c:	8b 43 04             	mov    0x4(%ebx),%eax
  80bc1f:	89 04 24             	mov    %eax,(%esp)
  80bc22:	e8 3c bf ff ff       	call   807b63 <pbuf_header>
  80bc27:	84 c0                	test   %al,%al
  80bc29:	0f 85 f8 02 00 00    	jne    80bf27 <tcp_enqueue+0x67f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80bc2f:	8b 43 04             	mov    0x4(%ebx),%eax
  80bc32:	8b 78 04             	mov    0x4(%eax),%edi
  80bc35:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80bc38:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80bc3b:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  80bc3f:	89 04 24             	mov    %eax,(%esp)
  80bc42:	e8 8d f0 ff ff       	call   80acd4 <htons>
  80bc47:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80bc4a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc4d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80bc50:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80bc54:	89 04 24             	mov    %eax,(%esp)
  80bc57:	e8 78 f0 ff ff       	call   80acd4 <htons>
  80bc5c:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80bc60:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc63:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80bc66:	89 0c 24             	mov    %ecx,(%esp)
  80bc69:	e8 87 f0 ff ff       	call   80acf5 <htonl>
  80bc6e:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80bc71:	8b 43 10             	mov    0x10(%ebx),%eax
  80bc74:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80bc7a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc7d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bc81:	89 04 24             	mov    %eax,(%esp)
  80bc84:	e8 58 f0 ff ff       	call   80ace1 <ntohs>
  80bc89:	83 e0 c0             	and    $0xffffffc0,%eax
  80bc8c:	66 0b 45 c8          	or     -0x38(%ebp),%ax
  80bc90:	0f b7 c0             	movzwl %ax,%eax
  80bc93:	89 04 24             	mov    %eax,(%esp)
  80bc96:	e8 39 f0 ff ff       	call   80acd4 <htons>
  80bc9b:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80bc9f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80bca3:	75 23                	jne    80bcc8 <tcp_enqueue+0x420>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80bca5:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bca8:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bcac:	89 04 24             	mov    %eax,(%esp)
  80bcaf:	e8 2d f0 ff ff       	call   80ace1 <ntohs>
  80bcb4:	83 e0 3f             	and    $0x3f,%eax
  80bcb7:	80 cc 50             	or     $0x50,%ah
  80bcba:	89 04 24             	mov    %eax,(%esp)
  80bcbd:	e8 12 f0 ff ff       	call   80acd4 <htons>
  80bcc2:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80bcc6:	eb 3e                	jmp    80bd06 <tcp_enqueue+0x45e>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80bcc8:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bccb:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bccf:	89 04 24             	mov    %eax,(%esp)
  80bcd2:	e8 0a f0 ff ff       	call   80ace1 <ntohs>
  80bcd7:	83 e0 3f             	and    $0x3f,%eax
  80bcda:	66 0b 45 c6          	or     -0x3a(%ebp),%ax
  80bcde:	0f b7 c0             	movzwl %ax,%eax
  80bce1:	89 04 24             	mov    %eax,(%esp)
  80bce4:	e8 eb ef ff ff       	call   80acd4 <htons>
  80bce9:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80bced:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80bcf0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bcf4:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80bcf7:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bcfb:	8b 43 08             	mov    0x8(%ebx),%eax
  80bcfe:	89 04 24             	mov    %eax,(%esp)
  80bd01:	e8 4b 56 ff ff       	call   801351 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80bd06:	66 29 75 e4          	sub    %si,-0x1c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80bd0a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bd0e:	0f 84 f7 fc ff ff    	je     80ba0b <tcp_enqueue+0x163>
  80bd14:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80bd19:	0f 85 ec fc ff ff    	jne    80ba0b <tcp_enqueue+0x163>
  80bd1f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bd22:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80bd25:	8b 4f 74             	mov    0x74(%edi),%ecx
  80bd28:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80bd2b:	85 c9                	test   %ecx,%ecx
  80bd2d:	0f 84 1f 01 00 00    	je     80be52 <tcp_enqueue+0x5aa>
  80bd33:	89 ca                	mov    %ecx,%edx
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80bd35:	89 d0                	mov    %edx,%eax
  80bd37:	8b 12                	mov    (%edx),%edx
  80bd39:	85 d2                	test   %edx,%edx
  80bd3b:	75 f8                	jne    80bd35 <tcp_enqueue+0x48d>
  80bd3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bd40:	85 c0                	test   %eax,%eax
  80bd42:	0f 84 0a 01 00 00    	je     80be52 <tcp_enqueue+0x5aa>
    TCP_TCPLEN(useg) != 0 &&
  80bd48:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd4c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  80bd50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bd53:	8b 42 10             	mov    0x10(%edx),%eax
  80bd56:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd5a:	89 04 24             	mov    %eax,(%esp)
  80bd5d:	e8 7f ef ff ff       	call   80ace1 <ntohs>
  80bd62:	a8 01                	test   $0x1,%al
  80bd64:	75 1b                	jne    80bd81 <tcp_enqueue+0x4d9>
  80bd66:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bd69:	8b 41 10             	mov    0x10(%ecx),%eax
  80bd6c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd70:	89 04 24             	mov    %eax,(%esp)
  80bd73:	e8 69 ef ff ff       	call   80ace1 <ntohs>
  80bd78:	ba 00 00 00 00       	mov    $0x0,%edx
  80bd7d:	a8 02                	test   $0x2,%al
  80bd7f:	74 05                	je     80bd86 <tcp_enqueue+0x4de>
  80bd81:	ba 01 00 00 00       	mov    $0x1,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bd86:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  80bd8a:	01 c2                	add    %eax,%edx
  80bd8c:	0f 84 f0 01 00 00    	je     80bf82 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80bd92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bd95:	8b 42 10             	mov    0x10(%edx),%eax
  80bd98:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd9c:	89 04 24             	mov    %eax,(%esp)
  80bd9f:	e8 3d ef ff ff       	call   80ace1 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bda4:	a8 03                	test   $0x3,%al
  80bda6:	0f 85 d6 01 00 00    	jne    80bf82 <tcp_enqueue+0x6da>
  80bdac:	f6 45 bb 03          	testb  $0x3,-0x45(%ebp)
  80bdb0:	0f 85 cc 01 00 00    	jne    80bf82 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80bdb6:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bdb9:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80bdbd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bdc0:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80bdc4:	01 c2                	add    %eax,%edx
  80bdc6:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80bdca:	39 c2                	cmp    %eax,%edx
  80bdcc:	0f 8f b0 01 00 00    	jg     80bf82 <tcp_enqueue+0x6da>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80bdd2:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80bdd9:	ff 
  80bdda:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80bddd:	8b 42 04             	mov    0x4(%edx),%eax
  80bde0:	89 04 24             	mov    %eax,(%esp)
  80bde3:	e8 7b bd ff ff       	call   807b63 <pbuf_header>
  80bde8:	84 c0                	test   %al,%al
  80bdea:	74 1c                	je     80be08 <tcp_enqueue+0x560>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80bdec:	c7 44 24 08 8c 3e 81 	movl   $0x813e8c,0x8(%esp)
  80bdf3:	00 
  80bdf4:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80bdfb:	00 
  80bdfc:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80be03:	e8 74 4b ff ff       	call   80097c <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80be08:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80be0b:	8b 41 04             	mov    0x4(%ecx),%eax
  80be0e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be15:	8b 42 04             	mov    0x4(%edx),%eax
  80be18:	89 04 24             	mov    %eax,(%esp)
  80be1b:	e8 7b bc ff ff       	call   807a9b <pbuf_cat>
    useg->len += queue->len;
  80be20:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80be23:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80be27:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be2a:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80be2e:	8b 01                	mov    (%ecx),%eax
  80be30:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80be32:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
  80be35:	0f 94 c0             	sete   %al
  80be38:	0f b6 c0             	movzbl %al,%eax
  80be3b:	83 e8 01             	sub    $0x1,%eax
  80be3e:	21 c3                	and    %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80be40:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80be44:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80be4b:	e8 f0 b8 ff ff       	call   807740 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80be50:	eb 06                	jmp    80be58 <tcp_enqueue+0x5b0>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80be52:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80be55:	89 4f 74             	mov    %ecx,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80be58:	f6 45 bb 02          	testb  $0x2,-0x45(%ebp)
  80be5c:	75 0c                	jne    80be6a <tcp_enqueue+0x5c2>
  80be5e:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80be62:	0f 85 27 01 00 00    	jne    80bf8f <tcp_enqueue+0x6e7>
  80be68:	eb 0f                	jmp    80be79 <tcp_enqueue+0x5d1>
    ++len;
  80be6a:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  80be6f:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80be73:	74 04                	je     80be79 <tcp_enqueue+0x5d1>
    pcb->flags |= TF_FIN;
  80be75:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80be79:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80be7d:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80be80:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80be84:	66 29 47 6e          	sub    %ax,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80be88:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80be8c:	66 89 57 70          	mov    %dx,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80be90:	66 85 d2             	test   %dx,%dx
  80be93:	74 28                	je     80bebd <tcp_enqueue+0x615>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80be95:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80be99:	75 22                	jne    80bebd <tcp_enqueue+0x615>
  80be9b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80be9f:	75 1c                	jne    80bebd <tcp_enqueue+0x615>
  80bea1:	c7 44 24 08 30 3e 81 	movl   $0x813e30,0x8(%esp)
  80bea8:	00 
  80bea9:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80beb0:	00 
  80beb1:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80beb8:	e8 bf 4a ff ff       	call   80097c <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80bebd:	85 db                	test   %ebx,%ebx
  80bebf:	0f 84 b0 00 00 00    	je     80bf75 <tcp_enqueue+0x6cd>
  80bec5:	66 85 f6             	test   %si,%si
  80bec8:	0f 84 a7 00 00 00    	je     80bf75 <tcp_enqueue+0x6cd>
  80bece:	8b 5b 10             	mov    0x10(%ebx),%ebx
  80bed1:	85 db                	test   %ebx,%ebx
  80bed3:	0f 84 9c 00 00 00    	je     80bf75 <tcp_enqueue+0x6cd>
  80bed9:	f6 45 a8 02          	testb  $0x2,-0x58(%ebp)
  80bedd:	8d 76 00             	lea    0x0(%esi),%esi
  80bee0:	0f 85 8f 00 00 00    	jne    80bf75 <tcp_enqueue+0x6cd>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80bee6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80beea:	89 04 24             	mov    %eax,(%esp)
  80beed:	e8 ef ed ff ff       	call   80ace1 <ntohs>
  80bef2:	83 c8 08             	or     $0x8,%eax
  80bef5:	0f b7 c0             	movzwl %ax,%eax
  80bef8:	89 04 24             	mov    %eax,(%esp)
  80befb:	e8 d4 ed ff ff       	call   80acd4 <htons>
  80bf00:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80bf04:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf09:	eb 6f                	jmp    80bf7a <tcp_enqueue+0x6d2>
  80bf0b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf0e:	eb 1a                	jmp    80bf2a <tcp_enqueue+0x682>
  80bf10:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf13:	eb 15                	jmp    80bf2a <tcp_enqueue+0x682>
  80bf15:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf18:	eb 10                	jmp    80bf2a <tcp_enqueue+0x682>
  80bf1a:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf1d:	8d 76 00             	lea    0x0(%esi),%esi
  80bf20:	eb 08                	jmp    80bf2a <tcp_enqueue+0x682>
  80bf22:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf25:	eb 03                	jmp    80bf2a <tcp_enqueue+0x682>
  80bf27:	8b 7d dc             	mov    -0x24(%ebp),%edi
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80bf2a:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80bf2e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bf32:	74 0b                	je     80bf3f <tcp_enqueue+0x697>
    tcp_segs_free(queue);
  80bf34:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bf37:	89 0c 24             	mov    %ecx,(%esp)
  80bf3a:	e8 57 cb ff ff       	call   808a96 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80bf3f:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80bf44:	74 28                	je     80bf6e <tcp_enqueue+0x6c6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80bf46:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80bf4a:	75 22                	jne    80bf6e <tcp_enqueue+0x6c6>
  80bf4c:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80bf50:	75 1c                	jne    80bf6e <tcp_enqueue+0x6c6>
  80bf52:	c7 44 24 08 30 3e 81 	movl   $0x813e30,0x8(%esp)
  80bf59:	00 
  80bf5a:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80bf61:	00 
  80bf62:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80bf69:	e8 0e 4a ff ff       	call   80097c <_panic>
  80bf6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bf73:	eb 05                	jmp    80bf7a <tcp_enqueue+0x6d2>
  80bf75:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80bf7a:	83 c4 5c             	add    $0x5c,%esp
  80bf7d:	5b                   	pop    %ebx
  80bf7e:	5e                   	pop    %esi
  80bf7f:	5f                   	pop    %edi
  80bf80:	5d                   	pop    %ebp
  80bf81:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80bf82:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80bf85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80bf88:	89 10                	mov    %edx,(%eax)
  80bf8a:	e9 c9 fe ff ff       	jmp    80be58 <tcp_enqueue+0x5b0>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80bf8f:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  80bf94:	e9 dc fe ff ff       	jmp    80be75 <tcp_enqueue+0x5cd>

0080bf99 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80bf99:	55                   	push   %ebp
  80bf9a:	89 e5                	mov    %esp,%ebp
  80bf9c:	83 ec 28             	sub    $0x28,%esp
  80bf9f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80bfa2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80bfa5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80bfa8:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  80bfac:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  80bfb0:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80bfb3:	83 fa 04             	cmp    $0x4,%edx
  80bfb6:	74 14                	je     80bfcc <tcp_write+0x33>
  80bfb8:	83 fa 07             	cmp    $0x7,%edx
  80bfbb:	74 0f                	je     80bfcc <tcp_write+0x33>
  80bfbd:	83 fa 02             	cmp    $0x2,%edx
  80bfc0:	74 0a                	je     80bfcc <tcp_write+0x33>
  80bfc2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80bfc7:	83 fa 03             	cmp    $0x3,%edx
  80bfca:	75 42                	jne    80c00e <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80bfcc:	b8 00 00 00 00       	mov    $0x0,%eax
  80bfd1:	66 85 db             	test   %bx,%bx
  80bfd4:	74 38                	je     80c00e <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80bfd6:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bfdd:	00 
  80bfde:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bfe5:	00 
  80bfe6:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80bfec:	89 74 24 10          	mov    %esi,0x10(%esp)
  80bff0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80bff7:	00 
  80bff8:	0f b7 db             	movzwl %bx,%ebx
  80bffb:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80bfff:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c002:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c006:	89 0c 24             	mov    %ecx,(%esp)
  80c009:	e8 9a f8 ff ff       	call   80b8a8 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80c00e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c011:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c014:	89 ec                	mov    %ebp,%esp
  80c016:	5d                   	pop    %ebp
  80c017:	c3                   	ret    

0080c018 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80c018:	55                   	push   %ebp
  80c019:	89 e5                	mov    %esp,%ebp
  80c01b:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80c01e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80c025:	00 
  80c026:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80c02d:	00 
  80c02e:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80c035:	00 
  80c036:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80c03a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c03e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c045:	00 
  80c046:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c04d:	00 
  80c04e:	8b 45 08             	mov    0x8(%ebp),%eax
  80c051:	89 04 24             	mov    %eax,(%esp)
  80c054:	e8 4f f8 ff ff       	call   80b8a8 <tcp_enqueue>
}
  80c059:	c9                   	leave  
  80c05a:	c3                   	ret    
  80c05b:	00 00                	add    %al,(%eax)
  80c05d:	00 00                	add    %al,(%eax)
	...

0080c060 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80c060:	55                   	push   %ebp
  80c061:	89 e5                	mov    %esp,%ebp
  80c063:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80c066:	8b 15 0c 3b 81 00    	mov    0x813b0c,%edx
  80c06c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80c06f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80c075:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80c079:	5d                   	pop    %ebp
  80c07a:	c3                   	ret    

0080c07b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80c07b:	55                   	push   %ebp
  80c07c:	89 e5                	mov    %esp,%ebp
  80c07e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80c081:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c084:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80c087:	8b 55 10             	mov    0x10(%ebp),%edx
  80c08a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80c08d:	5d                   	pop    %ebp
  80c08e:	c3                   	ret    

0080c08f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80c08f:	55                   	push   %ebp
  80c090:	89 e5                	mov    %esp,%ebp
  80c092:	53                   	push   %ebx
  80c093:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80c096:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c09d:	e8 e2 b6 ff ff       	call   807784 <memp_malloc>
  80c0a2:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80c0a4:	85 c0                	test   %eax,%eax
  80c0a6:	74 1c                	je     80c0c4 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80c0a8:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80c0af:	00 
  80c0b0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c0b7:	00 
  80c0b8:	89 04 24             	mov    %eax,(%esp)
  80c0bb:	e8 b6 51 ff ff       	call   801276 <memset>
    pcb->ttl = UDP_TTL;
  80c0c0:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80c0c4:	89 d8                	mov    %ebx,%eax
  80c0c6:	83 c4 14             	add    $0x14,%esp
  80c0c9:	5b                   	pop    %ebx
  80c0ca:	5d                   	pop    %ebp
  80c0cb:	c3                   	ret    

0080c0cc <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80c0cc:	55                   	push   %ebp
  80c0cd:	89 e5                	mov    %esp,%ebp
  80c0cf:	83 ec 18             	sub    $0x18,%esp
  80c0d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80c0d5:	8b 15 20 e6 b3 00    	mov    0xb3e620,%edx
  80c0db:	39 ca                	cmp    %ecx,%edx
  80c0dd:	74 06                	je     80c0e5 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c0df:	85 d2                	test   %edx,%edx
  80c0e1:	75 0e                	jne    80c0f1 <udp_remove+0x25>
  80c0e3:	eb 21                	jmp    80c106 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80c0e5:	8b 42 0c             	mov    0xc(%edx),%eax
  80c0e8:	a3 20 e6 b3 00       	mov    %eax,0xb3e620
  80c0ed:	eb 17                	jmp    80c106 <udp_remove+0x3a>
  80c0ef:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80c0f1:	8b 42 0c             	mov    0xc(%edx),%eax
  80c0f4:	85 c0                	test   %eax,%eax
  80c0f6:	74 0e                	je     80c106 <udp_remove+0x3a>
  80c0f8:	39 c1                	cmp    %eax,%ecx
  80c0fa:	75 f3                	jne    80c0ef <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80c0fc:	8b 41 0c             	mov    0xc(%ecx),%eax
  80c0ff:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c102:	85 c0                	test   %eax,%eax
  80c104:	75 e9                	jne    80c0ef <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80c106:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c10a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c111:	e8 2a b6 ff ff       	call   807740 <memp_free>
}
  80c116:	c9                   	leave  
  80c117:	c3                   	ret    

0080c118 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c118:	55                   	push   %ebp
  80c119:	89 e5                	mov    %esp,%ebp
  80c11b:	57                   	push   %edi
  80c11c:	56                   	push   %esi
  80c11d:	53                   	push   %ebx
  80c11e:	83 ec 1c             	sub    $0x1c,%esp
  80c121:	8b 55 08             	mov    0x8(%ebp),%edx
  80c124:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c127:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c12b:	a1 20 e6 b3 00       	mov    0xb3e620,%eax
  80c130:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c135:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c13a:	85 c0                	test   %eax,%eax
  80c13c:	74 2d                	je     80c16b <udp_bind+0x53>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80c13e:	39 c2                	cmp    %eax,%edx
  80c140:	75 22                	jne    80c164 <udp_bind+0x4c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c142:	84 c9                	test   %cl,%cl
  80c144:	74 1c                	je     80c162 <udp_bind+0x4a>
  80c146:	c7 44 24 08 a0 3e 81 	movl   $0x813ea0,0x8(%esp)
  80c14d:	00 
  80c14e:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80c155:	00 
  80c156:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80c15d:	e8 1a 48 ff ff       	call   80097c <_panic>
  80c162:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c164:	8b 40 0c             	mov    0xc(%eax),%eax
  80c167:	85 c0                	test   %eax,%eax
  80c169:	75 d3                	jne    80c13e <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80c16b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c170:	85 ff                	test   %edi,%edi
  80c172:	74 02                	je     80c176 <udp_bind+0x5e>
  80c174:	8b 07                	mov    (%edi),%eax
  80c176:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80c178:	66 85 f6             	test   %si,%si
  80c17b:	75 39                	jne    80c1b6 <udp_bind+0x9e>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80c17d:	8b 3d 20 e6 b3 00    	mov    0xb3e620,%edi
  80c183:	89 f8                	mov    %edi,%eax
  80c185:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c18a:	eb 13                	jmp    80c19f <udp_bind+0x87>
      if (ipcb->local_port == port) {
  80c18c:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80c190:	66 39 f3             	cmp    %si,%bx
  80c193:	75 07                	jne    80c19c <udp_bind+0x84>
        /* port is already used by another udp_pcb */
        port++;
  80c195:	8d 73 01             	lea    0x1(%ebx),%esi
  80c198:	89 f8                	mov    %edi,%eax
  80c19a:	eb 03                	jmp    80c19f <udp_bind+0x87>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80c19c:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c19f:	85 c0                	test   %eax,%eax
  80c1a1:	0f 95 c3             	setne  %bl
  80c1a4:	74 07                	je     80c1ad <udp_bind+0x95>
  80c1a6:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  80c1ab:	75 df                	jne    80c18c <udp_bind+0x74>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80c1ad:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80c1b2:	84 db                	test   %bl,%bl
  80c1b4:	75 20                	jne    80c1d6 <udp_bind+0xbe>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80c1b6:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80c1ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1bf:	84 c9                	test   %cl,%cl
  80c1c1:	75 13                	jne    80c1d6 <udp_bind+0xbe>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80c1c3:	a1 20 e6 b3 00       	mov    0xb3e620,%eax
  80c1c8:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80c1cb:	89 15 20 e6 b3 00    	mov    %edx,0xb3e620
  80c1d1:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80c1d6:	83 c4 1c             	add    $0x1c,%esp
  80c1d9:	5b                   	pop    %ebx
  80c1da:	5e                   	pop    %esi
  80c1db:	5f                   	pop    %edi
  80c1dc:	5d                   	pop    %ebp
  80c1dd:	c3                   	ret    

0080c1de <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c1de:	55                   	push   %ebp
  80c1df:	89 e5                	mov    %esp,%ebp
  80c1e1:	57                   	push   %edi
  80c1e2:	56                   	push   %esi
  80c1e3:	53                   	push   %ebx
  80c1e4:	83 ec 1c             	sub    $0x1c,%esp
  80c1e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c1ea:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c1ed:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80c1f1:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c1f6:	75 18                	jne    80c210 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c1f8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c1ff:	00 
  80c200:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c204:	89 1c 24             	mov    %ebx,(%esp)
  80c207:	e8 0c ff ff ff       	call   80c118 <udp_bind>
    if (err != ERR_OK)
  80c20c:	84 c0                	test   %al,%al
  80c20e:	75 48                	jne    80c258 <udp_connect+0x7a>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80c210:	b8 00 00 00 00       	mov    $0x0,%eax
  80c215:	85 ff                	test   %edi,%edi
  80c217:	74 02                	je     80c21b <udp_connect+0x3d>
  80c219:	8b 07                	mov    (%edi),%eax
  80c21b:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80c21e:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80c222:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c226:	8b 15 20 e6 b3 00    	mov    0xb3e620,%edx
  80c22c:	85 d2                	test   %edx,%edx
  80c22e:	74 13                	je     80c243 <udp_connect+0x65>
    if (pcb == ipcb) {
  80c230:	89 d0                	mov    %edx,%eax
  80c232:	39 d3                	cmp    %edx,%ebx
  80c234:	75 06                	jne    80c23c <udp_connect+0x5e>
  80c236:	eb 1b                	jmp    80c253 <udp_connect+0x75>
  80c238:	39 c3                	cmp    %eax,%ebx
  80c23a:	74 17                	je     80c253 <udp_connect+0x75>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c23c:	8b 40 0c             	mov    0xc(%eax),%eax
  80c23f:	85 c0                	test   %eax,%eax
  80c241:	75 f5                	jne    80c238 <udp_connect+0x5a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80c243:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80c246:	89 1d 20 e6 b3 00    	mov    %ebx,0xb3e620
  80c24c:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
  80c251:	eb 05                	jmp    80c258 <udp_connect+0x7a>
  80c253:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c258:	83 c4 1c             	add    $0x1c,%esp
  80c25b:	5b                   	pop    %ebx
  80c25c:	5e                   	pop    %esi
  80c25d:	5f                   	pop    %edi
  80c25e:	5d                   	pop    %ebp
  80c25f:	c3                   	ret    

0080c260 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80c260:	55                   	push   %ebp
  80c261:	89 e5                	mov    %esp,%ebp
  80c263:	57                   	push   %edi
  80c264:	56                   	push   %esi
  80c265:	53                   	push   %ebx
  80c266:	83 ec 3c             	sub    $0x3c,%esp
  80c269:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c26c:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80c270:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80c274:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c279:	75 1e                	jne    80c299 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c27b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c282:	00 
  80c283:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c287:	89 1c 24             	mov    %ebx,(%esp)
  80c28a:	e8 89 fe ff ff       	call   80c118 <udp_bind>
  80c28f:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80c291:	84 c0                	test   %al,%al
  80c293:	0f 85 6a 01 00 00    	jne    80c403 <udp_sendto_if+0x1a3>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80c299:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c2a0:	00 
  80c2a1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c2a4:	89 14 24             	mov    %edx,(%esp)
  80c2a7:	e8 b7 b8 ff ff       	call   807b63 <pbuf_header>
  80c2ac:	84 c0                	test   %al,%al
  80c2ae:	75 05                	jne    80c2b5 <udp_sendto_if+0x55>
  80c2b0:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c2b3:	eb 3a                	jmp    80c2ef <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80c2b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c2bc:	00 
  80c2bd:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c2c4:	00 
  80c2c5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c2cc:	e8 c2 be ff ff       	call   808193 <pbuf_alloc>
  80c2d1:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80c2d3:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80c2d8:	85 c0                	test   %eax,%eax
  80c2da:	0f 84 23 01 00 00    	je     80c403 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80c2e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c2e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c2e7:	89 34 24             	mov    %esi,(%esp)
  80c2ea:	e8 4d b8 ff ff       	call   807b3c <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80c2ef:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80c2f4:	77 1c                	ja     80c312 <udp_sendto_if+0xb2>
  80c2f6:	c7 44 24 08 d4 3e 81 	movl   $0x813ed4,0x8(%esp)
  80c2fd:	00 
  80c2fe:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80c305:	00 
  80c306:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80c30d:	e8 6a 46 ff ff       	call   80097c <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80c312:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80c315:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80c319:	89 04 24             	mov    %eax,(%esp)
  80c31c:	e8 b3 e9 ff ff       	call   80acd4 <htons>
  80c321:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80c324:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80c328:	89 04 24             	mov    %eax,(%esp)
  80c32b:	e8 a4 e9 ff ff       	call   80acd4 <htons>
  80c330:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80c334:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c33a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80c33d:	85 db                	test   %ebx,%ebx
  80c33f:	74 06                	je     80c347 <udp_sendto_if+0xe7>
  80c341:	8b 03                	mov    (%ebx),%eax
  80c343:	85 c0                	test   %eax,%eax
  80c345:	75 0b                	jne    80c352 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80c347:	8b 55 18             	mov    0x18(%ebp),%edx
  80c34a:	83 c2 04             	add    $0x4,%edx
  80c34d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c350:	eb 23                	jmp    80c375 <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80c352:	8b 55 18             	mov    0x18(%ebp),%edx
  80c355:	3b 42 04             	cmp    0x4(%edx),%eax
  80c358:	74 1b                	je     80c375 <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80c35a:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  80c35f:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c362:	0f 84 9b 00 00 00    	je     80c403 <udp_sendto_if+0x1a3>
        /* free the header pbuf */
        pbuf_free(q);
  80c368:	89 34 24             	mov    %esi,(%esp)
  80c36b:	e8 68 bb ff ff       	call   807ed8 <pbuf_free>
  80c370:	e9 8e 00 00 00       	jmp    80c403 <udp_sendto_if+0x1a3>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80c375:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c379:	89 04 24             	mov    %eax,(%esp)
  80c37c:	e8 53 e9 ff ff       	call   80acd4 <htons>
  80c381:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80c385:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80c389:	75 34                	jne    80c3bf <udp_sendto_if+0x15f>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80c38b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c38f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c393:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c39a:	00 
  80c39b:	8b 45 10             	mov    0x10(%ebp),%eax
  80c39e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c3a2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c3a5:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c3a9:	89 34 24             	mov    %esi,(%esp)
  80c3ac:	e8 1f e6 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80c3b1:	89 c2                	mov    %eax,%edx
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80c3b3:	66 83 f8 01          	cmp    $0x1,%ax
  80c3b7:	19 c0                	sbb    %eax,%eax
  80c3b9:	09 d0                	or     %edx,%eax
  80c3bb:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80c3bf:	8b 45 18             	mov    0x18(%ebp),%eax
  80c3c2:	89 44 24 18          	mov    %eax,0x18(%esp)
  80c3c6:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80c3cd:	00 
  80c3ce:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80c3d2:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c3d6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80c3da:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c3de:	8b 55 10             	mov    0x10(%ebp),%edx
  80c3e1:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c3e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c3e8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c3ec:	89 34 24             	mov    %esi,(%esp)
  80c3ef:	e8 1c d5 ff ff       	call   809910 <ip_output_if>
  80c3f4:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80c3f6:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c3f9:	74 08                	je     80c403 <udp_sendto_if+0x1a3>
    /* free the header pbuf */
    pbuf_free(q);
  80c3fb:	89 34 24             	mov    %esi,(%esp)
  80c3fe:	e8 d5 ba ff ff       	call   807ed8 <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80c403:	89 f8                	mov    %edi,%eax
  80c405:	83 c4 3c             	add    $0x3c,%esp
  80c408:	5b                   	pop    %ebx
  80c409:	5e                   	pop    %esi
  80c40a:	5f                   	pop    %edi
  80c40b:	5d                   	pop    %ebp
  80c40c:	c3                   	ret    

0080c40d <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80c40d:	55                   	push   %ebp
  80c40e:	89 e5                	mov    %esp,%ebp
  80c410:	83 ec 28             	sub    $0x28,%esp
  80c413:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c416:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c419:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80c41c:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80c420:	89 1c 24             	mov    %ebx,(%esp)
  80c423:	e8 99 d6 ff ff       	call   809ac1 <ip_route>
  80c428:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80c42a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80c42f:	85 d2                	test   %edx,%edx
  80c431:	74 21                	je     80c454 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80c433:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c437:	0f b7 f6             	movzwl %si,%esi
  80c43a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80c43e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80c442:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c445:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c449:	8b 45 08             	mov    0x8(%ebp),%eax
  80c44c:	89 04 24             	mov    %eax,(%esp)
  80c44f:	e8 0c fe ff ff       	call   80c260 <udp_sendto_if>
}
  80c454:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c457:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c45a:	89 ec                	mov    %ebp,%esp
  80c45c:	5d                   	pop    %ebp
  80c45d:	c3                   	ret    

0080c45e <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80c45e:	55                   	push   %ebp
  80c45f:	89 e5                	mov    %esp,%ebp
  80c461:	83 ec 18             	sub    $0x18,%esp
  80c464:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80c467:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80c46b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c46f:	8d 50 04             	lea    0x4(%eax),%edx
  80c472:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c476:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c479:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c47d:	89 04 24             	mov    %eax,(%esp)
  80c480:	e8 88 ff ff ff       	call   80c40d <udp_sendto>
}
  80c485:	c9                   	leave  
  80c486:	c3                   	ret    

0080c487 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80c487:	55                   	push   %ebp
  80c488:	89 e5                	mov    %esp,%ebp
  80c48a:	57                   	push   %edi
  80c48b:	56                   	push   %esi
  80c48c:	53                   	push   %ebx
  80c48d:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80c490:	8b 45 08             	mov    0x8(%ebp),%eax
  80c493:	8b 40 04             	mov    0x4(%eax),%eax
  80c496:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80c499:	8b 55 08             	mov    0x8(%ebp),%edx
  80c49c:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80c4a0:	0f b7 00             	movzwl (%eax),%eax
  80c4a3:	89 04 24             	mov    %eax,(%esp)
  80c4a6:	e8 36 e8 ff ff       	call   80ace1 <ntohs>
  80c4ab:	0f b6 c4             	movzbl %ah,%eax
  80c4ae:	83 e0 0f             	and    $0xf,%eax
  80c4b1:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c4b8:	39 c3                	cmp    %eax,%ebx
  80c4ba:	7c 2b                	jl     80c4e7 <udp_input+0x60>
  80c4bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c4bf:	0f b7 02             	movzwl (%edx),%eax
  80c4c2:	89 04 24             	mov    %eax,(%esp)
  80c4c5:	e8 17 e8 ff ff       	call   80ace1 <ntohs>
  80c4ca:	66 c1 e8 06          	shr    $0x6,%ax
  80c4ce:	83 e0 3c             	and    $0x3c,%eax
  80c4d1:	f7 d8                	neg    %eax
  80c4d3:	98                   	cwtl   
  80c4d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c4d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80c4db:	89 04 24             	mov    %eax,(%esp)
  80c4de:	e8 80 b6 ff ff       	call   807b63 <pbuf_header>
  80c4e3:	84 c0                	test   %al,%al
  80c4e5:	74 10                	je     80c4f7 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80c4e7:	8b 55 08             	mov    0x8(%ebp),%edx
  80c4ea:	89 14 24             	mov    %edx,(%esp)
  80c4ed:	e8 e6 b9 ff ff       	call   807ed8 <pbuf_free>
    goto end;
  80c4f2:	e9 f4 02 00 00       	jmp    80c7eb <udp_input+0x364>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80c4f7:	8b 45 08             	mov    0x8(%ebp),%eax
  80c4fa:	8b 40 04             	mov    0x4(%eax),%eax
  80c4fd:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80c500:	0f b7 00             	movzwl (%eax),%eax
  80c503:	89 04 24             	mov    %eax,(%esp)
  80c506:	e8 d6 e7 ff ff       	call   80ace1 <ntohs>
  80c50b:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  80c50f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80c512:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80c516:	89 04 24             	mov    %eax,(%esp)
  80c519:	e8 c3 e7 ff ff       	call   80ace1 <ntohs>
  80c51e:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80c520:	66 83 f8 44          	cmp    $0x44,%ax
  80c524:	75 49                	jne    80c56f <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80c526:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  80c52b:	0f 85 fa 00 00 00    	jne    80c62b <udp_input+0x1a4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80c531:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c534:	8b 42 20             	mov    0x20(%edx),%eax
  80c537:	85 c0                	test   %eax,%eax
  80c539:	0f 84 ec 00 00 00    	je     80c62b <udp_input+0x1a4>
  80c53f:	8b 58 08             	mov    0x8(%eax),%ebx
  80c542:	85 db                	test   %ebx,%ebx
  80c544:	0f 84 e6 00 00 00    	je     80c630 <udp_input+0x1a9>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80c54a:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c54d:	0f 84 ef 00 00 00    	je     80c642 <udp_input+0x1bb>
  80c553:	8b 43 04             	mov    0x4(%ebx),%eax
  80c556:	85 c0                	test   %eax,%eax
  80c558:	0f 84 e4 00 00 00    	je     80c642 <udp_input+0x1bb>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  80c55e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c561:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c564:	0f 85 c1 00 00 00    	jne    80c62b <udp_input+0x1a4>
  80c56a:	e9 d3 00 00 00       	jmp    80c642 <udp_input+0x1bb>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c56f:	8b 1d 20 e6 b3 00    	mov    0xb3e620,%ebx
  80c575:	85 db                	test   %ebx,%ebx
  80c577:	0f 84 62 02 00 00    	je     80c7df <udp_input+0x358>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c57d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c580:	83 c0 10             	add    $0x10,%eax
  80c583:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c586:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c58d:	bf 00 00 00 00       	mov    $0x0,%edi
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c592:	66 3b 73 12          	cmp    0x12(%ebx),%si
  80c596:	75 76                	jne    80c60e <udp_input+0x187>
          (ip_addr_isany(&pcb->local_ip) ||
  80c598:	85 db                	test   %ebx,%ebx
  80c59a:	74 24                	je     80c5c0 <udp_input+0x139>
  80c59c:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c59e:	85 c0                	test   %eax,%eax
  80c5a0:	74 1e                	je     80c5c0 <udp_input+0x139>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80c5a2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c5a5:	3b 42 10             	cmp    0x10(%edx),%eax
  80c5a8:	74 16                	je     80c5c0 <udp_input+0x139>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c5aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c5ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c5b1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c5b4:	89 14 24             	mov    %edx,(%esp)
  80c5b7:	e8 0c d3 ff ff       	call   8098c8 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c5bc:	84 c0                	test   %al,%al
  80c5be:	74 4e                	je     80c60e <udp_input+0x187>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c5c0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80c5c4:	0f 85 02 02 00 00    	jne    80c7cc <udp_input+0x345>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  80c5ca:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c5ce:	66 90                	xchg   %ax,%ax
  80c5d0:	0f 84 f3 01 00 00    	je     80c7c9 <udp_input+0x342>
  80c5d6:	66 90                	xchg   %ax,%ax
  80c5d8:	e9 ef 01 00 00       	jmp    80c7cc <udp_input+0x345>
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  80c5dd:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c5e0:	74 0f                	je     80c5f1 <udp_input+0x16a>
  80c5e2:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c5e5:	85 c0                	test   %eax,%eax
  80c5e7:	74 08                	je     80c5f1 <udp_input+0x16a>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  80c5e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c5ec:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c5ef:	75 1d                	jne    80c60e <udp_input+0x187>
  80c5f1:	89 d8                	mov    %ebx,%eax
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c5f3:	85 ff                	test   %edi,%edi
  80c5f5:	74 27                	je     80c61e <udp_input+0x197>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c5f7:	8b 53 0c             	mov    0xc(%ebx),%edx
  80c5fa:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80c5fd:	8b 15 20 e6 b3 00    	mov    0xb3e620,%edx
  80c603:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  80c606:	89 1d 20 e6 b3 00    	mov    %ebx,0xb3e620
  80c60c:	eb 10                	jmp    80c61e <udp_input+0x197>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c60e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c611:	85 c0                	test   %eax,%eax
  80c613:	74 0d                	je     80c622 <udp_input+0x19b>
  80c615:	89 df                	mov    %ebx,%edi
  80c617:	89 c3                	mov    %eax,%ebx
  80c619:	e9 74 ff ff ff       	jmp    80c592 <udp_input+0x10b>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80c61e:	85 c0                	test   %eax,%eax
  80c620:	75 20                	jne    80c642 <udp_input+0x1bb>
  80c622:	8b 5d dc             	mov    -0x24(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c625:	85 db                	test   %ebx,%ebx
  80c627:	75 19                	jne    80c642 <udp_input+0x1bb>
  80c629:	eb 05                	jmp    80c630 <udp_input+0x1a9>
  80c62b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c630:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c633:	8b 42 04             	mov    0x4(%edx),%eax
  80c636:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c639:	3b 42 10             	cmp    0x10(%edx),%eax
  80c63c:	0f 85 7a 01 00 00    	jne    80c7bc <udp_input+0x335>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c642:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c645:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c64a:	74 44                	je     80c690 <udp_input+0x209>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c64c:	8b 55 08             	mov    0x8(%ebp),%edx
  80c64f:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c653:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c657:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c65e:	00 
  80c65f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c662:	83 c0 10             	add    $0x10,%eax
  80c665:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c669:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c66c:	83 c0 0c             	add    $0xc,%eax
  80c66f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c673:	89 14 24             	mov    %edx,(%esp)
  80c676:	e8 55 e3 ff ff       	call   80a9d0 <inet_chksum_pseudo>
  80c67b:	66 85 c0             	test   %ax,%ax
  80c67e:	74 10                	je     80c690 <udp_input+0x209>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c680:	8b 45 08             	mov    0x8(%ebp),%eax
  80c683:	89 04 24             	mov    %eax,(%esp)
  80c686:	e8 4d b8 ff ff       	call   807ed8 <pbuf_free>
          goto end;
  80c68b:	e9 5b 01 00 00       	jmp    80c7eb <udp_input+0x364>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c690:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c697:	ff 
  80c698:	8b 55 08             	mov    0x8(%ebp),%edx
  80c69b:	89 14 24             	mov    %edx,(%esp)
  80c69e:	e8 c0 b4 ff ff       	call   807b63 <pbuf_header>
  80c6a3:	84 c0                	test   %al,%al
  80c6a5:	74 1c                	je     80c6c3 <udp_input+0x23c>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c6a7:	c7 44 24 08 8c 3e 81 	movl   $0x813e8c,0x8(%esp)
  80c6ae:	00 
  80c6af:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c6b6:	00 
  80c6b7:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80c6be:	e8 b9 42 ff ff       	call   80097c <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c6c3:	85 db                	test   %ebx,%ebx
  80c6c5:	74 41                	je     80c708 <udp_input+0x281>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c6c7:	8b 43 18             	mov    0x18(%ebx),%eax
  80c6ca:	85 c0                	test   %eax,%eax
  80c6cc:	74 2a                	je     80c6f8 <udp_input+0x271>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c6ce:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80c6d2:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c6d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c6d9:	83 c2 0c             	add    $0xc,%edx
  80c6dc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c6e0:	8b 55 08             	mov    0x8(%ebp),%edx
  80c6e3:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c6e7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c6eb:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80c6ee:	89 14 24             	mov    %edx,(%esp)
  80c6f1:	ff d0                	call   *%eax
  80c6f3:	e9 f3 00 00 00       	jmp    80c7eb <udp_input+0x364>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c6f8:	8b 45 08             	mov    0x8(%ebp),%eax
  80c6fb:	89 04 24             	mov    %eax,(%esp)
  80c6fe:	e8 d5 b7 ff ff       	call   807ed8 <pbuf_free>
        goto end;
  80c703:	e9 e3 00 00 00       	jmp    80c7eb <udp_input+0x364>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c708:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c70b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c70f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c712:	83 c0 10             	add    $0x10,%eax
  80c715:	89 04 24             	mov    %eax,(%esp)
  80c718:	e8 ab d1 ff ff       	call   8098c8 <ip_addr_isbroadcast>
  80c71d:	84 c0                	test   %al,%al
  80c71f:	0f 85 8a 00 00 00    	jne    80c7af <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80c725:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c728:	8b 70 10             	mov    0x10(%eax),%esi
  80c72b:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c732:	e8 e3 e7 ff ff       	call   80af1a <ntohl>
  80c737:	89 c3                	mov    %eax,%ebx
  80c739:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c740:	e8 d5 e7 ff ff       	call   80af1a <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c745:	21 f3                	and    %esi,%ebx
  80c747:	39 c3                	cmp    %eax,%ebx
  80c749:	74 64                	je     80c7af <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c74b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c74e:	0f b7 02             	movzwl (%edx),%eax
  80c751:	89 04 24             	mov    %eax,(%esp)
  80c754:	e8 88 e5 ff ff       	call   80ace1 <ntohs>
  80c759:	0f b6 c4             	movzbl %ah,%eax
  80c75c:	83 e0 0f             	and    $0xf,%eax
  80c75f:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c766:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c76a:	8b 45 08             	mov    0x8(%ebp),%eax
  80c76d:	89 04 24             	mov    %eax,(%esp)
  80c770:	e8 ee b3 ff ff       	call   807b63 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c775:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c778:	8b 55 08             	mov    0x8(%ebp),%edx
  80c77b:	39 42 04             	cmp    %eax,0x4(%edx)
  80c77e:	74 1c                	je     80c79c <udp_input+0x315>
  80c780:	c7 44 24 08 c0 3e 81 	movl   $0x813ec0,0x8(%esp)
  80c787:	00 
  80c788:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c78f:	00 
  80c790:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80c797:	e8 e0 41 ff ff       	call   80097c <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c79c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c7a3:	00 
  80c7a4:	8b 55 08             	mov    0x8(%ebp),%edx
  80c7a7:	89 14 24             	mov    %edx,(%esp)
  80c7aa:	e8 b3 55 00 00       	call   811d62 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c7af:	8b 45 08             	mov    0x8(%ebp),%eax
  80c7b2:	89 04 24             	mov    %eax,(%esp)
  80c7b5:	e8 1e b7 ff ff       	call   807ed8 <pbuf_free>
  80c7ba:	eb 2f                	jmp    80c7eb <udp_input+0x364>
    }
  } else {
    pbuf_free(p);
  80c7bc:	8b 55 08             	mov    0x8(%ebp),%edx
  80c7bf:	89 14 24             	mov    %edx,(%esp)
  80c7c2:	e8 11 b7 ff ff       	call   807ed8 <pbuf_free>
  80c7c7:	eb 22                	jmp    80c7eb <udp_input+0x364>
  }
end:
  PERF_STOP("udp_input");
}
  80c7c9:	89 5d dc             	mov    %ebx,-0x24(%ebp)
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80c7cc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80c7d0:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c7d4:	0f 85 34 fe ff ff    	jne    80c60e <udp_input+0x187>
  80c7da:	e9 fe fd ff ff       	jmp    80c5dd <udp_input+0x156>
  80c7df:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c7e6:	e9 37 fe ff ff       	jmp    80c622 <udp_input+0x19b>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c7eb:	83 c4 4c             	add    $0x4c,%esp
  80c7ee:	5b                   	pop    %ebx
  80c7ef:	5e                   	pop    %esi
  80c7f0:	5f                   	pop    %edi
  80c7f1:	5d                   	pop    %ebp
  80c7f2:	c3                   	ret    
	...

0080c800 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c800:	55                   	push   %ebp
  80c801:	89 e5                	mov    %esp,%ebp
  80c803:	57                   	push   %edi
  80c804:	56                   	push   %esi
  80c805:	53                   	push   %ebx
  80c806:	83 ec 2c             	sub    $0x2c,%esp
  80c809:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c80c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80c80f:	89 ce                	mov    %ecx,%esi
  80c811:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80c814:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c817:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c81b:	74 1c                	je     80c839 <etharp_send_ip+0x39>
  80c81d:	c7 44 24 08 04 3f 81 	movl   $0x813f04,0x8(%esp)
  80c824:	00 
  80c825:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c82c:	00 
  80c82d:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80c834:	e8 43 41 ff ff       	call   80097c <_panic>
  80c839:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c83e:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c841:	0f b6 c2             	movzbl %dl,%eax
  80c844:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c848:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c84b:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c84f:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c853:	84 d2                	test   %dl,%dl
  80c855:	75 e7                	jne    80c83e <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c857:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c85e:	e8 71 e4 ff ff       	call   80acd4 <htons>
  80c863:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c867:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c86a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c86e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c871:	89 14 24             	mov    %edx,(%esp)
  80c874:	ff 52 18             	call   *0x18(%edx)
}
  80c877:	83 c4 2c             	add    $0x2c,%esp
  80c87a:	5b                   	pop    %ebx
  80c87b:	5e                   	pop    %esi
  80c87c:	5f                   	pop    %edi
  80c87d:	5d                   	pop    %ebp
  80c87e:	c3                   	ret    

0080c87f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c87f:	55                   	push   %ebp
  80c880:	89 e5                	mov    %esp,%ebp
  80c882:	57                   	push   %edi
  80c883:	56                   	push   %esi
  80c884:	53                   	push   %ebx
  80c885:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c888:	8b 75 08             	mov    0x8(%ebp),%esi
  80c88b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c88e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c895:	00 
  80c896:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c89d:	00 
  80c89e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c8a5:	e8 e9 b8 ff ff       	call   808193 <pbuf_alloc>
  80c8aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c8ad:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80c8b2:	85 c0                	test   %eax,%eax
  80c8b4:	0f 84 02 01 00 00    	je     80c9bc <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c8ba:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c8bf:	77 1c                	ja     80c8dd <etharp_request+0x5e>
  80c8c1:	c7 44 24 08 48 3f 81 	movl   $0x813f48,0x8(%esp)
  80c8c8:	00 
  80c8c9:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c8d0:	00 
  80c8d1:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80c8d8:	e8 9f 40 ff ff       	call   80097c <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c8dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c8e0:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c8e3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c8ea:	e8 e5 e3 ff ff       	call   80acd4 <htons>
  80c8ef:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c8f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c8f6:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  80c8fa:	74 1c                	je     80c918 <etharp_request+0x99>
  80c8fc:	c7 44 24 08 04 3f 81 	movl   $0x813f04,0x8(%esp)
  80c903:	00 
  80c904:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c90b:	00 
  80c90c:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80c913:	e8 64 40 ff ff       	call   80097c <_panic>
  80c918:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c91d:	bf 69 40 81 00       	mov    $0x814069,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c922:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c925:	0f b6 c2             	movzbl %dl,%eax
  80c928:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c92c:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c930:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c934:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c938:	0f b6 88 63 40 81 00 	movzbl 0x814063(%eax),%ecx
  80c93f:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c942:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c946:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c94a:	84 d2                	test   %dl,%dl
  80c94c:	75 d4                	jne    80c922 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c94e:	8b 55 08             	mov    0x8(%ebp),%edx
  80c951:	8b 42 04             	mov    0x4(%edx),%eax
  80c954:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c957:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c95a:	8b 00                	mov    (%eax),%eax
  80c95c:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c95f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c966:	e8 69 e3 ff ff       	call   80acd4 <htons>
  80c96b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c96f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c976:	e8 59 e3 ff ff       	call   80acd4 <htons>
  80c97b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c97f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c986:	e8 49 e3 ff ff       	call   80acd4 <htons>
  80c98b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c98f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80c996:	e8 39 e3 ff ff       	call   80acd4 <htons>
  80c99b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80c99f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c9a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c9a6:	8b 45 08             	mov    0x8(%ebp),%eax
  80c9a9:	89 04 24             	mov    %eax,(%esp)
  80c9ac:	ff 50 18             	call   *0x18(%eax)
  80c9af:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80c9b1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c9b4:	89 0c 24             	mov    %ecx,(%esp)
  80c9b7:	e8 1c b5 ff ff       	call   807ed8 <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80c9bc:	89 d8                	mov    %ebx,%eax
  80c9be:	83 c4 3c             	add    $0x3c,%esp
  80c9c1:	5b                   	pop    %ebx
  80c9c2:	5e                   	pop    %esi
  80c9c3:	5f                   	pop    %edi
  80c9c4:	5d                   	pop    %ebp
  80c9c5:	c3                   	ret    

0080c9c6 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80c9c6:	55                   	push   %ebp
  80c9c7:	89 e5                	mov    %esp,%ebp
  80c9c9:	56                   	push   %esi
  80c9ca:	53                   	push   %ebx
  80c9cb:	83 ec 10             	sub    $0x10,%esp
  80c9ce:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80c9d0:	85 c0                	test   %eax,%eax
  80c9d2:	75 1c                	jne    80c9f0 <free_etharp_q+0x2a>
  80c9d4:	c7 44 24 08 b7 37 81 	movl   $0x8137b7,0x8(%esp)
  80c9db:	00 
  80c9dc:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80c9e3:	00 
  80c9e4:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80c9eb:	e8 8c 3f ff ff       	call   80097c <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c9f0:	8b 40 04             	mov    0x4(%eax),%eax
  80c9f3:	85 c0                	test   %eax,%eax
  80c9f5:	74 04                	je     80c9fb <free_etharp_q+0x35>
  while (q) {
    r = q;
    q = q->next;
  80c9f7:	8b 1e                	mov    (%esi),%ebx
  80c9f9:	eb 45                	jmp    80ca40 <free_etharp_q+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c9fb:	c7 44 24 08 05 40 81 	movl   $0x814005,0x8(%esp)
  80ca02:	00 
  80ca03:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80ca0a:	00 
  80ca0b:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80ca12:	e8 65 3f ff ff       	call   80097c <_panic>
  while (q) {
    r = q;
    q = q->next;
  80ca17:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80ca19:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca1c:	85 c0                	test   %eax,%eax
  80ca1e:	75 1c                	jne    80ca3c <free_etharp_q+0x76>
  80ca20:	c7 44 24 08 12 40 81 	movl   $0x814012,0x8(%esp)
  80ca27:	00 
  80ca28:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80ca2f:	00 
  80ca30:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80ca37:	e8 40 3f ff ff       	call   80097c <_panic>
  80ca3c:	89 de                	mov    %ebx,%esi
  80ca3e:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80ca40:	89 04 24             	mov    %eax,(%esp)
  80ca43:	e8 90 b4 ff ff       	call   807ed8 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80ca48:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ca4c:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80ca53:	e8 e8 ac ff ff       	call   807740 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80ca58:	85 db                	test   %ebx,%ebx
  80ca5a:	75 bb                	jne    80ca17 <free_etharp_q+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80ca5c:	83 c4 10             	add    $0x10,%esp
  80ca5f:	5b                   	pop    %ebx
  80ca60:	5e                   	pop    %esi
  80ca61:	5d                   	pop    %ebp
  80ca62:	c3                   	ret    

0080ca63 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80ca63:	55                   	push   %ebp
  80ca64:	89 e5                	mov    %esp,%ebp
  80ca66:	57                   	push   %edi
  80ca67:	56                   	push   %esi
  80ca68:	53                   	push   %ebx
  80ca69:	83 ec 3c             	sub    $0x3c,%esp
  80ca6c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ca6f:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80ca72:	85 c0                	test   %eax,%eax
  80ca74:	74 16                	je     80ca8c <find_entry+0x29>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80ca76:	0f b6 05 f8 7e b3 00 	movzbl 0xb37ef8,%eax
  80ca7d:	0f b6 d0             	movzbl %al,%edx
  80ca80:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80ca83:	83 b9 f0 7d b3 00 02 	cmpl   $0x2,0xb37df0(%ecx)
  80ca8a:	74 2a                	je     80cab6 <find_entry+0x53>
  80ca8c:	ba f4 7d b3 00       	mov    $0xb37df4,%edx
  80ca91:	be 00 00 00 00       	mov    $0x0,%esi
  80ca96:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80ca9a:	bf 00 00 00 00       	mov    $0x0,%edi
  80ca9f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80caa3:	b8 00 00 00 00       	mov    $0x0,%eax
  80caa8:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80caac:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80cab0:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  80cab4:	eb 22                	jmp    80cad8 <find_entry+0x75>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80cab6:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80cab9:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cabc:	8b 0b                	mov    (%ebx),%ecx
  80cabe:	3b 8a e4 7d b3 00    	cmp    0xb37de4(%edx),%ecx
  80cac4:	75 c6                	jne    80ca8c <find_entry+0x29>
  80cac6:	e9 c4 01 00 00       	jmp    80cc8f <find_entry+0x22c>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80cacb:	89 ce                	mov    %ecx,%esi
  80cacd:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  80cad1:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  80cad5:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80cad8:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80cadc:	75 1c                	jne    80cafa <find_entry+0x97>
  80cade:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80cae2:	75 16                	jne    80cafa <find_entry+0x97>
  80cae4:	88 45 e5             	mov    %al,-0x1b(%ebp)
  80cae7:	89 f1                	mov    %esi,%ecx
  80cae9:	89 fb                	mov    %edi,%ebx
  80caeb:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80caee:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80caf2:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80caf5:	e9 a0 00 00 00       	jmp    80cb9a <find_entry+0x137>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80cafa:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80cafd:	83 f9 01             	cmp    $0x1,%ecx
  80cb00:	75 51                	jne    80cb53 <find_entry+0xf0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80cb02:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cb06:	74 14                	je     80cb1c <find_entry+0xb9>
  80cb08:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cb0b:	8b 0b                	mov    (%ebx),%ecx
  80cb0d:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cb10:	75 0a                	jne    80cb1c <find_entry+0xb9>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cb12:	a2 f8 7e b3 00       	mov    %al,0xb37ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cb17:	e9 73 01 00 00       	jmp    80cc8f <find_entry+0x22c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80cb1c:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  80cb20:	74 1a                	je     80cb3c <find_entry+0xd9>
        if (arp_table[i].ctime >= age_queue) {
  80cb22:	0f b6 0a             	movzbl (%edx),%ecx
  80cb25:	89 f3                	mov    %esi,%ebx
  80cb27:	38 cb                	cmp    %cl,%bl
  80cb29:	77 61                	ja     80cb8c <find_entry+0x129>
  80cb2b:	88 45 df             	mov    %al,-0x21(%ebp)
  80cb2e:	89 fb                	mov    %edi,%ebx
  80cb30:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cb33:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb37:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cb3a:	eb 5e                	jmp    80cb9a <find_entry+0x137>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80cb3c:	0f b6 0a             	movzbl (%edx),%ecx
  80cb3f:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80cb42:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80cb45:	77 45                	ja     80cb8c <find_entry+0x129>
  80cb47:	88 45 dc             	mov    %al,-0x24(%ebp)
  80cb4a:	89 f1                	mov    %esi,%ecx
  80cb4c:	89 fb                	mov    %edi,%ebx
  80cb4e:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cb51:	eb 47                	jmp    80cb9a <find_entry+0x137>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80cb53:	83 f9 02             	cmp    $0x2,%ecx
  80cb56:	75 34                	jne    80cb8c <find_entry+0x129>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80cb58:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cb5c:	74 14                	je     80cb72 <find_entry+0x10f>
  80cb5e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cb61:	8b 0b                	mov    (%ebx),%ecx
  80cb63:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cb66:	75 0a                	jne    80cb72 <find_entry+0x10f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cb68:	a2 f8 7e b3 00       	mov    %al,0xb37ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cb6d:	e9 1d 01 00 00       	jmp    80cc8f <find_entry+0x22c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80cb72:	0f b6 0a             	movzbl (%edx),%ecx
  80cb75:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80cb78:	89 fb                	mov    %edi,%ebx
  80cb7a:	38 cb                	cmp    %cl,%bl
  80cb7c:	77 0e                	ja     80cb8c <find_entry+0x129>
  80cb7e:	88 45 de             	mov    %al,-0x22(%ebp)
  80cb81:	89 f1                	mov    %esi,%ecx
  80cb83:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb87:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cb8a:	eb 0e                	jmp    80cb9a <find_entry+0x137>
  80cb8c:	89 f1                	mov    %esi,%ecx
  80cb8e:	89 fb                	mov    %edi,%ebx
  80cb90:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cb93:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb97:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cb9a:	83 c0 01             	add    $0x1,%eax
  80cb9d:	83 c2 1c             	add    $0x1c,%edx
  80cba0:	3c 0a                	cmp    $0xa,%al
  80cba2:	0f 85 23 ff ff ff    	jne    80cacb <find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80cba8:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80cbac:	75 0a                	jne    80cbb8 <find_entry+0x155>
  80cbae:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  80cbb2:	0f 84 d2 00 00 00    	je     80cc8a <find_entry+0x227>
  80cbb8:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  80cbbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cbc0:	0f 85 c4 00 00 00    	jne    80cc8a <find_entry+0x227>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80cbc6:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80cbca:	80 fb 09             	cmp    $0x9,%bl
  80cbcd:	8d 76 00             	lea    0x0(%esi),%esi
  80cbd0:	7e 62                	jle    80cc34 <find_entry+0x1d1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80cbd2:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  80cbd6:	7f 2f                	jg     80cc07 <find_entry+0x1a4>
    /* recycle oldest stable*/
    i = old_stable;
  80cbd8:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80cbdc:	0f b6 c3             	movzbl %bl,%eax
  80cbdf:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cbe2:	83 b8 e0 7d b3 00 00 	cmpl   $0x0,0xb37de0(%eax)
  80cbe9:	74 49                	je     80cc34 <find_entry+0x1d1>
  80cbeb:	c7 44 24 08 1f 40 81 	movl   $0x81401f,0x8(%esp)
  80cbf2:	00 
  80cbf3:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80cbfa:	00 
  80cbfb:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80cc02:	e8 75 3d ff ff       	call   80097c <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80cc07:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80cc0b:	80 fb 09             	cmp    $0x9,%bl
  80cc0e:	7e 24                	jle    80cc34 <find_entry+0x1d1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80cc10:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  80cc14:	7f 74                	jg     80cc8a <find_entry+0x227>
    /* recycle oldest pending */
    i = old_queue;
  80cc16:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80cc1a:	0f b6 f3             	movzbl %bl,%esi
  80cc1d:	bf e0 7d b3 00       	mov    $0xb37de0,%edi
  80cc22:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80cc25:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  80cc28:	e8 99 fd ff ff       	call   80c9c6 <free_etharp_q>
    arp_table[i].q = NULL;
  80cc2d:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80cc34:	80 fb 09             	cmp    $0x9,%bl
  80cc37:	76 1c                	jbe    80cc55 <find_entry+0x1f2>
  80cc39:	c7 44 24 08 36 40 81 	movl   $0x814036,0x8(%esp)
  80cc40:	00 
  80cc41:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80cc48:	00 
  80cc49:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80cc50:	e8 27 3d ff ff       	call   80097c <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80cc55:	0f b6 c3             	movzbl %bl,%eax
  80cc58:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80cc5b:	c7 82 f0 7d b3 00 00 	movl   $0x0,0xb37df0(%edx)
  80cc62:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80cc65:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cc69:	74 0b                	je     80cc76 <find_entry+0x213>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80cc6b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80cc6e:	8b 0e                	mov    (%esi),%ecx
  80cc70:	89 8a e4 7d b3 00    	mov    %ecx,0xb37de4(%edx)
  }
  arp_table[i].ctime = 0;
  80cc76:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cc79:	c6 80 f4 7d b3 00 00 	movb   $0x0,0xb37df4(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80cc80:	88 1d f8 7e b3 00    	mov    %bl,0xb37ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80cc86:	89 d8                	mov    %ebx,%eax
  80cc88:	eb 05                	jmp    80cc8f <find_entry+0x22c>
  80cc8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80cc8f:	83 c4 3c             	add    $0x3c,%esp
  80cc92:	5b                   	pop    %ebx
  80cc93:	5e                   	pop    %esi
  80cc94:	5f                   	pop    %edi
  80cc95:	5d                   	pop    %ebp
  80cc96:	c3                   	ret    

0080cc97 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80cc97:	55                   	push   %ebp
  80cc98:	89 e5                	mov    %esp,%ebp
  80cc9a:	83 ec 38             	sub    $0x38,%esp
  80cc9d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cca0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cca3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cca6:	8b 75 08             	mov    0x8(%ebp),%esi
  80cca9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80ccac:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ccb0:	89 1c 24             	mov    %ebx,(%esp)
  80ccb3:	e8 10 cc ff ff       	call   8098c8 <ip_addr_isbroadcast>
  80ccb8:	84 c0                	test   %al,%al
  80ccba:	0f 85 c7 01 00 00    	jne    80ce87 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
  80ccc0:	8b 03                	mov    (%ebx),%eax
  80ccc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ccc5:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cccc:	e8 49 e2 ff ff       	call   80af1a <ntohl>
  80ccd1:	89 c7                	mov    %eax,%edi
  80ccd3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80ccda:	e8 3b e2 ff ff       	call   80af1a <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80ccdf:	23 7d e4             	and    -0x1c(%ebp),%edi
  80cce2:	39 c7                	cmp    %eax,%edi
  80cce4:	0f 84 9d 01 00 00    	je     80ce87 <etharp_query+0x1f0>
  80ccea:	85 db                	test   %ebx,%ebx
  80ccec:	0f 84 95 01 00 00    	je     80ce87 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
  80ccf2:	83 3b 00             	cmpl   $0x0,(%ebx)
  80ccf5:	0f 84 8c 01 00 00    	je     80ce87 <etharp_query+0x1f0>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80ccfb:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd00:	89 d8                	mov    %ebx,%eax
  80cd02:	e8 5c fd ff ff       	call   80ca63 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80cd07:	84 c0                	test   %al,%al
  80cd09:	0f 88 83 01 00 00    	js     80ce92 <etharp_query+0x1fb>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80cd0f:	0f be f8             	movsbl %al,%edi
  80cd12:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd15:	8b 80 f0 7d b3 00    	mov    0xb37df0(%eax),%eax
  80cd1b:	85 c0                	test   %eax,%eax
  80cd1d:	75 0f                	jne    80cd2e <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80cd1f:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd22:	c7 80 f0 7d b3 00 01 	movl   $0x1,0xb37df0(%eax)
  80cd29:	00 00 00 
  80cd2c:	eb 33                	jmp    80cd61 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80cd2e:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cd31:	83 fa 01             	cmp    $0x1,%edx
  80cd34:	76 1c                	jbe    80cd52 <etharp_query+0xbb>
  80cd36:	c7 44 24 08 7c 3f 81 	movl   $0x813f7c,0x8(%esp)
  80cd3d:	00 
  80cd3e:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80cd45:	00 
  80cd46:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80cd4d:	e8 2a 3c ff ff       	call   80097c <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80cd52:	83 f8 01             	cmp    $0x1,%eax
  80cd55:	74 0a                	je     80cd61 <etharp_query+0xca>
  80cd57:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  80cd5b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80cd5f:	75 0f                	jne    80cd70 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80cd61:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cd65:	89 34 24             	mov    %esi,(%esp)
  80cd68:	e8 12 fb ff ff       	call   80c87f <etharp_request>
  80cd6d:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80cd70:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80cd74:	0f 84 14 01 00 00    	je     80ce8e <etharp_query+0x1f7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80cd7a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd7d:	8b 80 f0 7d b3 00    	mov    0xb37df0(%eax),%eax
  80cd83:	83 f8 02             	cmp    $0x2,%eax
  80cd86:	75 1d                	jne    80cda5 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80cd88:	8d 4e 25             	lea    0x25(%esi),%ecx
  80cd8b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd8e:	05 e8 7d b3 00       	add    $0xb37de8,%eax
  80cd93:	89 04 24             	mov    %eax,(%esp)
  80cd96:	8b 55 10             	mov    0x10(%ebp),%edx
  80cd99:	89 f0                	mov    %esi,%eax
  80cd9b:	e8 60 fa ff ff       	call   80c800 <etharp_send_ip>
  80cda0:	e9 ed 00 00 00       	jmp    80ce92 <etharp_query+0x1fb>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80cda5:	83 f8 01             	cmp    $0x1,%eax
  80cda8:	0f 85 e0 00 00 00    	jne    80ce8e <etharp_query+0x1f7>
  80cdae:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80cdb1:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80cdb5:	66 3b 50 08          	cmp    0x8(%eax),%dx
  80cdb9:	75 21                	jne    80cddc <etharp_query+0x145>
  80cdbb:	83 38 00             	cmpl   $0x0,(%eax)
  80cdbe:	74 1c                	je     80cddc <etharp_query+0x145>
  80cdc0:	c7 44 24 08 49 40 81 	movl   $0x814049,0x8(%esp)
  80cdc7:	00 
  80cdc8:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80cdcf:	00 
  80cdd0:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80cdd7:	e8 a0 3b ff ff       	call   80097c <_panic>
        if(p->type != PBUF_ROM) {
  80cddc:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80cde0:	75 0b                	jne    80cded <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80cde2:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80cde4:	85 c0                	test   %eax,%eax
  80cde6:	75 c9                	jne    80cdb1 <etharp_query+0x11a>
  80cde8:	e9 b2 00 00 00       	jmp    80ce9f <etharp_query+0x208>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80cded:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80cdf1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80cdf8:	00 
  80cdf9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cdfd:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80ce04:	e8 8a b3 ff ff       	call   808193 <pbuf_alloc>
  80ce09:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80ce0b:	85 c0                	test   %eax,%eax
  80ce0d:	74 7f                	je     80ce8e <etharp_query+0x1f7>
          if (pbuf_copy(p, q) != ERR_OK) {
  80ce0f:	8b 45 10             	mov    0x10(%ebp),%eax
  80ce12:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ce16:	89 1c 24             	mov    %ebx,(%esp)
  80ce19:	e8 07 af ff ff       	call   807d25 <pbuf_copy>
  80ce1e:	84 c0                	test   %al,%al
  80ce20:	74 10                	je     80ce32 <etharp_query+0x19b>
            pbuf_free(p);
  80ce22:	89 1c 24             	mov    %ebx,(%esp)
  80ce25:	e8 ae b0 ff ff       	call   807ed8 <pbuf_free>
  80ce2a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80ce2e:	66 90                	xchg   %ax,%ax
  80ce30:	eb 60                	jmp    80ce92 <etharp_query+0x1fb>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80ce32:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80ce39:	e8 46 a9 ff ff       	call   807784 <memp_malloc>
        if (new_entry != NULL) {
  80ce3e:	85 c0                	test   %eax,%eax
  80ce40:	74 37                	je     80ce79 <etharp_query+0x1e2>
          new_entry->next = 0;
  80ce42:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80ce48:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80ce4b:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80ce4e:	8b 92 e0 7d b3 00    	mov    0xb37de0(%edx),%edx
  80ce54:	85 d2                	test   %edx,%edx
  80ce56:	74 11                	je     80ce69 <etharp_query+0x1d2>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80ce58:	89 d1                	mov    %edx,%ecx
  80ce5a:	8b 12                	mov    (%edx),%edx
  80ce5c:	85 d2                	test   %edx,%edx
  80ce5e:	75 f8                	jne    80ce58 <etharp_query+0x1c1>
              r = r->next;
            }
            r->next = new_entry;
  80ce60:	89 01                	mov    %eax,(%ecx)
  80ce62:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce67:	eb 29                	jmp    80ce92 <etharp_query+0x1fb>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80ce69:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80ce6c:	89 87 e0 7d b3 00    	mov    %eax,0xb37de0(%edi)
  80ce72:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce77:	eb 19                	jmp    80ce92 <etharp_query+0x1fb>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80ce79:	89 1c 24             	mov    %ebx,(%esp)
  80ce7c:	e8 57 b0 ff ff       	call   807ed8 <pbuf_free>
  80ce81:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80ce85:	eb 0b                	jmp    80ce92 <etharp_query+0x1fb>
  80ce87:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80ce8c:	eb 04                	jmp    80ce92 <etharp_query+0x1fb>
  80ce8e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80ce92:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ce95:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ce98:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ce9b:	89 ec                	mov    %ebp,%esp
  80ce9d:	5d                   	pop    %ebp
  80ce9e:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80ce9f:	8b 45 10             	mov    0x10(%ebp),%eax
  80cea2:	89 04 24             	mov    %eax,(%esp)
  80cea5:	e8 e0 ab ff ff       	call   807a8a <pbuf_ref>
  80ceaa:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80cead:	eb 83                	jmp    80ce32 <etharp_query+0x19b>

0080ceaf <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80ceaf:	55                   	push   %ebp
  80ceb0:	89 e5                	mov    %esp,%ebp
  80ceb2:	83 ec 48             	sub    $0x48,%esp
  80ceb5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ceb8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cebb:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cebe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80cec1:	8b 75 0c             	mov    0xc(%ebp),%esi
  80cec4:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80cec7:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80cece:	00 
  80cecf:	89 34 24             	mov    %esi,(%esp)
  80ced2:	e8 8c ac ff ff       	call   807b63 <pbuf_header>
  80ced7:	89 c2                	mov    %eax,%edx
  80ced9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80cede:	84 d2                	test   %dl,%dl
  80cee0:	0f 85 bd 00 00 00    	jne    80cfa3 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cee6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ceea:	89 3c 24             	mov    %edi,(%esp)
  80ceed:	e8 d6 c9 ff ff       	call   8098c8 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cef2:	ba 63 40 81 00       	mov    $0x814063,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cef7:	84 c0                	test   %al,%al
  80cef9:	0f 85 95 00 00 00    	jne    80cf94 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80ceff:	8b 07                	mov    (%edi),%eax
  80cf01:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80cf04:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cf0b:	e8 0a e0 ff ff       	call   80af1a <ntohl>
  80cf10:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80cf13:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cf1a:	e8 fb df ff ff       	call   80af1a <ntohl>
  80cf1f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80cf22:	23 55 d0             	and    -0x30(%ebp),%edx
  80cf25:	39 c2                	cmp    %eax,%edx
  80cf27:	75 41                	jne    80cf6a <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80cf29:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80cf2d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80cf31:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80cf35:	8b 07                	mov    (%edi),%eax
  80cf37:	89 04 24             	mov    %eax,(%esp)
  80cf3a:	e8 db df ff ff       	call   80af1a <ntohl>
  80cf3f:	c1 e8 10             	shr    $0x10,%eax
  80cf42:	83 e0 7f             	and    $0x7f,%eax
  80cf45:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80cf48:	8b 07                	mov    (%edi),%eax
  80cf4a:	89 04 24             	mov    %eax,(%esp)
  80cf4d:	e8 c8 df ff ff       	call   80af1a <ntohl>
  80cf52:	c1 e8 08             	shr    $0x8,%eax
  80cf55:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80cf58:	8b 07                	mov    (%edi),%eax
  80cf5a:	89 04 24             	mov    %eax,(%esp)
  80cf5d:	e8 b8 df ff ff       	call   80af1a <ntohl>
  80cf62:	88 45 e7             	mov    %al,-0x19(%ebp)
  80cf65:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80cf68:	eb 2a                	jmp    80cf94 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80cf6a:	8b 43 04             	mov    0x4(%ebx),%eax
  80cf6d:	33 07                	xor    (%edi),%eax
  80cf6f:	85 43 08             	test   %eax,0x8(%ebx)
  80cf72:	74 0e                	je     80cf82 <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80cf74:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80cf79:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80cf7d:	74 24                	je     80cfa3 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80cf7f:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cf82:	89 74 24 08          	mov    %esi,0x8(%esp)
  80cf86:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80cf8a:	89 1c 24             	mov    %ebx,(%esp)
  80cf8d:	e8 05 fd ff ff       	call   80cc97 <etharp_query>
  80cf92:	eb 0f                	jmp    80cfa3 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80cf94:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80cf97:	89 14 24             	mov    %edx,(%esp)
  80cf9a:	89 f2                	mov    %esi,%edx
  80cf9c:	89 d8                	mov    %ebx,%eax
  80cf9e:	e8 5d f8 ff ff       	call   80c800 <etharp_send_ip>
}
  80cfa3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cfa6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cfa9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cfac:	89 ec                	mov    %ebp,%esp
  80cfae:	5d                   	pop    %ebp
  80cfaf:	c3                   	ret    

0080cfb0 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80cfb0:	55                   	push   %ebp
  80cfb1:	89 e5                	mov    %esp,%ebp
  80cfb3:	53                   	push   %ebx
  80cfb4:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80cfb7:	ba 02 00 00 00       	mov    $0x2,%edx
  80cfbc:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cfbf:	e8 9f fa ff ff       	call   80ca63 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80cfc4:	84 c0                	test   %al,%al
  80cfc6:	78 29                	js     80cff1 <etharp_find_addr+0x41>
  80cfc8:	0f be d0             	movsbl %al,%edx
  80cfcb:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80cfce:	83 b9 f0 7d b3 00 02 	cmpl   $0x2,0xb37df0(%ecx)
  80cfd5:	75 1a                	jne    80cff1 <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80cfd7:	89 ca                	mov    %ecx,%edx
  80cfd9:	81 c2 e0 7d b3 00    	add    $0xb37de0,%edx
  80cfdf:	8d 5a 08             	lea    0x8(%edx),%ebx
  80cfe2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80cfe5:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80cfe7:	83 c2 04             	add    $0x4,%edx
  80cfea:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80cfed:	89 11                	mov    %edx,(%ecx)
      return i;
  80cfef:	eb 05                	jmp    80cff6 <etharp_find_addr+0x46>
  80cff1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80cff6:	83 c4 04             	add    $0x4,%esp
  80cff9:	5b                   	pop    %ebx
  80cffa:	5d                   	pop    %ebp
  80cffb:	c3                   	ret    

0080cffc <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80cffc:	55                   	push   %ebp
  80cffd:	89 e5                	mov    %esp,%ebp
  80cfff:	57                   	push   %edi
  80d000:	56                   	push   %esi
  80d001:	53                   	push   %ebx
  80d002:	83 ec 0c             	sub    $0xc,%esp
  80d005:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80d00a:	be f4 7d b3 00       	mov    $0xb37df4,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80d00f:	bf f0 7d b3 00       	mov    $0xb37df0,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80d014:	0f b6 14 1e          	movzbl (%esi,%ebx,1),%edx
  80d018:	83 c2 01             	add    $0x1,%edx
  80d01b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80d01e:	8b 04 1f             	mov    (%edi,%ebx,1),%eax
  80d021:	83 f8 02             	cmp    $0x2,%eax
  80d024:	75 07                	jne    80d02d <etharp_tmr+0x31>
  80d026:	80 fa ef             	cmp    $0xef,%dl
  80d029:	77 0f                	ja     80d03a <etharp_tmr+0x3e>
  80d02b:	eb 2d                	jmp    80d05a <etharp_tmr+0x5e>
  80d02d:	83 f8 01             	cmp    $0x1,%eax
  80d030:	75 28                	jne    80d05a <etharp_tmr+0x5e>
  80d032:	80 fa 01             	cmp    $0x1,%dl
  80d035:	8d 76 00             	lea    0x0(%esi),%esi
  80d038:	76 20                	jbe    80d05a <etharp_tmr+0x5e>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80d03a:	8b 83 e0 7d b3 00    	mov    0xb37de0(%ebx),%eax
  80d040:	85 c0                	test   %eax,%eax
  80d042:	74 0f                	je     80d053 <etharp_tmr+0x57>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80d044:	e8 7d f9 ff ff       	call   80c9c6 <free_etharp_q>
        arp_table[i].q = NULL;
  80d049:	c7 83 e0 7d b3 00 00 	movl   $0x0,0xb37de0(%ebx)
  80d050:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80d053:	c7 04 1f 00 00 00 00 	movl   $0x0,(%edi,%ebx,1)
  80d05a:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80d05d:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80d063:	75 af                	jne    80d014 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80d065:	83 c4 0c             	add    $0xc,%esp
  80d068:	5b                   	pop    %ebx
  80d069:	5e                   	pop    %esi
  80d06a:	5f                   	pop    %edi
  80d06b:	5d                   	pop    %ebp
  80d06c:	c3                   	ret    

0080d06d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80d06d:	55                   	push   %ebp
  80d06e:	89 e5                	mov    %esp,%ebp
  80d070:	83 ec 38             	sub    $0x38,%esp
  80d073:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d076:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d079:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d07c:	89 c6                	mov    %eax,%esi
  80d07e:	89 d3                	mov    %edx,%ebx
  80d080:	89 cf                	mov    %ecx,%edi
  80d082:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80d086:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80d089:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80d08d:	74 1c                	je     80d0ab <update_arp_entry+0x3e>
  80d08f:	c7 44 24 08 a4 3f 81 	movl   $0x813fa4,0x8(%esp)
  80d096:	00 
  80d097:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80d09e:	00 
  80d09f:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80d0a6:	e8 d1 38 ff ff       	call   80097c <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d0ab:	85 d2                	test   %edx,%edx
  80d0ad:	0f 84 14 01 00 00    	je     80d1c7 <update_arp_entry+0x15a>
  80d0b3:	83 3a 00             	cmpl   $0x0,(%edx)
  80d0b6:	0f 84 0b 01 00 00    	je     80d1c7 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80d0bc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d0c0:	89 14 24             	mov    %edx,(%esp)
  80d0c3:	e8 00 c8 ff ff       	call   8098c8 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d0c8:	84 c0                	test   %al,%al
  80d0ca:	0f 85 f7 00 00 00    	jne    80d1c7 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80d0d0:	8b 13                	mov    (%ebx),%edx
  80d0d2:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80d0d5:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d0dc:	e8 39 de ff ff       	call   80af1a <ntohl>
  80d0e1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80d0e4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d0eb:	e8 2a de ff ff       	call   80af1a <ntohl>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d0f0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80d0f3:	23 55 e0             	and    -0x20(%ebp),%edx
  80d0f6:	39 c2                	cmp    %eax,%edx
  80d0f8:	0f 84 c9 00 00 00    	je     80d1c7 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80d0fe:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80d102:	89 d8                	mov    %ebx,%eax
  80d104:	e8 5a f9 ff ff       	call   80ca63 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80d109:	84 c0                	test   %al,%al
  80d10b:	0f 88 bb 00 00 00    	js     80d1cc <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80d111:	0f be c0             	movsbl %al,%eax
  80d114:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d117:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80d11a:	c7 80 f0 7d b3 00 02 	movl   $0x2,0xb37df0(%eax)
  80d121:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80d124:	89 b0 f8 7d b3 00    	mov    %esi,0xb37df8(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80d12a:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80d12e:	88 98 ed 7d b3 00    	mov    %bl,0xb37ded(%eax)
  80d134:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80d138:	bb e0 7d b3 00       	mov    $0xb37de0,%ebx
  80d13d:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80d141:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80d145:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80d149:	88 88 eb 7d b3 00    	mov    %cl,0xb37deb(%eax)
  80d14f:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80d153:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80d157:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80d15b:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80d15f:	88 88 e9 7d b3 00    	mov    %cl,0xb37de9(%eax)
  80d165:	0f b6 0f             	movzbl (%edi),%ecx
  80d168:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80d16c:	c6 80 f4 7d b3 00 00 	movb   $0x0,0xb37df4(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d173:	8d 4e 25             	lea    0x25(%esi),%ecx
  80d176:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d179:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80d17d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d180:	eb 39                	jmp    80d1bb <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80d182:	8b 10                	mov    (%eax),%edx
  80d184:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80d187:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80d18a:	8b 50 04             	mov    0x4(%eax),%edx
  80d18d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80d190:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d194:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80d19b:	e8 a0 a5 ff ff       	call   807740 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d1a0:	89 3c 24             	mov    %edi,(%esp)
  80d1a3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80d1a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d1a9:	89 f0                	mov    %esi,%eax
  80d1ab:	e8 50 f6 ff ff       	call   80c800 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80d1b0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d1b3:	89 0c 24             	mov    %ecx,(%esp)
  80d1b6:	e8 1d ad ff ff       	call   807ed8 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d1bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d1be:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80d1c1:	85 c0                	test   %eax,%eax
  80d1c3:	75 bd                	jne    80d182 <update_arp_entry+0x115>
  80d1c5:	eb 05                	jmp    80d1cc <update_arp_entry+0x15f>
  80d1c7:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80d1cc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d1cf:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d1d2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d1d5:	89 ec                	mov    %ebp,%esp
  80d1d7:	5d                   	pop    %ebp
  80d1d8:	c3                   	ret    

0080d1d9 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80d1d9:	55                   	push   %ebp
  80d1da:	89 e5                	mov    %esp,%ebp
  80d1dc:	83 ec 18             	sub    $0x18,%esp
  80d1df:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d1e2:	85 c0                	test   %eax,%eax
  80d1e4:	75 1c                	jne    80d202 <etharp_ip_input+0x29>
  80d1e6:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  80d1ed:	00 
  80d1ee:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80d1f5:	00 
  80d1f6:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80d1fd:	e8 7a 37 ff ff       	call   80097c <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80d202:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d205:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80d208:	8b 48 04             	mov    0x4(%eax),%ecx
  80d20b:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80d20e:	85 48 08             	test   %ecx,0x8(%eax)
  80d211:	75 12                	jne    80d225 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80d213:	8d 4a 06             	lea    0x6(%edx),%ecx
  80d216:	83 c2 1c             	add    $0x1c,%edx
  80d219:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d220:	e8 48 fe ff ff       	call   80d06d <update_arp_entry>
}
  80d225:	c9                   	leave  
  80d226:	c3                   	ret    

0080d227 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80d227:	55                   	push   %ebp
  80d228:	89 e5                	mov    %esp,%ebp
  80d22a:	83 ec 38             	sub    $0x38,%esp
  80d22d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d230:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d233:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d236:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d239:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80d23d:	75 1c                	jne    80d25b <etharp_arp_input+0x34>
  80d23f:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  80d246:	00 
  80d247:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80d24e:	00 
  80d24f:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80d256:	e8 21 37 ff ff       	call   80097c <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80d25b:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80d260:	77 0d                	ja     80d26f <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d262:	89 1c 24             	mov    %ebx,(%esp)
  80d265:	e8 6e ac ff ff       	call   807ed8 <pbuf_free>
    return;
  80d26a:	e9 ab 01 00 00       	jmp    80d41a <etharp_arp_input+0x1f3>
  }

  hdr = p->payload;
  80d26f:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d272:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80d276:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d27d:	e8 52 da ff ff       	call   80acd4 <htons>
  80d282:	66 39 c7             	cmp    %ax,%di
  80d285:	75 3f                	jne    80d2c6 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80d287:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80d28b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80d292:	e8 3d da ff ff       	call   80acd4 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d297:	66 39 c7             	cmp    %ax,%di
  80d29a:	75 2a                	jne    80d2c6 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80d29c:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80d2a0:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80d2a7:	e8 28 da ff ff       	call   80acd4 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d2ac:	66 39 c7             	cmp    %ax,%di
  80d2af:	75 15                	jne    80d2c6 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80d2b1:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80d2b5:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80d2bc:	e8 13 da ff ff       	call   80acd4 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d2c1:	66 39 c7             	cmp    %ax,%di
  80d2c4:	74 0f                	je     80d2d5 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d2c6:	89 1c 24             	mov    %ebx,(%esp)
  80d2c9:	e8 0a ac ff ff       	call   807ed8 <pbuf_free>
    return;
  80d2ce:	66 90                	xchg   %ax,%ax
  80d2d0:	e9 45 01 00 00       	jmp    80d41a <etharp_arp_input+0x1f3>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80d2d5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d2dc:	00 
  80d2dd:	8d 46 1c             	lea    0x1c(%esi),%eax
  80d2e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d2e4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d2e7:	89 04 24             	mov    %eax,(%esp)
  80d2ea:	e8 62 40 ff ff       	call   801351 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80d2ef:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d2f6:	00 
  80d2f7:	8d 46 26             	lea    0x26(%esi),%eax
  80d2fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d2fe:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80d301:	89 04 24             	mov    %eax,(%esp)
  80d304:	e8 48 40 ff ff       	call   801351 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d309:	8b 55 08             	mov    0x8(%ebp),%edx
  80d30c:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d30f:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d314:	85 c0                	test   %eax,%eax
  80d316:	74 21                	je     80d339 <etharp_arp_input+0x112>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80d318:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80d31b:	0f 94 c0             	sete   %al
  80d31e:	89 c7                	mov    %eax,%edi
  80d320:	75 17                	jne    80d339 <etharp_arp_input+0x112>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d322:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d325:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d328:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d32f:	8b 45 08             	mov    0x8(%ebp),%eax
  80d332:	e8 36 fd ff ff       	call   80d06d <update_arp_entry>
  80d337:	eb 15                	jmp    80d34e <etharp_arp_input+0x127>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80d339:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d33c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d33f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d346:	8b 45 08             	mov    0x8(%ebp),%eax
  80d349:	e8 1f fd ff ff       	call   80d06d <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80d34e:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80d352:	89 04 24             	mov    %eax,(%esp)
  80d355:	e8 7a d9 ff ff       	call   80acd4 <htons>
  80d35a:	66 83 f8 01          	cmp    $0x1,%ax
  80d35e:	74 15                	je     80d375 <etharp_arp_input+0x14e>
  80d360:	66 83 f8 02          	cmp    $0x2,%ax
  80d364:	0f 85 a8 00 00 00    	jne    80d412 <etharp_arp_input+0x1eb>
  80d36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d370:	e9 8b 00 00 00       	jmp    80d400 <etharp_arp_input+0x1d9>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80d375:	89 fa                	mov    %edi,%edx
  80d377:	84 d2                	test   %dl,%dl
  80d379:	0f 84 93 00 00 00    	je     80d412 <etharp_arp_input+0x1eb>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80d37f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80d386:	e8 49 d9 ff ff       	call   80acd4 <htons>
  80d38b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80d38f:	8b 46 1c             	mov    0x1c(%esi),%eax
  80d392:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80d395:	8b 55 08             	mov    0x8(%ebp),%edx
  80d398:	8b 42 04             	mov    0x4(%edx),%eax
  80d39b:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80d39e:	ba 06 00 00 00       	mov    $0x6,%edx
  80d3a3:	8b 45 08             	mov    0x8(%ebp),%eax
  80d3a6:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80d3aa:	74 1c                	je     80d3c8 <etharp_arp_input+0x1a1>
  80d3ac:	c7 44 24 08 04 3f 81 	movl   $0x813f04,0x8(%esp)
  80d3b3:	00 
  80d3b4:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80d3bb:	00 
  80d3bc:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80d3c3:	e8 b4 35 ff ff       	call   80097c <_panic>
  80d3c8:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80d3cb:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80d3ce:	0f b6 c2             	movzbl %dl,%eax
  80d3d1:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80d3d6:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80d3da:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80d3dd:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d3e1:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80d3e5:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d3e9:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80d3ed:	84 d2                	test   %dl,%dl
  80d3ef:	75 da                	jne    80d3cb <etharp_arp_input+0x1a4>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80d3f1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d3f5:	8b 55 08             	mov    0x8(%ebp),%edx
  80d3f8:	89 14 24             	mov    %edx,(%esp)
  80d3fb:	ff 52 18             	call   *0x18(%edx)
  80d3fe:	eb 12                	jmp    80d412 <etharp_arp_input+0x1eb>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80d400:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d403:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d407:	8b 45 08             	mov    0x8(%ebp),%eax
  80d40a:	89 04 24             	mov    %eax,(%esp)
  80d40d:	e8 75 90 ff ff       	call   806487 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80d412:	89 1c 24             	mov    %ebx,(%esp)
  80d415:	e8 be aa ff ff       	call   807ed8 <pbuf_free>
}
  80d41a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d41d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d420:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d423:	89 ec                	mov    %ebp,%esp
  80d425:	5d                   	pop    %ebp
  80d426:	c3                   	ret    

0080d427 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80d427:	55                   	push   %ebp
  80d428:	89 e5                	mov    %esp,%ebp
  80d42a:	83 ec 18             	sub    $0x18,%esp
  80d42d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d430:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d433:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d436:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80d439:	8b 43 04             	mov    0x4(%ebx),%eax
  80d43c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d440:	89 04 24             	mov    %eax,(%esp)
  80d443:	e8 8c d8 ff ff       	call   80acd4 <htons>
  80d448:	66 3d 00 08          	cmp    $0x800,%ax
  80d44c:	74 0c                	je     80d45a <ethernet_input+0x33>
  80d44e:	66 3d 06 08          	cmp    $0x806,%ax
  80d452:	75 65                	jne    80d4b9 <ethernet_input+0x92>
  80d454:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d458:	eb 4a                	jmp    80d4a4 <ethernet_input+0x7d>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80d45a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d45e:	89 34 24             	mov    %esi,(%esp)
  80d461:	e8 73 fd ff ff       	call   80d1d9 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80d466:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80d46d:	ff 
  80d46e:	89 1c 24             	mov    %ebx,(%esp)
  80d471:	e8 ed a6 ff ff       	call   807b63 <pbuf_header>
  80d476:	84 c0                	test   %al,%al
  80d478:	74 1c                	je     80d496 <ethernet_input+0x6f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80d47a:	c7 44 24 08 cc 3f 81 	movl   $0x813fcc,0x8(%esp)
  80d481:	00 
  80d482:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80d489:	00 
  80d48a:	c7 04 24 ed 3f 81 00 	movl   $0x813fed,(%esp)
  80d491:	e8 e6 34 ff ff       	call   80097c <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80d496:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d49a:	89 1c 24             	mov    %ebx,(%esp)
  80d49d:	e8 f2 c6 ff ff       	call   809b94 <ip_input>
      }
      break;
  80d4a2:	eb 1d                	jmp    80d4c1 <ethernet_input+0x9a>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80d4a4:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80d4a8:	8d 46 25             	lea    0x25(%esi),%eax
  80d4ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d4af:	89 34 24             	mov    %esi,(%esp)
  80d4b2:	e8 70 fd ff ff       	call   80d227 <etharp_arp_input>
      break;
  80d4b7:	eb 08                	jmp    80d4c1 <ethernet_input+0x9a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80d4b9:	89 1c 24             	mov    %ebx,(%esp)
  80d4bc:	e8 17 aa ff ff       	call   807ed8 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80d4c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4c6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d4c9:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d4cc:	89 ec                	mov    %ebp,%esp
  80d4ce:	5d                   	pop    %ebp
  80d4cf:	c3                   	ret    

0080d4d0 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80d4d0:	55                   	push   %ebp
  80d4d1:	89 e5                	mov    %esp,%ebp
  80d4d3:	56                   	push   %esi
  80d4d4:	53                   	push   %ebx
  80d4d5:	b8 00 7f b3 00       	mov    $0xb37f00,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d4da:	be 00 93 b3 00       	mov    $0xb39300,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80d4df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d4e5:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80d4e7:	8b 15 00 93 b3 00    	mov    0xb39300,%edx
  80d4ed:	89 50 0c             	mov    %edx,0xc(%eax)
  80d4f0:	85 d2                	test   %edx,%edx
  80d4f2:	74 06                	je     80d4fa <sys_init+0x2a>
  80d4f4:	8d 58 0c             	lea    0xc(%eax),%ebx
  80d4f7:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d4fa:	89 0d 00 93 b3 00    	mov    %ecx,0xb39300
  80d500:	c7 40 10 00 93 b3 00 	movl   $0xb39300,0x10(%eax)
  80d507:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80d50a:	39 f0                	cmp    %esi,%eax
  80d50c:	75 d1                	jne    80d4df <sys_init+0xf>
  80d50e:	b8 20 93 b3 00       	mov    $0xb39320,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d513:	be 20 e1 b3 00       	mov    $0xb3e120,%esi
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80d518:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d51e:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80d520:	8b 15 20 e1 b3 00    	mov    0xb3e120,%edx
  80d526:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80d52c:	85 d2                	test   %edx,%edx
  80d52e:	74 0c                	je     80d53c <sys_init+0x6c>
  80d530:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80d536:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80d53c:	89 0d 20 e1 b3 00    	mov    %ecx,0xb3e120
  80d542:	c7 80 98 00 00 00 20 	movl   $0xb3e120,0x98(%eax)
  80d549:	e1 b3 00 
  80d54c:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80d551:	39 f0                	cmp    %esi,%eax
  80d553:	75 c3                	jne    80d518 <sys_init+0x48>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80d555:	5b                   	pop    %ebx
  80d556:	5e                   	pop    %esi
  80d557:	5d                   	pop    %ebp
  80d558:	c3                   	ret    

0080d559 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80d559:	55                   	push   %ebp
  80d55a:	89 e5                	mov    %esp,%ebp
}
  80d55c:	5d                   	pop    %ebp
  80d55d:	c3                   	ret    

0080d55e <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80d55e:	55                   	push   %ebp
  80d55f:	89 e5                	mov    %esp,%ebp
}
  80d561:	5d                   	pop    %ebp
  80d562:	c3                   	ret    

0080d563 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d563:	55                   	push   %ebp
  80d564:	89 e5                	mov    %esp,%ebp
  80d566:	83 ec 18             	sub    $0x18,%esp
  80d569:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d56c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d56f:	83 3c 95 00 7f b3 00 	cmpl   $0x0,0xb37f00(,%edx,4)
  80d576:	00 
  80d577:	74 24                	je     80d59d <sys_sem_free+0x3a>
  80d579:	c7 44 24 0c 6f 40 81 	movl   $0x81406f,0xc(%esp)
  80d580:	00 
  80d581:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80d588:	00 
  80d589:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80d590:	00 
  80d591:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d598:	e8 df 33 ff ff       	call   80097c <_panic>
    sems[sem].freed = 1;
  80d59d:	ba 00 7f b3 00       	mov    $0xb37f00,%edx
  80d5a2:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80d5a5:	c1 e0 02             	shl    $0x2,%eax
  80d5a8:	c7 04 10 01 00 00 00 	movl   $0x1,(%eax,%edx,1)
    sems[sem].gen++;
  80d5af:	83 44 02 04 01       	addl   $0x1,0x4(%edx,%eax,1)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d5b4:	01 d0                	add    %edx,%eax
  80d5b6:	8b 15 00 93 b3 00    	mov    0xb39300,%edx
  80d5bc:	89 50 0c             	mov    %edx,0xc(%eax)
  80d5bf:	85 d2                	test   %edx,%edx
  80d5c1:	74 06                	je     80d5c9 <sys_sem_free+0x66>
  80d5c3:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d5c6:	89 4a 10             	mov    %ecx,0x10(%edx)
  80d5c9:	a3 00 93 b3 00       	mov    %eax,0xb39300
  80d5ce:	c7 40 10 00 93 b3 00 	movl   $0xb39300,0x10(%eax)
}
  80d5d5:	c9                   	leave  
  80d5d6:	c3                   	ret    

0080d5d7 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d5d7:	55                   	push   %ebp
  80d5d8:	89 e5                	mov    %esp,%ebp
  80d5da:	56                   	push   %esi
  80d5db:	53                   	push   %ebx
  80d5dc:	83 ec 10             	sub    $0x10,%esp
  80d5df:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d5e2:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d5e8:	83 b8 20 93 b3 00 00 	cmpl   $0x0,0xb39320(%eax)
  80d5ef:	74 24                	je     80d615 <sys_mbox_free+0x3e>
  80d5f1:	c7 44 24 0c 9d 40 81 	movl   $0x81409d,0xc(%esp)
  80d5f8:	00 
  80d5f9:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80d600:	00 
  80d601:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80d608:	00 
  80d609:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d610:	e8 67 33 ff ff       	call   80097c <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d615:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d61b:	8b 83 ac 93 b3 00    	mov    0xb393ac(%ebx),%eax
  80d621:	89 04 24             	mov    %eax,(%esp)
  80d624:	e8 3a ff ff ff       	call   80d563 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d629:	8b 83 b0 93 b3 00    	mov    0xb393b0(%ebx),%eax
  80d62f:	89 04 24             	mov    %eax,(%esp)
  80d632:	e8 2c ff ff ff       	call   80d563 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d637:	81 c3 20 93 b3 00    	add    $0xb39320,%ebx
  80d63d:	a1 20 e1 b3 00       	mov    0xb3e120,%eax
  80d642:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80d648:	85 c0                	test   %eax,%eax
  80d64a:	74 0c                	je     80d658 <sys_mbox_free+0x81>
  80d64c:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80d652:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d658:	89 1d 20 e1 b3 00    	mov    %ebx,0xb3e120
  80d65e:	c7 83 98 00 00 00 20 	movl   $0xb3e120,0x98(%ebx)
  80d665:	e1 b3 00 
    mboxes[mbox].freed = 1;
  80d668:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d66e:	c7 86 20 93 b3 00 01 	movl   $0x1,0xb39320(%esi)
  80d675:	00 00 00 
}
  80d678:	83 c4 10             	add    $0x10,%esp
  80d67b:	5b                   	pop    %ebx
  80d67c:	5e                   	pop    %esi
  80d67d:	5d                   	pop    %ebp
  80d67e:	c3                   	ret    

0080d67f <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d67f:	55                   	push   %ebp
  80d680:	89 e5                	mov    %esp,%ebp
  80d682:	57                   	push   %edi
  80d683:	56                   	push   %esi
  80d684:	53                   	push   %ebx
  80d685:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d688:	e8 e6 07 00 00       	call   80de73 <thread_id>
  80d68d:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d68f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d694:	f7 e2                	mul    %edx
  80d696:	c1 ea 08             	shr    $0x8,%edx
  80d699:	89 d0                	mov    %edx,%eax
  80d69b:	c1 e0 08             	shl    $0x8,%eax
  80d69e:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d6a1:	89 f0                	mov    %esi,%eax
  80d6a3:	29 d0                	sub    %edx,%eax
  80d6a5:	8d 3c 85 40 e1 b3 00 	lea    0xb3e140(,%eax,4),%edi
  80d6ac:	8b 1f                	mov    (%edi),%ebx
  80d6ae:	85 db                	test   %ebx,%ebx
  80d6b0:	74 20                	je     80d6d2 <sys_arch_timeouts+0x53>
	if (t->tid == tid)
  80d6b2:	3b 33                	cmp    (%ebx),%esi
  80d6b4:	75 10                	jne    80d6c6 <sys_arch_timeouts+0x47>
  80d6b6:	e9 b0 00 00 00       	jmp    80d76b <sys_arch_timeouts+0xec>
  80d6bb:	3b 33                	cmp    (%ebx),%esi
  80d6bd:	8d 76 00             	lea    0x0(%esi),%esi
  80d6c0:	0f 84 a5 00 00 00    	je     80d76b <sys_arch_timeouts+0xec>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d6c6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d6c9:	85 db                	test   %ebx,%ebx
  80d6cb:	90                   	nop
  80d6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d6d0:	75 e9                	jne    80d6bb <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d6d2:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d6d9:	e8 05 56 ff ff       	call   802ce3 <malloc>
  80d6de:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d6e0:	85 c0                	test   %eax,%eax
  80d6e2:	75 1c                	jne    80d700 <sys_arch_timeouts+0x81>
	panic("sys_arch_timeouts: cannot malloc");
  80d6e4:	c7 44 24 08 00 41 81 	movl   $0x814100,0x8(%esp)
  80d6eb:	00 
  80d6ec:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80d6f3:	00 
  80d6f4:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d6fb:	e8 7c 32 ff ff       	call   80097c <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d700:	c7 04 24 76 d7 80 00 	movl   $0x80d776,(%esp)
  80d707:	e8 ba 07 00 00       	call   80dec6 <thread_onhalt>
    if (r < 0)
  80d70c:	85 c0                	test   %eax,%eax
  80d70e:	79 28                	jns    80d738 <sys_arch_timeouts+0xb9>
	panic("thread_onhalt failed: %s", e2s(r));
  80d710:	89 04 24             	mov    %eax,(%esp)
  80d713:	e8 20 0b 00 00       	call   80e238 <e2s>
  80d718:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d71c:	c7 44 24 08 b1 40 81 	movl   $0x8140b1,0x8(%esp)
  80d723:	00 
  80d724:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80d72b:	00 
  80d72c:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d733:	e8 44 32 ff ff       	call   80097c <_panic>

    t->tid = tid;
  80d738:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d73a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d741:	00 
  80d742:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d749:	00 
  80d74a:	8d 43 04             	lea    0x4(%ebx),%eax
  80d74d:	89 04 24             	mov    %eax,(%esp)
  80d750:	e8 21 3b ff ff       	call   801276 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d755:	8b 07                	mov    (%edi),%eax
  80d757:	89 43 08             	mov    %eax,0x8(%ebx)
  80d75a:	85 c0                	test   %eax,%eax
  80d75c:	74 08                	je     80d766 <sys_arch_timeouts+0xe7>
  80d75e:	8b 07                	mov    (%edi),%eax
  80d760:	8d 53 08             	lea    0x8(%ebx),%edx
  80d763:	89 50 0c             	mov    %edx,0xc(%eax)
  80d766:	89 1f                	mov    %ebx,(%edi)
  80d768:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80d76b:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80d76e:	83 c4 1c             	add    $0x1c,%esp
  80d771:	5b                   	pop    %ebx
  80d772:	5e                   	pop    %esi
  80d773:	5f                   	pop    %edi
  80d774:	5d                   	pop    %ebp
  80d775:	c3                   	ret    

0080d776 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d776:	55                   	push   %ebp
  80d777:	89 e5                	mov    %esp,%ebp
  80d779:	83 ec 18             	sub    $0x18,%esp
  80d77c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d77f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d784:	89 c8                	mov    %ecx,%eax
  80d786:	f7 e2                	mul    %edx
  80d788:	c1 ea 08             	shr    $0x8,%edx
  80d78b:	89 d0                	mov    %edx,%eax
  80d78d:	c1 e0 08             	shl    $0x8,%eax
  80d790:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d793:	89 c8                	mov    %ecx,%eax
  80d795:	29 d0                	sub    %edx,%eax
  80d797:	8b 04 85 40 e1 b3 00 	mov    0xb3e140(,%eax,4),%eax
  80d79e:	85 c0                	test   %eax,%eax
  80d7a0:	74 36                	je     80d7d8 <timeout_cleanup+0x62>
	if (t->tid == tid) {
  80d7a2:	39 08                	cmp    %ecx,(%eax)
  80d7a4:	75 2b                	jne    80d7d1 <timeout_cleanup+0x5b>
  80d7a6:	eb 0a                	jmp    80d7b2 <timeout_cleanup+0x3c>
  80d7a8:	39 08                	cmp    %ecx,(%eax)
  80d7aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d7b0:	75 1f                	jne    80d7d1 <timeout_cleanup+0x5b>
	    LIST_REMOVE(t, link);
  80d7b2:	8b 50 08             	mov    0x8(%eax),%edx
  80d7b5:	85 d2                	test   %edx,%edx
  80d7b7:	74 06                	je     80d7bf <timeout_cleanup+0x49>
  80d7b9:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d7bc:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80d7bf:	8b 50 0c             	mov    0xc(%eax),%edx
  80d7c2:	8b 48 08             	mov    0x8(%eax),%ecx
  80d7c5:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80d7c7:	89 04 24             	mov    %eax,(%esp)
  80d7ca:	e8 41 54 ff ff       	call   802c10 <free>
	    goto done;
  80d7cf:	eb 07                	jmp    80d7d8 <timeout_cleanup+0x62>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d7d1:	8b 40 08             	mov    0x8(%eax),%eax
  80d7d4:	85 c0                	test   %eax,%eax
  80d7d6:	75 d0                	jne    80d7a8 <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d7d8:	c9                   	leave  
  80d7d9:	c3                   	ret    

0080d7da <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d7da:	55                   	push   %ebp
  80d7db:	89 e5                	mov    %esp,%ebp
  80d7dd:	53                   	push   %ebx
  80d7de:	83 ec 14             	sub    $0x14,%esp
  80d7e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d7e4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d7e7:	89 04 24             	mov    %eax,(%esp)
  80d7ea:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d7ec:	89 1c 24             	mov    %ebx,(%esp)
  80d7ef:	e8 1c 54 ff ff       	call   802c10 <free>
}
  80d7f4:	83 c4 14             	add    $0x14,%esp
  80d7f7:	5b                   	pop    %ebx
  80d7f8:	5d                   	pop    %ebp
  80d7f9:	c3                   	ret    

0080d7fa <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d7fa:	55                   	push   %ebp
  80d7fb:	89 e5                	mov    %esp,%ebp
  80d7fd:	53                   	push   %ebx
  80d7fe:	83 ec 24             	sub    $0x24,%esp
  80d801:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d804:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d80b:	e8 d3 54 ff ff       	call   802ce3 <malloc>
    if (lt == 0)
  80d810:	85 c0                	test   %eax,%eax
  80d812:	75 1c                	jne    80d830 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80d814:	c7 44 24 08 24 41 81 	movl   $0x814124,0x8(%esp)
  80d81b:	00 
  80d81c:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80d823:	00 
  80d824:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d82b:	e8 4c 31 ff ff       	call   80097c <_panic>

    if (stacksize > PGSIZE)
  80d830:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d836:	7e 20                	jle    80d858 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d838:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80d83c:	c7 44 24 08 ca 40 81 	movl   $0x8140ca,0x8(%esp)
  80d843:	00 
  80d844:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80d84b:	00 
  80d84c:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d853:	e8 24 31 ff ff       	call   80097c <_panic>

    lt->func = thread;
  80d858:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d85b:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d85d:	8b 55 10             	mov    0x10(%ebp),%edx
  80d860:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d863:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d867:	c7 44 24 08 da d7 80 	movl   $0x80d7da,0x8(%esp)
  80d86e:	00 
  80d86f:	8b 45 08             	mov    0x8(%ebp),%eax
  80d872:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d876:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80d879:	89 04 24             	mov    %eax,(%esp)
  80d87c:	e8 b6 07 00 00       	call   80e037 <thread_create>

    if (r < 0)
  80d881:	85 c0                	test   %eax,%eax
  80d883:	79 28                	jns    80d8ad <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d885:	89 04 24             	mov    %eax,(%esp)
  80d888:	e8 ab 09 00 00       	call   80e238 <e2s>
  80d88d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d891:	c7 44 24 08 54 41 81 	movl   $0x814154,0x8(%esp)
  80d898:	00 
  80d899:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80d8a0:	00 
  80d8a1:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d8a8:	e8 cf 30 ff ff       	call   80097c <_panic>

    return tid;
}
  80d8ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80d8b0:	83 c4 24             	add    $0x24,%esp
  80d8b3:	5b                   	pop    %ebx
  80d8b4:	5d                   	pop    %ebp
  80d8b5:	c3                   	ret    

0080d8b6 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d8b6:	55                   	push   %ebp
  80d8b7:	89 e5                	mov    %esp,%ebp
  80d8b9:	57                   	push   %edi
  80d8ba:	56                   	push   %esi
  80d8bb:	53                   	push   %ebx
  80d8bc:	83 ec 3c             	sub    $0x3c,%esp
    assert(!sems[sem].freed);
  80d8bf:	8b 55 08             	mov    0x8(%ebp),%edx
  80d8c2:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d8c5:	83 3c 85 00 7f b3 00 	cmpl   $0x0,0xb37f00(,%eax,4)
  80d8cc:	00 
  80d8cd:	74 24                	je     80d8f3 <sys_arch_sem_wait+0x3d>
  80d8cf:	c7 44 24 0c 6f 40 81 	movl   $0x81406f,0xc(%esp)
  80d8d6:	00 
  80d8d7:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80d8de:	00 
  80d8df:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80d8e6:	00 
  80d8e7:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80d8ee:	e8 89 30 ff ff       	call   80097c <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d8f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d8f6:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d8f9:	8b 04 85 04 7f b3 00 	mov    0xb37f04(,%eax,4),%eax
  80d900:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d903:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d907:	0f 94 45 d7          	sete   -0x29(%ebp)
  80d90b:	0f 95 45 e3          	setne  -0x1d(%ebp)
  80d90f:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d913:	75 0a                	jne    80d91f <sys_arch_sem_wait+0x69>
  80d915:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d919:	0f 84 d7 00 00 00    	je     80d9f6 <sys_arch_sem_wait+0x140>
	if (sems[sem].counter > 0) {
  80d91f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d922:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d925:	0f b7 04 85 08 7f b3 	movzwl 0xb37f08(,%eax,4),%eax
  80d92c:	00 
  80d92d:	bf 00 00 00 00       	mov    $0x0,%edi
  80d932:	66 85 c0             	test   %ax,%ax
  80d935:	75 17                	jne    80d94e <sys_arch_sem_wait+0x98>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d937:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d93b:	75 27                	jne    80d964 <sys_arch_sem_wait+0xae>
  80d93d:	e9 b4 00 00 00       	jmp    80d9f6 <sys_arch_sem_wait+0x140>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d942:	0f b7 83 08 7f b3 00 	movzwl 0xb37f08(%ebx),%eax
  80d949:	66 85 c0             	test   %ax,%ax
  80d94c:	74 31                	je     80d97f <sys_arch_sem_wait+0xc9>
	    sems[sem].counter--;
  80d94e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d951:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d954:	83 e8 01             	sub    $0x1,%eax
  80d957:	66 89 04 95 08 7f b3 	mov    %ax,0xb37f08(,%edx,4)
  80d95e:	00 
	    return waited;
  80d95f:	e9 97 00 00 00       	jmp    80d9fb <sys_arch_sem_wait+0x145>
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d964:	8b 55 08             	mov    0x8(%ebp),%edx
  80d967:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d96a:	8d 04 85 08 7f b3 00 	lea    0xb37f08(,%eax,4),%eax
  80d971:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d974:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d979:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
  80d97c:	c1 e3 02             	shl    $0x2,%ebx
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d97f:	e8 53 3c ff ff       	call   8015d7 <sys_time_msec>
  80d984:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80d987:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d98c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d990:	74 08                	je     80d99a <sys_arch_sem_wait+0xe4>
  80d992:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d995:	03 45 0c             	add    0xc(%ebp),%eax
  80d998:	29 f8                	sub    %edi,%eax
	    sems[sem].waiters = 1;
  80d99a:	be 00 7f b3 00       	mov    $0xb37f00,%esi
  80d99f:	66 c7 44 33 0a 01 00 	movw   $0x1,0xa(%ebx,%esi,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d9a6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d9aa:	8b 44 33 08          	mov    0x8(%ebx,%esi,1),%eax
  80d9ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9b2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80d9b5:	89 0c 24             	mov    %ecx,(%esp)
  80d9b8:	e8 c2 07 00 00       	call   80e17f <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80d9bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d9c0:	39 44 33 04          	cmp    %eax,0x4(%ebx,%esi,1)
  80d9c4:	74 13                	je     80d9d9 <sys_arch_sem_wait+0x123>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d9c6:	c7 04 24 80 41 81 00 	movl   $0x814180,(%esp)
  80d9cd:	e8 6f 30 ff ff       	call   800a41 <cprintf>
  80d9d2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		return SYS_ARCH_TIMEOUT;
  80d9d7:	eb 22                	jmp    80d9fb <sys_arch_sem_wait+0x145>
	    }
	    uint32_t b = sys_time_msec();
  80d9d9:	e8 f9 3b ff ff       	call   8015d7 <sys_time_msec>
	    waited += (b - a);
  80d9de:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80d9e1:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80d9e3:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80d9e6:	0f 87 56 ff ff ff    	ja     80d942 <sys_arch_sem_wait+0x8c>
  80d9ec:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d9f0:	0f 85 4c ff ff ff    	jne    80d942 <sys_arch_sem_wait+0x8c>
  80d9f6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80d9fb:	89 f8                	mov    %edi,%eax
  80d9fd:	83 c4 3c             	add    $0x3c,%esp
  80da00:	5b                   	pop    %ebx
  80da01:	5e                   	pop    %esi
  80da02:	5f                   	pop    %edi
  80da03:	5d                   	pop    %ebp
  80da04:	c3                   	ret    

0080da05 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80da05:	55                   	push   %ebp
  80da06:	89 e5                	mov    %esp,%ebp
  80da08:	53                   	push   %ebx
  80da09:	83 ec 14             	sub    $0x14,%esp
  80da0c:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80da10:	a1 00 93 b3 00       	mov    0xb39300,%eax
    if (!se) {
  80da15:	85 c0                	test   %eax,%eax
  80da17:	75 13                	jne    80da2c <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80da19:	c7 04 24 ac 41 81 00 	movl   $0x8141ac,(%esp)
  80da20:	e8 1c 30 ff ff       	call   800a41 <cprintf>
  80da25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80da2a:	eb 5d                	jmp    80da89 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80da2c:	8b 50 0c             	mov    0xc(%eax),%edx
  80da2f:	85 d2                	test   %edx,%edx
  80da31:	74 06                	je     80da39 <sys_sem_new+0x34>
  80da33:	8b 58 10             	mov    0x10(%eax),%ebx
  80da36:	89 5a 10             	mov    %ebx,0x10(%edx)
  80da39:	8b 50 10             	mov    0x10(%eax),%edx
  80da3c:	8b 58 0c             	mov    0xc(%eax),%ebx
  80da3f:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80da41:	83 38 00             	cmpl   $0x0,(%eax)
  80da44:	75 24                	jne    80da6a <sys_sem_new+0x65>
  80da46:	c7 44 24 0c d9 40 81 	movl   $0x8140d9,0xc(%esp)
  80da4d:	00 
  80da4e:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80da55:	00 
  80da56:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80da5d:	00 
  80da5e:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80da65:	e8 12 2f ff ff       	call   80097c <_panic>
    se->freed = 0;
  80da6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80da70:	0f b6 c9             	movzbl %cl,%ecx
  80da73:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80da77:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80da7b:	2d 00 7f b3 00       	sub    $0xb37f00,%eax
  80da80:	c1 f8 02             	sar    $0x2,%eax
  80da83:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80da89:	83 c4 14             	add    $0x14,%esp
  80da8c:	5b                   	pop    %ebx
  80da8d:	5d                   	pop    %ebp
  80da8e:	c3                   	ret    

0080da8f <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80da8f:	55                   	push   %ebp
  80da90:	89 e5                	mov    %esp,%ebp
  80da92:	56                   	push   %esi
  80da93:	53                   	push   %ebx
  80da94:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80da97:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80da9b:	7e 24                	jle    80dac1 <sys_mbox_new+0x32>
  80da9d:	c7 44 24 0c e3 40 81 	movl   $0x8140e3,0xc(%esp)
  80daa4:	00 
  80daa5:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80daac:	00 
  80daad:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80dab4:	00 
  80dab5:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80dabc:	e8 bb 2e ff ff       	call   80097c <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80dac1:	8b 1d 20 e1 b3 00    	mov    0xb3e120,%ebx
    if (!mbe) {
  80dac7:	85 db                	test   %ebx,%ebx
  80dac9:	75 16                	jne    80dae1 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80dacb:	c7 04 24 d4 41 81 00 	movl   $0x8141d4,(%esp)
  80dad2:	e8 6a 2f ff ff       	call   800a41 <cprintf>
  80dad7:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80dadc:	e9 bd 00 00 00       	jmp    80db9e <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80dae1:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80dae7:	85 c0                	test   %eax,%eax
  80dae9:	74 0c                	je     80daf7 <sys_mbox_new+0x68>
  80daeb:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80daf1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80daf7:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80dafd:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80db03:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80db05:	83 3b 00             	cmpl   $0x0,(%ebx)
  80db08:	75 24                	jne    80db2e <sys_mbox_new+0x9f>
  80db0a:	c7 44 24 0c f4 40 81 	movl   $0x8140f4,0xc(%esp)
  80db11:	00 
  80db12:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80db19:	00 
  80db1a:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80db21:	00 
  80db22:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80db29:	e8 4e 2e ff ff       	call   80097c <_panic>
    mbe->freed = 0;
  80db2e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80db34:	89 de                	mov    %ebx,%esi
  80db36:	81 ee 20 93 b3 00    	sub    $0xb39320,%esi
  80db3c:	c1 fe 02             	sar    $0x2,%esi
  80db3f:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80db45:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80db4c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80db53:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80db5a:	e8 a6 fe ff ff       	call   80da05 <sys_sem_new>
  80db5f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80db65:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80db6c:	e8 94 fe ff ff       	call   80da05 <sys_sem_new>
  80db71:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80db77:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80db7e:	74 05                	je     80db85 <sys_mbox_new+0xf6>
  80db80:	83 f8 ff             	cmp    $0xffffffff,%eax
  80db83:	75 19                	jne    80db9e <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80db85:	89 34 24             	mov    %esi,(%esp)
  80db88:	e8 4a fa ff ff       	call   80d5d7 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80db8d:	c7 04 24 fc 41 81 00 	movl   $0x8141fc,(%esp)
  80db94:	e8 a8 2e ff ff       	call   800a41 <cprintf>
  80db99:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80db9e:	89 f0                	mov    %esi,%eax
  80dba0:	83 c4 10             	add    $0x10,%esp
  80dba3:	5b                   	pop    %ebx
  80dba4:	5e                   	pop    %esi
  80dba5:	5d                   	pop    %ebp
  80dba6:	c3                   	ret    

0080dba7 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80dba7:	55                   	push   %ebp
  80dba8:	89 e5                	mov    %esp,%ebp
  80dbaa:	83 ec 18             	sub    $0x18,%esp
  80dbad:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80dbb0:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80dbb3:	83 3c 95 00 7f b3 00 	cmpl   $0x0,0xb37f00(,%edx,4)
  80dbba:	00 
  80dbbb:	74 24                	je     80dbe1 <sys_sem_signal+0x3a>
  80dbbd:	c7 44 24 0c 6f 40 81 	movl   $0x81406f,0xc(%esp)
  80dbc4:	00 
  80dbc5:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80dbcc:	00 
  80dbcd:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80dbd4:	00 
  80dbd5:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80dbdc:	e8 9b 2d ff ff       	call   80097c <_panic>
    sems[sem].counter++;
  80dbe1:	ba 00 7f b3 00       	mov    $0xb37f00,%edx
  80dbe6:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80dbe9:	c1 e1 02             	shl    $0x2,%ecx
  80dbec:	66 83 44 0a 08 01    	addw   $0x1,0x8(%edx,%ecx,1)
    if (sems[sem].waiters) {
  80dbf2:	66 83 7c 11 0a 00    	cmpw   $0x0,0xa(%ecx,%edx,1)
  80dbf8:	74 18                	je     80dc12 <sys_sem_signal+0x6b>
	sems[sem].waiters = 0;
  80dbfa:	89 c8                	mov    %ecx,%eax
  80dbfc:	66 c7 81 0a 7f b3 00 	movw   $0x0,0xb37f0a(%ecx)
  80dc03:	00 00 
	thread_wakeup(&sems[sem].v);
  80dc05:	05 08 7f b3 00       	add    $0xb37f08,%eax
  80dc0a:	89 04 24             	mov    %eax,(%esp)
  80dc0d:	e8 6d 02 00 00       	call   80de7f <thread_wakeup>
    }
}
  80dc12:	c9                   	leave  
  80dc13:	c3                   	ret    

0080dc14 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80dc14:	55                   	push   %ebp
  80dc15:	89 e5                	mov    %esp,%ebp
  80dc17:	83 ec 28             	sub    $0x28,%esp
  80dc1a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dc1d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dc20:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dc23:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dc26:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80dc29:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dc2f:	83 b8 20 93 b3 00 00 	cmpl   $0x0,0xb39320(%eax)
  80dc36:	74 24                	je     80dc5c <sys_arch_mbox_fetch+0x48>
  80dc38:	c7 44 24 0c 9d 40 81 	movl   $0x81409d,0xc(%esp)
  80dc3f:	00 
  80dc40:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80dc47:	00 
  80dc48:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80dc4f:	00 
  80dc50:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80dc57:	e8 20 2d ff ff       	call   80097c <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80dc5c:	8b 45 10             	mov    0x10(%ebp),%eax
  80dc5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc63:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dc69:	8b 80 ac 93 b3 00    	mov    0xb393ac(%eax),%eax
  80dc6f:	89 04 24             	mov    %eax,(%esp)
  80dc72:	e8 3f fc ff ff       	call   80d8b6 <sys_arch_sem_wait>
  80dc77:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80dc79:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dc7c:	0f 84 85 00 00 00    	je     80dd07 <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80dc82:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dc88:	8b 80 24 93 b3 00    	mov    0xb39324(%eax),%eax
    if (slot == -1)
  80dc8e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dc91:	75 1c                	jne    80dcaf <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80dc93:	c7 44 24 08 28 42 81 	movl   $0x814228,0x8(%esp)
  80dc9a:	00 
  80dc9b:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80dca2:	00 
  80dca3:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80dcaa:	e8 cd 2c ff ff       	call   80097c <_panic>
    if (msg)
  80dcaf:	85 ff                	test   %edi,%edi
  80dcb1:	74 0e                	je     80dcc1 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80dcb3:	6b d3 27             	imul   $0x27,%ebx,%edx
  80dcb6:	01 c2                	add    %eax,%edx
  80dcb8:	8b 14 95 2c 93 b3 00 	mov    0xb3932c(,%edx,4),%edx
  80dcbf:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80dcc1:	8d 48 01             	lea    0x1(%eax),%ecx
  80dcc4:	89 ca                	mov    %ecx,%edx
  80dcc6:	c1 fa 1f             	sar    $0x1f,%edx
  80dcc9:	c1 ea 1b             	shr    $0x1b,%edx
  80dccc:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80dccf:	83 e0 1f             	and    $0x1f,%eax
  80dcd2:	29 d0                	sub    %edx,%eax
  80dcd4:	ba 20 93 b3 00       	mov    $0xb39320,%edx
  80dcd9:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80dcdf:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80dce3:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80dce7:	75 0a                	jne    80dcf3 <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80dce9:	c7 81 24 93 b3 00 ff 	movl   $0xffffffff,0xb39324(%ecx)
  80dcf0:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80dcf3:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80dcf9:	8b 83 b0 93 b3 00    	mov    0xb393b0(%ebx),%eax
  80dcff:	89 04 24             	mov    %eax,(%esp)
  80dd02:	e8 a0 fe ff ff       	call   80dba7 <sys_sem_signal>
    return waited;
}
  80dd07:	89 f0                	mov    %esi,%eax
  80dd09:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80dd0c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80dd0f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80dd12:	89 ec                	mov    %ebp,%esp
  80dd14:	5d                   	pop    %ebp
  80dd15:	c3                   	ret    

0080dd16 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80dd16:	55                   	push   %ebp
  80dd17:	89 e5                	mov    %esp,%ebp
  80dd19:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80dd1c:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80dd23:	ff 
  80dd24:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dd27:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd2b:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd2e:	89 04 24             	mov    %eax,(%esp)
  80dd31:	e8 de fe ff ff       	call   80dc14 <sys_arch_mbox_fetch>
}
  80dd36:	c9                   	leave  
  80dd37:	c3                   	ret    

0080dd38 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80dd38:	55                   	push   %ebp
  80dd39:	89 e5                	mov    %esp,%ebp
  80dd3b:	83 ec 28             	sub    $0x28,%esp
  80dd3e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dd41:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dd44:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dd47:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80dd4a:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80dd50:	83 b8 20 93 b3 00 00 	cmpl   $0x0,0xb39320(%eax)
  80dd57:	74 24                	je     80dd7d <sys_mbox_trypost+0x45>
  80dd59:	c7 44 24 0c 9d 40 81 	movl   $0x81409d,0xc(%esp)
  80dd60:	00 
  80dd61:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80dd68:	00 
  80dd69:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80dd70:	00 
  80dd71:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80dd78:	e8 ff 2b ff ff       	call   80097c <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80dd7d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dd84:	00 
  80dd85:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80dd8b:	8b 83 b0 93 b3 00    	mov    0xb393b0(%ebx),%eax
  80dd91:	89 04 24             	mov    %eax,(%esp)
  80dd94:	e8 1d fb ff ff       	call   80d8b6 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80dd99:	b9 20 93 b3 00       	mov    $0xb39320,%ecx
  80dd9e:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80dda2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dda7:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80ddab:	74 4c                	je     80ddf9 <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80ddad:	89 c8                	mov    %ecx,%eax
  80ddaf:	89 d9                	mov    %ebx,%ecx
  80ddb1:	8d 7a 01             	lea    0x1(%edx),%edi
  80ddb4:	89 fb                	mov    %edi,%ebx
  80ddb6:	c1 fb 1f             	sar    $0x1f,%ebx
  80ddb9:	c1 eb 1b             	shr    $0x1b,%ebx
  80ddbc:	01 df                	add    %ebx,%edi
  80ddbe:	83 e7 1f             	and    $0x1f,%edi
  80ddc1:	29 df                	sub    %ebx,%edi
  80ddc3:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80ddc7:	6b de 27             	imul   $0x27,%esi,%ebx
  80ddca:	01 d3                	add    %edx,%ebx
  80ddcc:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80ddcf:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80ddd3:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80ddd8:	75 06                	jne    80dde0 <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80ddda:	89 91 24 93 b3 00    	mov    %edx,0xb39324(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80dde0:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80dde6:	8b 86 ac 93 b3 00    	mov    0xb393ac(%esi),%eax
  80ddec:	89 04 24             	mov    %eax,(%esp)
  80ddef:	e8 b3 fd ff ff       	call   80dba7 <sys_sem_signal>
  80ddf4:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80ddf9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ddfc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ddff:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80de02:	89 ec                	mov    %ebp,%esp
  80de04:	5d                   	pop    %ebp
  80de05:	c3                   	ret    

0080de06 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80de06:	55                   	push   %ebp
  80de07:	89 e5                	mov    %esp,%ebp
  80de09:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80de0c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80de0f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de13:	8b 45 08             	mov    0x8(%ebp),%eax
  80de16:	89 04 24             	mov    %eax,(%esp)
  80de19:	e8 1a ff ff ff       	call   80dd38 <sys_mbox_trypost>
  80de1e:	84 c0                	test   %al,%al
  80de20:	74 24                	je     80de46 <sys_mbox_post+0x40>
  80de22:	c7 44 24 0c 50 42 81 	movl   $0x814250,0xc(%esp)
  80de29:	00 
  80de2a:	c7 44 24 08 cb 2b 81 	movl   $0x812bcb,0x8(%esp)
  80de31:	00 
  80de32:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80de39:	00 
  80de3a:	c7 04 24 80 40 81 00 	movl   $0x814080,(%esp)
  80de41:	e8 36 2b ff ff       	call   80097c <_panic>
}
  80de46:	c9                   	leave  
  80de47:	c3                   	ret    
	...

0080de50 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80de50:	55                   	push   %ebp
  80de51:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80de53:	c7 05 4c e5 b3 00 00 	movl   $0x0,0xb3e54c
  80de5a:	00 00 00 
    tq->tq_last = 0;
  80de5d:	c7 05 50 e5 b3 00 00 	movl   $0x0,0xb3e550
  80de64:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80de67:	c7 05 44 e5 b3 00 00 	movl   $0x0,0xb3e544
  80de6e:	00 00 00 
}
  80de71:	5d                   	pop    %ebp
  80de72:	c3                   	ret    

0080de73 <thread_id>:

uint32_t
thread_id(void) {
  80de73:	55                   	push   %ebp
  80de74:	89 e5                	mov    %esp,%ebp
  80de76:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80de7b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80de7d:	5d                   	pop    %ebp
  80de7e:	c3                   	ret    

0080de7f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80de7f:	55                   	push   %ebp
  80de80:	89 e5                	mov    %esp,%ebp
  80de82:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80de85:	a1 4c e5 b3 00       	mov    0xb3e54c,%eax
    while (tc) {
  80de8a:	85 c0                	test   %eax,%eax
  80de8c:	74 10                	je     80de9e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80de8e:	39 50 48             	cmp    %edx,0x48(%eax)
  80de91:	75 04                	jne    80de97 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80de93:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80de97:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80de9a:	85 c0                	test   %eax,%eax
  80de9c:	75 f0                	jne    80de8e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80de9e:	5d                   	pop    %ebp
  80de9f:	90                   	nop
  80dea0:	c3                   	ret    

0080dea1 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80dea1:	55                   	push   %ebp
  80dea2:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80dea4:	8b 15 4c e5 b3 00    	mov    0xb3e54c,%edx
    int n = 0;
    while (tc) {
  80deaa:	b8 00 00 00 00       	mov    $0x0,%eax
  80deaf:	85 d2                	test   %edx,%edx
  80deb1:	74 11                	je     80dec4 <thread_wakeups_pending+0x23>
	if (tc->tc_wakeup)
  80deb3:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80deb7:	80 f9 01             	cmp    $0x1,%cl
  80deba:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80debd:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80dec0:	85 d2                	test   %edx,%edx
  80dec2:	75 ef                	jne    80deb3 <thread_wakeups_pending+0x12>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80dec4:	5d                   	pop    %ebp
  80dec5:	c3                   	ret    

0080dec6 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80dec6:	55                   	push   %ebp
  80dec7:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80dec9:	8b 15 48 e5 b3 00    	mov    0xb3e548,%edx
  80decf:	8b 4a 60             	mov    0x60(%edx),%ecx
  80ded2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ded7:	83 f9 03             	cmp    $0x3,%ecx
  80deda:	7f 12                	jg     80deee <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80dedc:	8b 45 08             	mov    0x8(%ebp),%eax
  80dedf:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80dee3:	83 c1 01             	add    $0x1,%ecx
  80dee6:	89 4a 60             	mov    %ecx,0x60(%edx)
  80dee9:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80deee:	5d                   	pop    %ebp
  80deef:	c3                   	ret    

0080def0 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80def0:	55                   	push   %ebp
  80def1:	89 e5                	mov    %esp,%ebp
  80def3:	53                   	push   %ebx
  80def4:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80def7:	8b 1d 4c e5 b3 00    	mov    0xb3e54c,%ebx
  80defd:	85 db                	test   %ebx,%ebx
  80deff:	74 69                	je     80df6a <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80df01:	8b 43 64             	mov    0x64(%ebx),%eax
  80df04:	a3 4c e5 b3 00       	mov    %eax,0xb3e54c
    tc->tc_queue_link = 0;
  80df09:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80df10:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80df15:	85 c0                	test   %eax,%eax
  80df17:	74 3e                	je     80df57 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80df19:	83 c0 30             	add    $0x30,%eax
  80df1c:	89 04 24             	mov    %eax,(%esp)
  80df1f:	e8 cc 02 00 00       	call   80e1f0 <jos_setjmp>
  80df24:	85 c0                	test   %eax,%eax
  80df26:	75 42                	jne    80df6a <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80df28:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80df2d:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80df34:	83 3d 4c e5 b3 00 00 	cmpl   $0x0,0xb3e54c
  80df3b:	75 0c                	jne    80df49 <thread_yield+0x59>
	tq->tq_first = tc;
  80df3d:	a3 4c e5 b3 00       	mov    %eax,0xb3e54c
	tq->tq_last = tc;
  80df42:	a3 50 e5 b3 00       	mov    %eax,0xb3e550
  80df47:	eb 0e                	jmp    80df57 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80df49:	8b 15 50 e5 b3 00    	mov    0xb3e550,%edx
  80df4f:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80df52:	a3 50 e5 b3 00       	mov    %eax,0xb3e550
    }

    cur_tc = next_tc;
  80df57:	89 1d 48 e5 b3 00    	mov    %ebx,0xb3e548
    jos_longjmp(&cur_tc->tc_jb, 1);
  80df5d:	8d 43 30             	lea    0x30(%ebx),%eax
  80df60:	ba 01 00 00 00       	mov    $0x1,%edx
  80df65:	e8 b6 02 00 00       	call   80e220 <jos_longjmp>
}
  80df6a:	83 c4 14             	add    $0x14,%esp
  80df6d:	5b                   	pop    %ebx
  80df6e:	5d                   	pop    %ebp
  80df6f:	c3                   	ret    

0080df70 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80df70:	55                   	push   %ebp
  80df71:	89 e5                	mov    %esp,%ebp
  80df73:	56                   	push   %esi
  80df74:	53                   	push   %ebx
  80df75:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80df78:	8b 1d 54 e5 b3 00    	mov    0xb3e554,%ebx
  80df7e:	85 db                	test   %ebx,%ebx
  80df80:	0f 84 88 00 00 00    	je     80e00e <thread_halt+0x9e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80df86:	8b 43 64             	mov    0x64(%ebx),%eax
  80df89:	a3 54 e5 b3 00       	mov    %eax,0xb3e554
    tc->tc_queue_link = 0;
  80df8e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80df95:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80df99:	7e 16                	jle    80dfb1 <thread_halt+0x41>
  80df9b:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80dfa0:	8b 03                	mov    (%ebx),%eax
  80dfa2:	89 04 24             	mov    %eax,(%esp)
  80dfa5:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80dfa9:	83 c6 01             	add    $0x1,%esi
  80dfac:	3b 73 60             	cmp    0x60(%ebx),%esi
  80dfaf:	7c ef                	jl     80dfa0 <thread_halt+0x30>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80dfb1:	8b 43 04             	mov    0x4(%ebx),%eax
  80dfb4:	89 04 24             	mov    %eax,(%esp)
  80dfb7:	e8 54 4c ff ff       	call   802c10 <free>
    free(tc);
  80dfbc:	89 1c 24             	mov    %ebx,(%esp)
  80dfbf:	e8 4c 4c ff ff       	call   802c10 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80dfc4:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dfc9:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80dfd0:	83 3d 54 e5 b3 00 00 	cmpl   $0x0,0xb3e554
  80dfd7:	75 0c                	jne    80dfe5 <thread_halt+0x75>
	tq->tq_first = tc;
  80dfd9:	a3 54 e5 b3 00       	mov    %eax,0xb3e554
	tq->tq_last = tc;
  80dfde:	a3 58 e5 b3 00       	mov    %eax,0xb3e558
  80dfe3:	eb 0e                	jmp    80dff3 <thread_halt+0x83>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dfe5:	8b 15 58 e5 b3 00    	mov    0xb3e558,%edx
  80dfeb:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80dfee:	a3 58 e5 b3 00       	mov    %eax,0xb3e558
    cur_tc = NULL;
  80dff3:	c7 05 48 e5 b3 00 00 	movl   $0x0,0xb3e548
  80dffa:	00 00 00 
    thread_yield();
  80dffd:	e8 ee fe ff ff       	call   80def0 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80e002:	e8 59 29 ff ff       	call   800960 <exit>
}
  80e007:	83 c4 10             	add    $0x10,%esp
  80e00a:	5b                   	pop    %ebx
  80e00b:	5e                   	pop    %esi
  80e00c:	5d                   	pop    %ebp
  80e00d:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80e00e:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80e013:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80e01a:	eb bd                	jmp    80dfd9 <thread_halt+0x69>

0080e01c <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80e01c:	55                   	push   %ebp
  80e01d:	89 e5                	mov    %esp,%ebp
  80e01f:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80e022:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80e027:	8b 50 2c             	mov    0x2c(%eax),%edx
  80e02a:	89 14 24             	mov    %edx,(%esp)
  80e02d:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80e030:	e8 3b ff ff ff       	call   80df70 <thread_halt>
}
  80e035:	c9                   	leave  
  80e036:	c3                   	ret    

0080e037 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80e037:	55                   	push   %ebp
  80e038:	89 e5                	mov    %esp,%ebp
  80e03a:	57                   	push   %edi
  80e03b:	56                   	push   %esi
  80e03c:	53                   	push   %ebx
  80e03d:	83 ec 1c             	sub    $0x1c,%esp
  80e040:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80e043:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80e04a:	e8 94 4c ff ff       	call   802ce3 <malloc>
  80e04f:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80e051:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e056:	85 db                	test   %ebx,%ebx
  80e058:	0f 84 19 01 00 00    	je     80e177 <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80e05e:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80e065:	00 
  80e066:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e06d:	00 
  80e06e:	89 1c 24             	mov    %ebx,(%esp)
  80e071:	e8 00 32 ff ff       	call   801276 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80e076:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80e07d:	00 
  80e07e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e081:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e085:	8d 43 08             	lea    0x8(%ebx),%eax
  80e088:	89 04 24             	mov    %eax,(%esp)
  80e08b:	e8 aa 30 ff ff       	call   80113a <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80e090:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80e094:	a1 44 e5 b3 00       	mov    0xb3e544,%eax
  80e099:	8d 50 01             	lea    0x1(%eax),%edx
  80e09c:	89 15 44 e5 b3 00    	mov    %edx,0xb3e544
    if (max_tid == (uint32_t)~0)
  80e0a2:	83 fa ff             	cmp    $0xffffffff,%edx
  80e0a5:	75 1c                	jne    80e0c3 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80e0a7:	c7 44 24 08 76 42 81 	movl   $0x814276,0x8(%esp)
  80e0ae:	00 
  80e0af:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e0b6:	00 
  80e0b7:	c7 04 24 94 42 81 00 	movl   $0x814294,(%esp)
  80e0be:	e8 b9 28 ff ff       	call   80097c <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80e0c3:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80e0c5:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80e0cc:	e8 12 4c ff ff       	call   802ce3 <malloc>
  80e0d1:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80e0d4:	85 c0                	test   %eax,%eax
  80e0d6:	75 12                	jne    80e0ea <thread_create+0xb3>
	free(tc);
  80e0d8:	89 1c 24             	mov    %ebx,(%esp)
  80e0db:	e8 30 4b ff ff       	call   802c10 <free>
  80e0e0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80e0e5:	e9 8d 00 00 00       	jmp    80e177 <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80e0ea:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80e0f0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e0f7:	00 
  80e0f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e0ff:	00 
  80e100:	89 34 24             	mov    %esi,(%esp)
  80e103:	e8 6e 31 ff ff       	call   801276 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80e108:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80e10f:	00 
  80e110:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e117:	00 
  80e118:	8d 43 30             	lea    0x30(%ebx),%eax
  80e11b:	89 04 24             	mov    %eax,(%esp)
  80e11e:	e8 53 31 ff ff       	call   801276 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80e123:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80e126:	c7 43 30 1c e0 80 00 	movl   $0x80e01c,0x30(%ebx)
    tc->tc_entry = entry;
  80e12d:	8b 45 10             	mov    0x10(%ebp),%eax
  80e130:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80e133:	8b 45 14             	mov    0x14(%ebp),%eax
  80e136:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80e139:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80e140:	83 3d 4c e5 b3 00 00 	cmpl   $0x0,0xb3e54c
  80e147:	75 0e                	jne    80e157 <thread_create+0x120>
	tq->tq_first = tc;
  80e149:	89 1d 4c e5 b3 00    	mov    %ebx,0xb3e54c
	tq->tq_last = tc;
  80e14f:	89 1d 50 e5 b3 00    	mov    %ebx,0xb3e550
  80e155:	eb 0e                	jmp    80e165 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80e157:	a1 50 e5 b3 00       	mov    0xb3e550,%eax
  80e15c:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80e15f:	89 1d 50 e5 b3 00    	mov    %ebx,0xb3e550

    threadq_push(&thread_queue, tc);

    if (tid)
  80e165:	b8 00 00 00 00       	mov    $0x0,%eax
  80e16a:	85 ff                	test   %edi,%edi
  80e16c:	74 09                	je     80e177 <thread_create+0x140>
	*tid = tc->tc_tid;
  80e16e:	8b 03                	mov    (%ebx),%eax
  80e170:	89 07                	mov    %eax,(%edi)
  80e172:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80e177:	83 c4 1c             	add    $0x1c,%esp
  80e17a:	5b                   	pop    %ebx
  80e17b:	5e                   	pop    %esi
  80e17c:	5f                   	pop    %edi
  80e17d:	5d                   	pop    %ebp
  80e17e:	c3                   	ret    

0080e17f <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80e17f:	55                   	push   %ebp
  80e180:	89 e5                	mov    %esp,%ebp
  80e182:	57                   	push   %edi
  80e183:	56                   	push   %esi
  80e184:	53                   	push   %ebx
  80e185:	83 ec 0c             	sub    $0xc,%esp
  80e188:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e18b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80e18e:	e8 44 34 ff ff       	call   8015d7 <sys_time_msec>
  80e193:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80e195:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80e19a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e19d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80e1a1:	39 fe                	cmp    %edi,%esi
  80e1a3:	72 06                	jb     80e1ab <thread_wait+0x2c>
  80e1a5:	eb 2d                	jmp    80e1d4 <thread_wait+0x55>
	if (p < s)
  80e1a7:	39 c6                	cmp    %eax,%esi
  80e1a9:	77 29                	ja     80e1d4 <thread_wait+0x55>
	    break;
	if (addr && *addr != val)
  80e1ab:	85 db                	test   %ebx,%ebx
  80e1ad:	8d 76 00             	lea    0x0(%esi),%esi
  80e1b0:	74 07                	je     80e1b9 <thread_wait+0x3a>
  80e1b2:	8b 03                	mov    (%ebx),%eax
  80e1b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80e1b7:	75 1b                	jne    80e1d4 <thread_wait+0x55>
	    break;
	if (cur_tc->tc_wakeup)
  80e1b9:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80e1be:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80e1c2:	84 c0                	test   %al,%al
  80e1c4:	75 0e                	jne    80e1d4 <thread_wait+0x55>
	    break;

	thread_yield();
  80e1c6:	e8 25 fd ff ff       	call   80def0 <thread_yield>
	p = sys_time_msec();
  80e1cb:	e8 07 34 ff ff       	call   8015d7 <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80e1d0:	39 c7                	cmp    %eax,%edi
  80e1d2:	77 d3                	ja     80e1a7 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80e1d4:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  80e1d9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e1e0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80e1e4:	83 c4 0c             	add    $0xc,%esp
  80e1e7:	5b                   	pop    %ebx
  80e1e8:	5e                   	pop    %esi
  80e1e9:	5f                   	pop    %edi
  80e1ea:	5d                   	pop    %ebp
  80e1eb:	c3                   	ret    
  80e1ec:	00 00                	add    %al,(%eax)
	...

0080e1f0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80e1f0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80e1f4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80e1f7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80e1f9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80e1fd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80e200:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80e203:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80e206:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80e209:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80e20c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80e211:	c3                   	ret    
  80e212:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80e219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080e220 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80e220:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80e222:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80e225:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80e228:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80e22b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80e22e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80e231:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80e233:	ff e1                	jmp    *%ecx
  80e235:	00 00                	add    %al,(%eax)
	...

0080e238 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80e238:	55                   	push   %ebp
  80e239:	89 e5                	mov    %esp,%ebp
  80e23b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e23e:	8b 04 85 a0 80 81 00 	mov    0x8180a0(,%eax,4),%eax
	return sys_errlist[err];
}
  80e245:	5d                   	pop    %ebp
  80e246:	c3                   	ret    

0080e247 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80e247:	55                   	push   %ebp
  80e248:	89 e5                	mov    %esp,%ebp
  80e24a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80e24d:	a1 a0 e5 b3 00       	mov    0xb3e5a0,%eax
  80e252:	89 04 24             	mov    %eax,(%esp)
  80e255:	e8 de ff ff ff       	call   80e238 <e2s>
  80e25a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e25e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e261:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e265:	c7 04 24 af 42 81 00 	movl   $0x8142af,(%esp)
  80e26c:	e8 d0 27 ff ff       	call   800a41 <cprintf>
}
  80e271:	c9                   	leave  
  80e272:	c3                   	ret    
	...

0080e280 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80e280:	55                   	push   %ebp
  80e281:	89 e5                	mov    %esp,%ebp
  80e283:	83 ec 38             	sub    $0x38,%esp
  80e286:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80e289:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80e28c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80e28f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80e292:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80e299:	e8 a2 8e ff ff       	call   807140 <mem_malloc>
  80e29e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80e2a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e2a5:	85 f6                	test   %esi,%esi
  80e2a7:	0f 84 8a 00 00 00    	je     80e337 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80e2ad:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80e2b0:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80e2b3:	c7 43 14 59 e4 80 00 	movl   $0x80e459,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80e2ba:	c7 43 18 44 e3 80 00 	movl   $0x80e344,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80e2c1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80e2c8:	00 
  80e2c9:	c7 44 24 04 fe 2b 81 	movl   $0x812bfe,0x4(%esp)
  80e2d0:	00 
  80e2d1:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80e2d4:	89 04 24             	mov    %eax,(%esp)
  80e2d7:	e8 75 30 ff ff       	call   801351 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80e2dc:	8d 43 25             	lea    0x25(%ebx),%eax
  80e2df:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80e2e1:	8b 07                	mov    (%edi),%eax
  80e2e3:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80e2e6:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80e2ea:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80e2f0:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80e2f4:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80e2f8:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80e2fc:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80e300:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80e304:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80e308:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80e30c:	c7 04 24 c9 24 81 00 	movl   $0x8124c9,(%esp)
  80e313:	e8 e0 cb ff ff       	call   80aef8 <inet_addr>
  80e318:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80e31b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e322:	00 
  80e323:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e326:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e32a:	89 1c 24             	mov    %ebx,(%esp)
  80e32d:	e8 65 e9 ff ff       	call   80cc97 <etharp_query>
  80e332:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80e337:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80e33a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80e33d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80e340:	89 ec                	mov    %ebp,%esp
  80e342:	5d                   	pop    %ebp
  80e343:	c3                   	ret    

0080e344 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80e344:	55                   	push   %ebp
  80e345:	89 e5                	mov    %esp,%ebp
  80e347:	57                   	push   %edi
  80e348:	56                   	push   %esi
  80e349:	53                   	push   %ebx
  80e34a:	83 ec 2c             	sub    $0x2c,%esp
  80e34d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80e350:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80e357:	00 
  80e358:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e35f:	10 
  80e360:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e367:	e8 0a 35 ff ff       	call   801876 <sys_page_alloc>
    if (r < 0)
  80e36c:	85 c0                	test   %eax,%eax
  80e36e:	79 1c                	jns    80e38c <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80e370:	c7 44 24 08 a8 47 81 	movl   $0x8147a8,0x8(%esp)
  80e377:	00 
  80e378:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80e37f:	00 
  80e380:	c7 04 24 91 47 81 00 	movl   $0x814791,(%esp)
  80e387:	e8 f0 25 ff ff       	call   80097c <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80e38c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e38f:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e392:	be 00 00 00 00       	mov    $0x0,%esi
  80e397:	85 db                	test   %ebx,%ebx
  80e399:	74 74                	je     80e40f <low_level_output+0xcb>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80e39b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e39f:	0f b7 d0             	movzwl %ax,%edx
  80e3a2:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80e3a8:	7e 38                	jle    80e3e2 <low_level_output+0x9e>
  80e3aa:	eb 12                	jmp    80e3be <low_level_output+0x7a>
  80e3ac:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3b0:	0f b7 d0             	movzwl %ax,%edx
  80e3b3:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80e3b6:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80e3bc:	7e 29                	jle    80e3e7 <low_level_output+0xa3>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80e3be:	89 74 24 10          	mov    %esi,0x10(%esp)
  80e3c2:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e3c6:	c7 44 24 08 d0 47 81 	movl   $0x8147d0,0x8(%esp)
  80e3cd:	00 
  80e3ce:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80e3d5:	00 
  80e3d6:	c7 04 24 91 47 81 00 	movl   $0x814791,(%esp)
  80e3dd:	e8 9a 25 ff ff       	call   80097c <_panic>
  80e3e2:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80e3e7:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80e3ed:	0f b7 c0             	movzwl %ax,%eax
  80e3f0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e3f4:	8b 43 04             	mov    0x4(%ebx),%eax
  80e3f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e3fb:	89 14 24             	mov    %edx,(%esp)
  80e3fe:	e8 4e 2f ff ff       	call   801351 <memcpy>
	txsize += q->len;
  80e403:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e407:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e409:	8b 1b                	mov    (%ebx),%ebx
  80e40b:	85 db                	test   %ebx,%ebx
  80e40d:	75 9d                	jne    80e3ac <low_level_output+0x68>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80e40f:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80e415:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80e41c:	00 
  80e41d:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80e424:	10 
  80e425:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80e42c:	00 
  80e42d:	8b 47 04             	mov    0x4(%edi),%eax
  80e430:	89 04 24             	mov    %eax,(%esp)
  80e433:	e8 f8 38 ff ff       	call   801d30 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80e438:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e43f:	10 
  80e440:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e447:	e8 6e 33 ff ff       	call   8017ba <sys_page_unmap>

    return ERR_OK;
}
  80e44c:	b8 00 00 00 00       	mov    $0x0,%eax
  80e451:	83 c4 2c             	add    $0x2c,%esp
  80e454:	5b                   	pop    %ebx
  80e455:	5e                   	pop    %esi
  80e456:	5f                   	pop    %edi
  80e457:	5d                   	pop    %ebp
  80e458:	c3                   	ret    

0080e459 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80e459:	55                   	push   %ebp
  80e45a:	89 e5                	mov    %esp,%ebp
  80e45c:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80e45f:	8b 45 10             	mov    0x10(%ebp),%eax
  80e462:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e466:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e469:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e46d:	8b 45 08             	mov    0x8(%ebp),%eax
  80e470:	89 04 24             	mov    %eax,(%esp)
  80e473:	e8 37 ea ff ff       	call   80ceaf <etharp_output>
}
  80e478:	c9                   	leave  
  80e479:	c3                   	ret    

0080e47a <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80e47a:	55                   	push   %ebp
  80e47b:	89 e5                	mov    %esp,%ebp
  80e47d:	57                   	push   %edi
  80e47e:	56                   	push   %esi
  80e47f:	53                   	push   %ebx
  80e480:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80e483:	8b 45 08             	mov    0x8(%ebp),%eax
  80e486:	8b 40 1c             	mov    0x1c(%eax),%eax
  80e489:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80e48c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80e48f:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80e492:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80e499:	00 
  80e49a:	0f b7 c6             	movzwl %si,%eax
  80e49d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4a1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80e4a8:	e8 e6 9c ff ff       	call   808193 <pbuf_alloc>
  80e4ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80e4b0:	85 c0                	test   %eax,%eax
  80e4b2:	0f 84 ca 00 00 00    	je     80e582 <jif_input+0x108>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80e4b8:	83 c3 04             	add    $0x4,%ebx
  80e4bb:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e4be:	89 c3                	mov    %eax,%ebx
  80e4c0:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80e4c5:	0f bf f6             	movswl %si,%esi
  80e4c8:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80e4cb:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e4cf:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80e4d2:	29 fe                	sub    %edi,%esi
  80e4d4:	39 c6                	cmp    %eax,%esi
  80e4d6:	7e 02                	jle    80e4da <jif_input+0x60>
  80e4d8:	89 c6                	mov    %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80e4da:	89 74 24 08          	mov    %esi,0x8(%esp)
  80e4de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e4e1:	01 f8                	add    %edi,%eax
  80e4e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4e7:	8b 43 04             	mov    0x4(%ebx),%eax
  80e4ea:	89 04 24             	mov    %eax,(%esp)
  80e4ed:	e8 5f 2e ff ff       	call   801351 <memcpy>
	copied += bytes;
  80e4f2:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e4f4:	8b 1b                	mov    (%ebx),%ebx
  80e4f6:	85 db                	test   %ebx,%ebx
  80e4f8:	75 d1                	jne    80e4cb <jif_input+0x51>
  80e4fa:	eb 61                	jmp    80e55d <jif_input+0xe3>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80e4fc:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4ff:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e503:	8b 45 08             	mov    0x8(%ebp),%eax
  80e506:	89 04 24             	mov    %eax,(%esp)
  80e509:	e8 cb ec ff ff       	call   80d1d9 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80e50e:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80e515:	ff 
  80e516:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e519:	89 14 24             	mov    %edx,(%esp)
  80e51c:	e8 42 96 ff ff       	call   807b63 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e521:	8b 45 08             	mov    0x8(%ebp),%eax
  80e524:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e528:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e52b:	89 14 24             	mov    %edx,(%esp)
  80e52e:	ff 50 10             	call   *0x10(%eax)
	break;
  80e531:	eb 4f                	jmp    80e582 <jif_input+0x108>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e533:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e536:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e53a:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e53d:	8b 02                	mov    (%edx),%eax
  80e53f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e543:	8b 45 08             	mov    0x8(%ebp),%eax
  80e546:	89 04 24             	mov    %eax,(%esp)
  80e549:	e8 d9 ec ff ff       	call   80d227 <etharp_arp_input>
	break;
  80e54e:	eb 32                	jmp    80e582 <jif_input+0x108>

    default:
	pbuf_free(p);
  80e550:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e553:	89 14 24             	mov    %edx,(%esp)
  80e556:	e8 7d 99 ff ff       	call   807ed8 <pbuf_free>
  80e55b:	eb 25                	jmp    80e582 <jif_input+0x108>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e55d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e560:	8b 42 04             	mov    0x4(%edx),%eax
  80e563:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e567:	89 04 24             	mov    %eax,(%esp)
  80e56a:	e8 65 c7 ff ff       	call   80acd4 <htons>
  80e56f:	66 3d 00 08          	cmp    $0x800,%ax
  80e573:	74 87                	je     80e4fc <jif_input+0x82>
  80e575:	66 3d 06 08          	cmp    $0x806,%ax
  80e579:	75 d5                	jne    80e550 <jif_input+0xd6>
  80e57b:	90                   	nop
  80e57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80e580:	eb b1                	jmp    80e533 <jif_input+0xb9>
	break;

    default:
	pbuf_free(p);
    }
}
  80e582:	83 c4 2c             	add    $0x2c,%esp
  80e585:	5b                   	pop    %ebx
  80e586:	5e                   	pop    %esi
  80e587:	5f                   	pop    %edi
  80e588:	5d                   	pop    %ebp
  80e589:	c3                   	ret    
  80e58a:	00 00                	add    %al,(%eax)
  80e58c:	00 00                	add    %al,(%eax)
	...

0080e590 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e590:	55                   	push   %ebp
  80e591:	89 e5                	mov    %esp,%ebp
  80e593:	83 ec 18             	sub    $0x18,%esp
  80e596:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e599:	85 c0                	test   %eax,%eax
  80e59b:	75 1c                	jne    80e5b9 <netconn_type+0x29>
  80e59d:	c7 44 24 08 f9 47 81 	movl   $0x8147f9,0x8(%esp)
  80e5a4:	00 
  80e5a5:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e5ac:	00 
  80e5ad:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e5b4:	e8 c3 23 ff ff       	call   80097c <_panic>
  80e5b9:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e5bb:	c9                   	leave  
  80e5bc:	c3                   	ret    

0080e5bd <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e5bd:	55                   	push   %ebp
  80e5be:	89 e5                	mov    %esp,%ebp
  80e5c0:	53                   	push   %ebx
  80e5c1:	83 ec 34             	sub    $0x34,%esp
  80e5c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e5c7:	85 db                	test   %ebx,%ebx
  80e5c9:	75 1c                	jne    80e5e7 <netconn_close+0x2a>
  80e5cb:	c7 44 24 08 2b 48 81 	movl   $0x81482b,0x8(%esp)
  80e5d2:	00 
  80e5d3:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e5da:	00 
  80e5db:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e5e2:	e8 95 23 ff ff       	call   80097c <_panic>

  msg.function = do_close;
  80e5e7:	c7 45 e4 cf ef 80 00 	movl   $0x80efcf,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e5ee:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e5f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e5f4:	89 04 24             	mov    %eax,(%esp)
  80e5f7:	e8 eb 6b ff ff       	call   8051e7 <tcpip_apimsg>
  80e5fc:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e600:	83 c4 34             	add    $0x34,%esp
  80e603:	5b                   	pop    %ebx
  80e604:	5d                   	pop    %ebp
  80e605:	c3                   	ret    

0080e606 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e606:	55                   	push   %ebp
  80e607:	89 e5                	mov    %esp,%ebp
  80e609:	53                   	push   %ebx
  80e60a:	83 ec 34             	sub    $0x34,%esp
  80e60d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e610:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e614:	85 db                	test   %ebx,%ebx
  80e616:	75 1c                	jne    80e634 <netconn_write+0x2e>
  80e618:	c7 44 24 08 47 48 81 	movl   $0x814847,0x8(%esp)
  80e61f:	00 
  80e620:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e627:	00 
  80e628:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e62f:	e8 48 23 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e634:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e637:	74 1c                	je     80e655 <netconn_write+0x4f>
  80e639:	c7 44 24 08 94 49 81 	movl   $0x814994,0x8(%esp)
  80e640:	00 
  80e641:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e648:	00 
  80e649:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e650:	e8 27 23 ff ff       	call   80097c <_panic>

  msg.function = do_write;
  80e655:	c7 45 e4 5e f3 80 00 	movl   $0x80f35e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e65c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e65f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e662:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e665:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80e668:	8b 45 10             	mov    0x10(%ebp),%eax
  80e66b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e66e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e671:	89 04 24             	mov    %eax,(%esp)
  80e674:	e8 6e 6b ff ff       	call   8051e7 <tcpip_apimsg>
  80e679:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e67d:	83 c4 34             	add    $0x34,%esp
  80e680:	5b                   	pop    %ebx
  80e681:	5d                   	pop    %ebp
  80e682:	c3                   	ret    

0080e683 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e683:	55                   	push   %ebp
  80e684:	89 e5                	mov    %esp,%ebp
  80e686:	53                   	push   %ebx
  80e687:	83 ec 34             	sub    $0x34,%esp
  80e68a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e68d:	85 db                	test   %ebx,%ebx
  80e68f:	75 1c                	jne    80e6ad <netconn_send+0x2a>
  80e691:	c7 44 24 08 63 48 81 	movl   $0x814863,0x8(%esp)
  80e698:	00 
  80e699:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e6a0:	00 
  80e6a1:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e6a8:	e8 cf 22 ff ff       	call   80097c <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e6ad:	c7 45 e4 ec f3 80 00 	movl   $0x80f3ec,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e6b4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80e6b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e6ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e6bd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e6c0:	89 04 24             	mov    %eax,(%esp)
  80e6c3:	e8 1f 6b ff ff       	call   8051e7 <tcpip_apimsg>
  80e6c8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e6cc:	83 c4 34             	add    $0x34,%esp
  80e6cf:	5b                   	pop    %ebx
  80e6d0:	5d                   	pop    %ebp
  80e6d1:	c3                   	ret    

0080e6d2 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e6d2:	55                   	push   %ebp
  80e6d3:	89 e5                	mov    %esp,%ebp
  80e6d5:	83 ec 18             	sub    $0x18,%esp
  80e6d8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e6db:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e6df:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e6e4:	85 d2                	test   %edx,%edx
  80e6e6:	74 19                	je     80e701 <netconn_sendto+0x2f>
    buf->addr = addr;
  80e6e8:	8b 45 10             	mov    0x10(%ebp),%eax
  80e6eb:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e6ee:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e6f2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e6f6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e6f9:	89 04 24             	mov    %eax,(%esp)
  80e6fc:	e8 82 ff ff ff       	call   80e683 <netconn_send>
  }
  return ERR_VAL;
}
  80e701:	c9                   	leave  
  80e702:	c3                   	ret    

0080e703 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e703:	55                   	push   %ebp
  80e704:	89 e5                	mov    %esp,%ebp
  80e706:	53                   	push   %ebx
  80e707:	83 ec 34             	sub    $0x34,%esp
  80e70a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e70d:	85 db                	test   %ebx,%ebx
  80e70f:	75 1c                	jne    80e72d <netconn_listen_with_backlog+0x2a>
  80e711:	c7 44 24 08 7e 48 81 	movl   $0x81487e,0x8(%esp)
  80e718:	00 
  80e719:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e720:	00 
  80e721:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e728:	e8 4f 22 ff ff       	call   80097c <_panic>

  msg.function = do_listen;
  80e72d:	c7 45 e4 af f4 80 00 	movl   $0x80f4af,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e734:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e737:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e73a:	89 04 24             	mov    %eax,(%esp)
  80e73d:	e8 a5 6a ff ff       	call   8051e7 <tcpip_apimsg>
  80e742:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e746:	83 c4 34             	add    $0x34,%esp
  80e749:	5b                   	pop    %ebx
  80e74a:	5d                   	pop    %ebp
  80e74b:	c3                   	ret    

0080e74c <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e74c:	55                   	push   %ebp
  80e74d:	89 e5                	mov    %esp,%ebp
  80e74f:	53                   	push   %ebx
  80e750:	83 ec 34             	sub    $0x34,%esp
  80e753:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e756:	85 db                	test   %ebx,%ebx
  80e758:	75 1c                	jne    80e776 <netconn_disconnect+0x2a>
  80e75a:	c7 44 24 08 b8 49 81 	movl   $0x8149b8,0x8(%esp)
  80e761:	00 
  80e762:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e769:	00 
  80e76a:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e771:	e8 06 22 ff ff       	call   80097c <_panic>

  msg.function = do_disconnect;
  80e776:	c7 45 e4 79 f6 80 00 	movl   $0x80f679,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e77d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80e780:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e783:	89 04 24             	mov    %eax,(%esp)
  80e786:	e8 5c 6a ff ff       	call   8051e7 <tcpip_apimsg>
  80e78b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e78f:	83 c4 34             	add    $0x34,%esp
  80e792:	5b                   	pop    %ebx
  80e793:	5d                   	pop    %ebp
  80e794:	c3                   	ret    

0080e795 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e795:	55                   	push   %ebp
  80e796:	89 e5                	mov    %esp,%ebp
  80e798:	53                   	push   %ebx
  80e799:	83 ec 34             	sub    $0x34,%esp
  80e79c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e79f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e7a3:	85 db                	test   %ebx,%ebx
  80e7a5:	75 1c                	jne    80e7c3 <netconn_connect+0x2e>
  80e7a7:	c7 44 24 08 9b 48 81 	movl   $0x81489b,0x8(%esp)
  80e7ae:	00 
  80e7af:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e7b6:	00 
  80e7b7:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e7be:	e8 b9 21 ff ff       	call   80097c <_panic>

  msg.function = do_connect;
  80e7c3:	c7 45 e4 b0 f6 80 00 	movl   $0x80f6b0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e7ca:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e7cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e7d0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e7d3:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e7d7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e7da:	89 04 24             	mov    %eax,(%esp)
  80e7dd:	e8 05 6a ff ff       	call   8051e7 <tcpip_apimsg>
  80e7e2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e7e6:	83 c4 34             	add    $0x34,%esp
  80e7e9:	5b                   	pop    %ebx
  80e7ea:	5d                   	pop    %ebp
  80e7eb:	c3                   	ret    

0080e7ec <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e7ec:	55                   	push   %ebp
  80e7ed:	89 e5                	mov    %esp,%ebp
  80e7ef:	53                   	push   %ebx
  80e7f0:	83 ec 34             	sub    $0x34,%esp
  80e7f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e7f6:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e7fa:	85 db                	test   %ebx,%ebx
  80e7fc:	75 1c                	jne    80e81a <netconn_bind+0x2e>
  80e7fe:	c7 44 24 08 b9 48 81 	movl   $0x8148b9,0x8(%esp)
  80e805:	00 
  80e806:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e80d:	00 
  80e80e:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e815:	e8 62 21 ff ff       	call   80097c <_panic>

  msg.function = do_bind;
  80e81a:	c7 45 e4 78 f7 80 00 	movl   $0x80f778,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e821:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e824:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e827:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e82a:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e82e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e831:	89 04 24             	mov    %eax,(%esp)
  80e834:	e8 ae 69 ff ff       	call   8051e7 <tcpip_apimsg>
  80e839:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e83d:	83 c4 34             	add    $0x34,%esp
  80e840:	5b                   	pop    %ebx
  80e841:	5d                   	pop    %ebp
  80e842:	c3                   	ret    

0080e843 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e843:	55                   	push   %ebp
  80e844:	89 e5                	mov    %esp,%ebp
  80e846:	53                   	push   %ebx
  80e847:	83 ec 34             	sub    $0x34,%esp
  80e84a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e84d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e850:	8b 45 10             	mov    0x10(%ebp),%eax
  80e853:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e857:	85 db                	test   %ebx,%ebx
  80e859:	75 1c                	jne    80e877 <netconn_getaddr+0x34>
  80e85b:	c7 44 24 08 d4 48 81 	movl   $0x8148d4,0x8(%esp)
  80e862:	00 
  80e863:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e86a:	00 
  80e86b:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e872:	e8 05 21 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e877:	85 d2                	test   %edx,%edx
  80e879:	75 1c                	jne    80e897 <netconn_getaddr+0x54>
  80e87b:	c7 44 24 08 f2 48 81 	movl   $0x8148f2,0x8(%esp)
  80e882:	00 
  80e883:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e88a:	00 
  80e88b:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e892:	e8 e5 20 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e897:	85 c0                	test   %eax,%eax
  80e899:	75 1c                	jne    80e8b7 <netconn_getaddr+0x74>
  80e89b:	c7 44 24 08 10 49 81 	movl   $0x814910,0x8(%esp)
  80e8a2:	00 
  80e8a3:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e8aa:	00 
  80e8ab:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e8b2:	e8 c5 20 ff ff       	call   80097c <_panic>

  msg.function = do_getaddr;
  80e8b7:	c7 45 e4 60 ec 80 00 	movl   $0x80ec60,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e8be:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e8c1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80e8c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80e8c7:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e8ca:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e8cd:	89 04 24             	mov    %eax,(%esp)
  80e8d0:	e8 12 69 ff ff       	call   8051e7 <tcpip_apimsg>
  80e8d5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80e8d9:	83 c4 34             	add    $0x34,%esp
  80e8dc:	5b                   	pop    %ebx
  80e8dd:	5d                   	pop    %ebp
  80e8de:	c3                   	ret    

0080e8df <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e8df:	55                   	push   %ebp
  80e8e0:	89 e5                	mov    %esp,%ebp
  80e8e2:	53                   	push   %ebx
  80e8e3:	83 ec 24             	sub    $0x24,%esp
  80e8e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e8e9:	85 db                	test   %ebx,%ebx
  80e8eb:	75 1c                	jne    80e909 <netconn_accept+0x2a>
  80e8ed:	c7 44 24 08 2e 49 81 	movl   $0x81492e,0x8(%esp)
  80e8f4:	00 
  80e8f5:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e8fc:	00 
  80e8fd:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e904:	e8 73 20 ff ff       	call   80097c <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e909:	8b 43 18             	mov    0x18(%ebx),%eax
  80e90c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e90f:	75 1c                	jne    80e92d <netconn_accept+0x4e>
  80e911:	c7 44 24 08 dc 49 81 	movl   $0x8149dc,0x8(%esp)
  80e918:	00 
  80e919:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e920:	00 
  80e921:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e928:	e8 4f 20 ff ff       	call   80097c <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e92d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e934:	00 
  80e935:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80e938:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e93c:	89 04 24             	mov    %eax,(%esp)
  80e93f:	e8 d0 f2 ff ff       	call   80dc14 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e944:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e947:	85 c0                	test   %eax,%eax
  80e949:	74 15                	je     80e960 <netconn_accept+0x81>
  80e94b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e952:	00 
  80e953:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e95a:	00 
  80e95b:	89 1c 24             	mov    %ebx,(%esp)
  80e95e:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e960:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e963:	83 c4 24             	add    $0x24,%esp
  80e966:	5b                   	pop    %ebx
  80e967:	5d                   	pop    %ebp
  80e968:	c3                   	ret    

0080e969 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e969:	55                   	push   %ebp
  80e96a:	89 e5                	mov    %esp,%ebp
  80e96c:	53                   	push   %ebx
  80e96d:	83 ec 34             	sub    $0x34,%esp
  80e970:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e973:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e97a:	85 db                	test   %ebx,%ebx
  80e97c:	75 1c                	jne    80e99a <netconn_recv+0x31>
  80e97e:	c7 44 24 08 4b 49 81 	movl   $0x81494b,0x8(%esp)
  80e985:	00 
  80e986:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80e98d:	00 
  80e98e:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80e995:	e8 e2 1f ff ff       	call   80097c <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80e99a:	8b 43 14             	mov    0x14(%ebx),%eax
  80e99d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e9a0:	75 0e                	jne    80e9b0 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80e9a2:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e9a6:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80e9ab:	e9 65 01 00 00       	jmp    80eb15 <netconn_recv+0x1ac>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80e9b0:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80e9b4:	0f 8c 56 01 00 00    	jl     80eb10 <netconn_recv+0x1a7>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80e9ba:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e9bd:	8d 76 00             	lea    0x0(%esi),%esi
  80e9c0:	0f 85 fc 00 00 00    	jne    80eac2 <netconn_recv+0x159>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80e9c6:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80e9ca:	75 0e                	jne    80e9da <netconn_recv+0x71>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80e9cc:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e9d0:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80e9d5:	e9 3b 01 00 00       	jmp    80eb15 <netconn_recv+0x1ac>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80e9da:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e9e1:	e8 9e 8d ff ff       	call   807784 <memp_malloc>
  80e9e6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80e9e9:	85 c0                	test   %eax,%eax
  80e9eb:	75 09                	jne    80e9f6 <netconn_recv+0x8d>
      conn->err = ERR_MEM;
  80e9ed:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80e9f1:	e9 1f 01 00 00       	jmp    80eb15 <netconn_recv+0x1ac>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80e9f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9fd:	00 
  80e9fe:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ea01:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ea05:	8b 43 14             	mov    0x14(%ebx),%eax
  80ea08:	89 04 24             	mov    %eax,(%esp)
  80ea0b:	e8 04 f2 ff ff       	call   80dc14 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80ea10:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ea13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea18:	85 d2                	test   %edx,%edx
  80ea1a:	74 08                	je     80ea24 <netconn_recv+0xbb>
      len = p->tot_len;
  80ea1c:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80ea20:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ea24:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80ea27:	85 d2                	test   %edx,%edx
  80ea29:	74 14                	je     80ea3f <netconn_recv+0xd6>
  80ea2b:	0f b7 c0             	movzwl %ax,%eax
  80ea2e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ea32:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80ea39:	00 
  80ea3a:	89 1c 24             	mov    %ebx,(%esp)
  80ea3d:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80ea3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ea42:	85 c0                	test   %eax,%eax
  80ea44:	75 2b                	jne    80ea71 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  80ea46:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea49:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ea4d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ea54:	e8 e7 8c ff ff       	call   807740 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ea59:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ea5d:	0f 85 ad 00 00 00    	jne    80eb10 <netconn_recv+0x1a7>
        conn->err = ERR_CLSD;
  80ea63:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ea67:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea6c:	e9 a4 00 00 00       	jmp    80eb15 <netconn_recv+0x1ac>
      }
      return NULL;
    }

    buf->p = p;
  80ea71:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ea74:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80ea76:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ea79:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea7c:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80ea7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea82:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80ea88:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea8b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80ea92:	c7 45 e4 ab f3 80 00 	movl   $0x80f3ab,-0x1c(%ebp)
    msg.msg.conn = conn;
  80ea99:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80ea9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea9f:	85 c0                	test   %eax,%eax
  80eaa1:	74 0c                	je     80eaaf <netconn_recv+0x146>
      msg.msg.msg.r.len = buf->p->tot_len;
  80eaa3:	8b 00                	mov    (%eax),%eax
  80eaa5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80eaa9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80eaad:	eb 06                	jmp    80eab5 <netconn_recv+0x14c>
    } else {
      msg.msg.msg.r.len = 1;
  80eaaf:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80eab5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eab8:	89 04 24             	mov    %eax,(%esp)
  80eabb:	e8 27 67 ff ff       	call   8051e7 <tcpip_apimsg>
  80eac0:	eb 49                	jmp    80eb0b <netconn_recv+0x1a2>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80eac2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eac9:	00 
  80eaca:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80eacd:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ead1:	89 04 24             	mov    %eax,(%esp)
  80ead4:	e8 3b f1 ff ff       	call   80dc14 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80ead9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eadc:	85 c0                	test   %eax,%eax
  80eade:	74 2b                	je     80eb0b <netconn_recv+0x1a2>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80eae0:	8b 00                	mov    (%eax),%eax
  80eae2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80eae6:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80eaea:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eaed:	85 c0                	test   %eax,%eax
  80eaef:	74 1a                	je     80eb0b <netconn_recv+0x1a2>
  80eaf1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eaf4:	8b 12                	mov    (%edx),%edx
  80eaf6:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80eafa:	89 54 24 08          	mov    %edx,0x8(%esp)
  80eafe:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80eb05:	00 
  80eb06:	89 1c 24             	mov    %ebx,(%esp)
  80eb09:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80eb0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb0e:	eb 05                	jmp    80eb15 <netconn_recv+0x1ac>
  80eb10:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eb15:	83 c4 34             	add    $0x34,%esp
  80eb18:	5b                   	pop    %ebx
  80eb19:	5d                   	pop    %ebp
  80eb1a:	c3                   	ret    

0080eb1b <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80eb1b:	55                   	push   %ebp
  80eb1c:	89 e5                	mov    %esp,%ebp
  80eb1e:	53                   	push   %ebx
  80eb1f:	83 ec 34             	sub    $0x34,%esp
  80eb22:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80eb25:	85 db                	test   %ebx,%ebx
  80eb27:	74 24                	je     80eb4d <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80eb29:	c7 45 e4 19 f8 80 00 	movl   $0x80f819,-0x1c(%ebp)
  msg.msg.conn = conn;
  80eb30:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80eb33:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eb36:	89 04 24             	mov    %eax,(%esp)
  80eb39:	e8 a9 66 ff ff       	call   8051e7 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80eb3e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80eb45:	89 1c 24             	mov    %ebx,(%esp)
  80eb48:	e8 84 0d 00 00       	call   80f8d1 <netconn_free>

  return ERR_OK;
}
  80eb4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb52:	83 c4 34             	add    $0x34,%esp
  80eb55:	5b                   	pop    %ebx
  80eb56:	5d                   	pop    %ebp
  80eb57:	c3                   	ret    

0080eb58 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80eb58:	55                   	push   %ebp
  80eb59:	89 e5                	mov    %esp,%ebp
  80eb5b:	56                   	push   %esi
  80eb5c:	53                   	push   %ebx
  80eb5d:	83 ec 30             	sub    $0x30,%esp
  80eb60:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80eb64:	8b 45 10             	mov    0x10(%ebp),%eax
  80eb67:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb6b:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb6e:	89 04 24             	mov    %eax,(%esp)
  80eb71:	e8 57 0f 00 00       	call   80facd <netconn_alloc>
  80eb76:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80eb78:	85 c0                	test   %eax,%eax
  80eb7a:	0f 84 d6 00 00 00    	je     80ec56 <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80eb80:	c7 45 e4 3a fc 80 00 	movl   $0x80fc3a,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80eb87:	89 f0                	mov    %esi,%eax
  80eb89:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80eb8c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80eb8f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eb92:	89 04 24             	mov    %eax,(%esp)
  80eb95:	e8 4d 66 ff ff       	call   8051e7 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80eb9a:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80eb9e:	0f 84 b2 00 00 00    	je     80ec56 <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80eba4:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80eba8:	74 1c                	je     80ebc6 <netconn_new_with_proto_and_callback+0x6e>
  80ebaa:	c7 44 24 08 00 4a 81 	movl   $0x814a00,0x8(%esp)
  80ebb1:	00 
  80ebb2:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80ebb9:	00 
  80ebba:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80ebc1:	e8 b6 1d ff ff       	call   80097c <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ebc6:	8b 43 10             	mov    0x10(%ebx),%eax
  80ebc9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ebcc:	75 1c                	jne    80ebea <netconn_new_with_proto_and_callback+0x92>
  80ebce:	c7 44 24 08 66 49 81 	movl   $0x814966,0x8(%esp)
  80ebd5:	00 
  80ebd6:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80ebdd:	00 
  80ebde:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80ebe5:	e8 92 1d ff ff       	call   80097c <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ebea:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ebee:	75 1c                	jne    80ec0c <netconn_new_with_proto_and_callback+0xb4>
  80ebf0:	c7 44 24 08 7f 49 81 	movl   $0x81497f,0x8(%esp)
  80ebf7:	00 
  80ebf8:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80ebff:	00 
  80ec00:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80ec07:	e8 70 1d ff ff       	call   80097c <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ec0c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ec10:	74 1c                	je     80ec2e <netconn_new_with_proto_and_callback+0xd6>
  80ec12:	c7 44 24 08 24 4a 81 	movl   $0x814a24,0x8(%esp)
  80ec19:	00 
  80ec1a:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80ec21:	00 
  80ec22:	c7 04 24 14 48 81 00 	movl   $0x814814,(%esp)
  80ec29:	e8 4e 1d ff ff       	call   80097c <_panic>
      sys_sem_free(conn->op_completed);
  80ec2e:	89 04 24             	mov    %eax,(%esp)
  80ec31:	e8 2d e9 ff ff       	call   80d563 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ec36:	8b 43 14             	mov    0x14(%ebx),%eax
  80ec39:	89 04 24             	mov    %eax,(%esp)
  80ec3c:	e8 96 e9 ff ff       	call   80d5d7 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ec41:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ec45:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80ec4c:	e8 ef 8a ff ff       	call   807740 <memp_free>
  80ec51:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80ec56:	89 d8                	mov    %ebx,%eax
  80ec58:	83 c4 30             	add    $0x30,%esp
  80ec5b:	5b                   	pop    %ebx
  80ec5c:	5e                   	pop    %esi
  80ec5d:	5d                   	pop    %ebp
  80ec5e:	c3                   	ret    
	...

0080ec60 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80ec60:	55                   	push   %ebp
  80ec61:	89 e5                	mov    %esp,%ebp
  80ec63:	83 ec 18             	sub    $0x18,%esp
  80ec66:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80ec69:	8b 08                	mov    (%eax),%ecx
  80ec6b:	8b 51 08             	mov    0x8(%ecx),%edx
  80ec6e:	85 d2                	test   %edx,%edx
  80ec70:	0f 84 9f 00 00 00    	je     80ed15 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80ec76:	8b 48 04             	mov    0x4(%eax),%ecx
  80ec79:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ec7d:	74 06                	je     80ec85 <do_getaddr+0x25>
  80ec7f:	8b 12                	mov    (%edx),%edx
  80ec81:	89 11                	mov    %edx,(%ecx)
  80ec83:	eb 05                	jmp    80ec8a <do_getaddr+0x2a>
  80ec85:	8b 52 04             	mov    0x4(%edx),%edx
  80ec88:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ec8a:	8b 08                	mov    (%eax),%ecx
  80ec8c:	8b 11                	mov    (%ecx),%edx
  80ec8e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ec94:	83 fa 20             	cmp    $0x20,%edx
  80ec97:	74 2e                	je     80ecc7 <do_getaddr+0x67>
  80ec99:	83 fa 40             	cmp    $0x40,%edx
  80ec9c:	74 0c                	je     80ecaa <do_getaddr+0x4a>
  80ec9e:	83 fa 10             	cmp    $0x10,%edx
  80eca1:	75 76                	jne    80ed19 <do_getaddr+0xb9>
  80eca3:	90                   	nop
  80eca4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80eca8:	eb 4d                	jmp    80ecf7 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80ecaa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ecae:	66 90                	xchg   %ax,%ax
  80ecb0:	74 0f                	je     80ecc1 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80ecb2:	8b 50 08             	mov    0x8(%eax),%edx
  80ecb5:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ecb8:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80ecbc:	66 89 0a             	mov    %cx,(%edx)
  80ecbf:	eb 58                	jmp    80ed19 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80ecc1:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ecc5:	eb 52                	jmp    80ed19 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80ecc7:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80eccb:	74 0f                	je     80ecdc <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80eccd:	8b 50 08             	mov    0x8(%eax),%edx
  80ecd0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ecd3:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80ecd7:	66 89 0a             	mov    %cx,(%edx)
  80ecda:	eb 3d                	jmp    80ed19 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80ecdc:	8b 51 08             	mov    0x8(%ecx),%edx
  80ecdf:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80ece3:	75 06                	jne    80eceb <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80ece5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ece9:	eb 2e                	jmp    80ed19 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80eceb:	8b 48 08             	mov    0x8(%eax),%ecx
  80ecee:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80ecf2:	66 89 11             	mov    %dx,(%ecx)
  80ecf5:	eb 22                	jmp    80ed19 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80ecf7:	8b 50 08             	mov    0x8(%eax),%edx
  80ecfa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ecfe:	74 09                	je     80ed09 <do_getaddr+0xa9>
  80ed00:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed03:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80ed07:	eb 07                	jmp    80ed10 <do_getaddr+0xb0>
  80ed09:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed0c:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80ed10:	66 89 0a             	mov    %cx,(%edx)
  80ed13:	eb 04                	jmp    80ed19 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80ed15:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80ed19:	8b 00                	mov    (%eax),%eax
  80ed1b:	8b 40 10             	mov    0x10(%eax),%eax
  80ed1e:	89 04 24             	mov    %eax,(%esp)
  80ed21:	e8 81 ee ff ff       	call   80dba7 <sys_sem_signal>
}
  80ed26:	c9                   	leave  
  80ed27:	c3                   	ret    

0080ed28 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80ed28:	55                   	push   %ebp
  80ed29:	89 e5                	mov    %esp,%ebp
  80ed2b:	53                   	push   %ebx
  80ed2c:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80ed2f:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80ed32:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ed36:	89 1c 24             	mov    %ebx,(%esp)
  80ed39:	e8 08 9b ff ff       	call   808846 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80ed3e:	c7 44 24 04 a0 f5 80 	movl   $0x80f5a0,0x4(%esp)
  80ed45:	00 
  80ed46:	89 1c 24             	mov    %ebx,(%esp)
  80ed49:	e8 06 9b ff ff       	call   808854 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80ed4e:	c7 44 24 04 ac f2 80 	movl   $0x80f2ac,0x4(%esp)
  80ed55:	00 
  80ed56:	89 1c 24             	mov    %ebx,(%esp)
  80ed59:	e8 07 9b ff ff       	call   808865 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80ed5e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ed65:	00 
  80ed66:	c7 44 24 04 57 f2 80 	movl   $0x80f257,0x4(%esp)
  80ed6d:	00 
  80ed6e:	89 1c 24             	mov    %ebx,(%esp)
  80ed71:	e8 1f 9b ff ff       	call   808895 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80ed76:	c7 44 24 04 08 f0 80 	movl   $0x80f008,0x4(%esp)
  80ed7d:	00 
  80ed7e:	89 1c 24             	mov    %ebx,(%esp)
  80ed81:	e8 f0 9a ff ff       	call   808876 <tcp_err>
}
  80ed86:	83 c4 14             	add    $0x14,%esp
  80ed89:	5b                   	pop    %ebx
  80ed8a:	5d                   	pop    %ebp
  80ed8b:	c3                   	ret    

0080ed8c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ed8c:	55                   	push   %ebp
  80ed8d:	89 e5                	mov    %esp,%ebp
  80ed8f:	53                   	push   %ebx
  80ed90:	83 ec 14             	sub    $0x14,%esp
  80ed93:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80ed97:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80ed9a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80ed9f:	85 db                	test   %ebx,%ebx
  80eda1:	74 2a                	je     80edcd <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80eda3:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80eda6:	83 3b 10             	cmpl   $0x10,(%ebx)
  80eda9:	75 0b                	jne    80edb6 <do_connected+0x2a>
  80edab:	84 d2                	test   %dl,%dl
  80edad:	75 07                	jne    80edb6 <do_connected+0x2a>
    setup_tcp(conn);
  80edaf:	89 d8                	mov    %ebx,%eax
  80edb1:	e8 72 ff ff ff       	call   80ed28 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80edb6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80edbd:	8b 43 10             	mov    0x10(%ebx),%eax
  80edc0:	89 04 24             	mov    %eax,(%esp)
  80edc3:	e8 df ed ff ff       	call   80dba7 <sys_sem_signal>
  80edc8:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80edcd:	83 c4 14             	add    $0x14,%esp
  80edd0:	5b                   	pop    %ebx
  80edd1:	5d                   	pop    %ebp
  80edd2:	c3                   	ret    

0080edd3 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80edd3:	55                   	push   %ebp
  80edd4:	89 e5                	mov    %esp,%ebp
  80edd6:	53                   	push   %ebx
  80edd7:	83 ec 14             	sub    $0x14,%esp
  80edda:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80eddc:	85 c0                	test   %eax,%eax
  80edde:	75 1c                	jne    80edfc <do_close_internal+0x29>
  80ede0:	c7 44 24 08 71 48 81 	movl   $0x814871,0x8(%esp)
  80ede7:	00 
  80ede8:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80edef:	00 
  80edf0:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80edf7:	e8 80 1b ff ff       	call   80097c <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80edfc:	83 38 10             	cmpl   $0x10,(%eax)
  80edff:	74 1c                	je     80ee1d <do_close_internal+0x4a>
  80ee01:	c7 44 24 08 5c 4a 81 	movl   $0x814a5c,0x8(%esp)
  80ee08:	00 
  80ee09:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80ee10:	00 
  80ee11:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80ee18:	e8 5f 1b ff ff       	call   80097c <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ee1d:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80ee21:	74 1c                	je     80ee3f <do_close_internal+0x6c>
  80ee23:	c7 44 24 08 28 4b 81 	movl   $0x814b28,0x8(%esp)
  80ee2a:	00 
  80ee2b:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80ee32:	00 
  80ee33:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80ee3a:	e8 3d 1b ff ff       	call   80097c <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80ee3f:	8b 40 08             	mov    0x8(%eax),%eax
  80ee42:	85 c0                	test   %eax,%eax
  80ee44:	75 1c                	jne    80ee62 <do_close_internal+0x8f>
  80ee46:	c7 44 24 08 7a 4a 81 	movl   $0x814a7a,0x8(%esp)
  80ee4d:	00 
  80ee4e:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80ee55:	00 
  80ee56:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80ee5d:	e8 1a 1b ff ff       	call   80097c <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80ee62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee69:	00 
  80ee6a:	89 04 24             	mov    %eax,(%esp)
  80ee6d:	e8 d4 99 ff ff       	call   808846 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80ee72:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee75:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ee79:	75 12                	jne    80ee8d <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80ee7b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee82:	00 
  80ee83:	89 04 24             	mov    %eax,(%esp)
  80ee86:	e8 fc 99 ff ff       	call   808887 <tcp_accept>
  80ee8b:	eb 64                	jmp    80eef1 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80ee8d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee94:	00 
  80ee95:	89 04 24             	mov    %eax,(%esp)
  80ee98:	e8 b7 99 ff ff       	call   808854 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80ee9d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eea4:	00 
  80eea5:	8b 43 08             	mov    0x8(%ebx),%eax
  80eea8:	89 04 24             	mov    %eax,(%esp)
  80eeab:	e8 d7 99 ff ff       	call   808887 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80eeb0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eeb7:	00 
  80eeb8:	8b 43 08             	mov    0x8(%ebx),%eax
  80eebb:	89 04 24             	mov    %eax,(%esp)
  80eebe:	e8 a2 99 ff ff       	call   808865 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80eec3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80eeca:	00 
  80eecb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eed2:	00 
  80eed3:	8b 43 08             	mov    0x8(%ebx),%eax
  80eed6:	89 04 24             	mov    %eax,(%esp)
  80eed9:	e8 b7 99 ff ff       	call   808895 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80eede:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eee5:	00 
  80eee6:	8b 43 08             	mov    0x8(%ebx),%eax
  80eee9:	89 04 24             	mov    %eax,(%esp)
  80eeec:	e8 85 99 ff ff       	call   808876 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80eef1:	8b 43 08             	mov    0x8(%ebx),%eax
  80eef4:	89 04 24             	mov    %eax,(%esp)
  80eef7:	e8 41 a8 ff ff       	call   80973d <tcp_close>
  if (err == ERR_OK) {
  80eefc:	84 c0                	test   %al,%al
  80eefe:	75 57                	jne    80ef57 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80ef00:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80ef07:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80ef0e:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80ef12:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ef15:	85 c0                	test   %eax,%eax
  80ef17:	74 31                	je     80ef4a <do_close_internal+0x177>
  80ef19:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ef20:	00 
  80ef21:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef28:	00 
  80ef29:	89 1c 24             	mov    %ebx,(%esp)
  80ef2c:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80ef2e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ef31:	85 c0                	test   %eax,%eax
  80ef33:	74 15                	je     80ef4a <do_close_internal+0x177>
  80ef35:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ef3c:	00 
  80ef3d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ef44:	00 
  80ef45:	89 1c 24             	mov    %ebx,(%esp)
  80ef48:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80ef4a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ef4d:	89 04 24             	mov    %eax,(%esp)
  80ef50:	e8 52 ec ff ff       	call   80dba7 <sys_sem_signal>
  80ef55:	eb 72                	jmp    80efc9 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ef57:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef5a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ef5e:	75 1c                	jne    80ef7c <do_close_internal+0x1a9>
  80ef60:	c7 44 24 08 4c 4b 81 	movl   $0x814b4c,0x8(%esp)
  80ef67:	00 
  80ef68:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ef6f:	00 
  80ef70:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80ef77:	e8 00 1a ff ff       	call   80097c <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80ef7c:	c7 44 24 04 ac f2 80 	movl   $0x80f2ac,0x4(%esp)
  80ef83:	00 
  80ef84:	89 04 24             	mov    %eax,(%esp)
  80ef87:	e8 d9 98 ff ff       	call   808865 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80ef8c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ef93:	00 
  80ef94:	c7 44 24 04 57 f2 80 	movl   $0x80f257,0x4(%esp)
  80ef9b:	00 
  80ef9c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef9f:	89 04 24             	mov    %eax,(%esp)
  80efa2:	e8 ee 98 ff ff       	call   808895 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80efa7:	c7 44 24 04 08 f0 80 	movl   $0x80f008,0x4(%esp)
  80efae:	00 
  80efaf:	8b 43 08             	mov    0x8(%ebx),%eax
  80efb2:	89 04 24             	mov    %eax,(%esp)
  80efb5:	e8 bc 98 ff ff       	call   808876 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80efba:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80efbe:	8b 43 08             	mov    0x8(%ebx),%eax
  80efc1:	89 04 24             	mov    %eax,(%esp)
  80efc4:	e8 7d 98 ff ff       	call   808846 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80efc9:	83 c4 14             	add    $0x14,%esp
  80efcc:	5b                   	pop    %ebx
  80efcd:	5d                   	pop    %ebp
  80efce:	c3                   	ret    

0080efcf <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80efcf:	55                   	push   %ebp
  80efd0:	89 e5                	mov    %esp,%ebp
  80efd2:	83 ec 18             	sub    $0x18,%esp
  80efd5:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80efd8:	8b 02                	mov    (%edx),%eax
  80efda:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80efde:	74 15                	je     80eff5 <do_close+0x26>
  80efe0:	83 38 10             	cmpl   $0x10,(%eax)
  80efe3:	75 10                	jne    80eff5 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80efe5:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80efec:	8b 02                	mov    (%edx),%eax
  80efee:	e8 e0 fd ff ff       	call   80edd3 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80eff3:	eb 11                	jmp    80f006 <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80eff5:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80eff9:	8b 02                	mov    (%edx),%eax
  80effb:	8b 40 10             	mov    0x10(%eax),%eax
  80effe:	89 04 24             	mov    %eax,(%esp)
  80f001:	e8 a1 eb ff ff       	call   80dba7 <sys_sem_signal>
  }
}
  80f006:	c9                   	leave  
  80f007:	c3                   	ret    

0080f008 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80f008:	55                   	push   %ebp
  80f009:	89 e5                	mov    %esp,%ebp
  80f00b:	53                   	push   %ebx
  80f00c:	83 ec 14             	sub    $0x14,%esp
  80f00f:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80f013:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f016:	85 db                	test   %ebx,%ebx
  80f018:	75 1c                	jne    80f036 <err_tcp+0x2e>
  80f01a:	c7 44 24 08 8d 4a 81 	movl   $0x814a8d,0x8(%esp)
  80f021:	00 
  80f022:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80f029:	00 
  80f02a:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f031:	e8 46 19 ff ff       	call   80097c <_panic>

  conn->pcb.tcp = NULL;
  80f036:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80f03d:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f040:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f044:	74 2f                	je     80f075 <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f046:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f049:	85 c0                	test   %eax,%eax
  80f04b:	74 15                	je     80f062 <err_tcp+0x5a>
  80f04d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f054:	00 
  80f055:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f05c:	00 
  80f05d:	89 1c 24             	mov    %ebx,(%esp)
  80f060:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80f062:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f069:	00 
  80f06a:	8b 43 14             	mov    0x14(%ebx),%eax
  80f06d:	89 04 24             	mov    %eax,(%esp)
  80f070:	e8 91 ed ff ff       	call   80de06 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80f075:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80f079:	74 18                	je     80f093 <err_tcp+0x8b>
  80f07b:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80f07f:	75 12                	jne    80f093 <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80f081:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80f088:	8b 43 10             	mov    0x10(%ebx),%eax
  80f08b:	89 04 24             	mov    %eax,(%esp)
  80f08e:	e8 14 eb ff ff       	call   80dba7 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f093:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f097:	74 2f                	je     80f0c8 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f099:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f09c:	85 c0                	test   %eax,%eax
  80f09e:	74 15                	je     80f0b5 <err_tcp+0xad>
  80f0a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f0a7:	00 
  80f0a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f0af:	00 
  80f0b0:	89 1c 24             	mov    %ebx,(%esp)
  80f0b3:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80f0b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f0bc:	00 
  80f0bd:	8b 43 18             	mov    0x18(%ebx),%eax
  80f0c0:	89 04 24             	mov    %eax,(%esp)
  80f0c3:	e8 3e ed ff ff       	call   80de06 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80f0c8:	8b 43 04             	mov    0x4(%ebx),%eax
  80f0cb:	83 f8 01             	cmp    $0x1,%eax
  80f0ce:	74 05                	je     80f0d5 <err_tcp+0xcd>
  80f0d0:	83 f8 04             	cmp    $0x4,%eax
  80f0d3:	75 12                	jne    80f0e7 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80f0d5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80f0dc:	8b 43 10             	mov    0x10(%ebx),%eax
  80f0df:	89 04 24             	mov    %eax,(%esp)
  80f0e2:	e8 c0 ea ff ff       	call   80dba7 <sys_sem_signal>
  }
}
  80f0e7:	83 c4 14             	add    $0x14,%esp
  80f0ea:	5b                   	pop    %ebx
  80f0eb:	5d                   	pop    %ebp
  80f0ec:	c3                   	ret    

0080f0ed <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80f0ed:	55                   	push   %ebp
  80f0ee:	89 e5                	mov    %esp,%ebp
  80f0f0:	57                   	push   %edi
  80f0f1:	56                   	push   %esi
  80f0f2:	53                   	push   %ebx
  80f0f3:	83 ec 2c             	sub    $0x2c,%esp
  80f0f6:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80f0f8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80f0fc:	74 1c                	je     80f11a <do_writemore+0x2d>
  80f0fe:	c7 44 24 08 9a 4a 81 	movl   $0x814a9a,0x8(%esp)
  80f105:	00 
  80f106:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80f10d:	00 
  80f10e:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f115:	e8 62 18 ff ff       	call   80097c <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80f11a:	8b 50 24             	mov    0x24(%eax),%edx
  80f11d:	8b 42 04             	mov    0x4(%edx),%eax
  80f120:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f123:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80f126:	8b 72 08             	mov    0x8(%edx),%esi
  80f129:	89 f1                	mov    %esi,%ecx
  80f12b:	29 c1                	sub    %eax,%ecx
  80f12d:	66 29 c6             	sub    %ax,%si
  80f130:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  80f134:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80f13a:	0f 9c c1             	setl   %cl
  80f13d:	0f b6 f1             	movzbl %cl,%esi
  80f140:	83 ee 01             	sub    $0x1,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80f143:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80f146:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80f14a:	66 0b 75 e2          	or     -0x1e(%ebp),%si
  80f14e:	66 39 fe             	cmp    %di,%si
  80f151:	76 02                	jbe    80f155 <do_writemore+0x68>
  80f153:	89 fe                	mov    %edi,%esi
  80f155:	0f b7 f6             	movzwl %si,%esi
  80f158:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80f15c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f160:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f164:	03 45 e4             	add    -0x1c(%ebp),%eax
  80f167:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f16b:	89 0c 24             	mov    %ecx,(%esp)
  80f16e:	e8 26 ce ff ff       	call   80bf99 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80f173:	89 f2                	mov    %esi,%edx
  80f175:	03 53 28             	add    0x28(%ebx),%edx
  80f178:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80f17b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80f17e:	7e 1c                	jle    80f19c <do_writemore+0xaf>
  80f180:	c7 44 24 08 b7 4a 81 	movl   $0x814ab7,0x8(%esp)
  80f187:	00 
  80f188:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80f18f:	00 
  80f190:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f197:	e8 e0 17 ff ff       	call   80097c <_panic>
  if (err == ERR_OK) {
  80f19c:	84 c0                	test   %al,%al
  80f19e:	75 72                	jne    80f212 <do_writemore+0x125>
    conn->write_offset += len;
  80f1a0:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80f1a3:	8b 43 24             	mov    0x24(%ebx),%eax
  80f1a6:	bf 00 00 00 00       	mov    $0x0,%edi
  80f1ab:	3b 50 08             	cmp    0x8(%eax),%edx
  80f1ae:	75 13                	jne    80f1c3 <do_writemore+0xd6>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80f1b0:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80f1b7:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80f1be:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80f1c3:	8b 43 08             	mov    0x8(%ebx),%eax
  80f1c6:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80f1ca:	74 12                	je     80f1de <do_writemore+0xf1>
  80f1cc:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80f1d0:	75 0c                	jne    80f1de <do_writemore+0xf1>
  80f1d2:	8b 50 74             	mov    0x74(%eax),%edx
  80f1d5:	85 d2                	test   %edx,%edx
  80f1d7:	74 78                	je     80f251 <do_writemore+0x164>
  80f1d9:	83 3a 00             	cmpl   $0x0,(%edx)
  80f1dc:	74 73                	je     80f251 <do_writemore+0x164>
  80f1de:	89 04 24             	mov    %eax,(%esp)
  80f1e1:	e8 75 c1 ff ff       	call   80b35b <tcp_output>
    conn->err = err;
  80f1e6:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80f1e9:	84 c0                	test   %al,%al
  80f1eb:	75 3f                	jne    80f22c <do_writemore+0x13f>
  80f1ed:	8b 43 08             	mov    0x8(%ebx),%eax
  80f1f0:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f1f6:	77 34                	ja     80f22c <do_writemore+0x13f>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80f1f8:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f1fb:	85 c0                	test   %eax,%eax
  80f1fd:	74 2d                	je     80f22c <do_writemore+0x13f>
  80f1ff:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f203:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80f20a:	00 
  80f20b:	89 1c 24             	mov    %ebx,(%esp)
  80f20e:	ff d0                	call   *%eax
  80f210:	eb 1a                	jmp    80f22c <do_writemore+0x13f>
    }
  } else if (err == ERR_MEM) {
  80f212:	3c ff                	cmp    $0xff,%al
  80f214:	75 11                	jne    80f227 <do_writemore+0x13a>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80f216:	8b 43 08             	mov    0x8(%ebx),%eax
  80f219:	89 04 24             	mov    %eax,(%esp)
  80f21c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f220:	e8 36 c1 ff ff       	call   80b35b <tcp_output>
  80f225:	eb 1d                	jmp    80f244 <do_writemore+0x157>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80f227:	88 43 0c             	mov    %al,0xc(%ebx)
  80f22a:	eb 06                	jmp    80f232 <do_writemore+0x145>
    write_finished = 1;
  }

  if (write_finished) {
  80f22c:	89 f8                	mov    %edi,%eax
  80f22e:	84 c0                	test   %al,%al
  80f230:	74 12                	je     80f244 <do_writemore+0x157>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80f232:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80f239:	8b 43 10             	mov    0x10(%ebx),%eax
  80f23c:	89 04 24             	mov    %eax,(%esp)
  80f23f:	e8 63 e9 ff ff       	call   80dba7 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80f244:	b8 00 00 00 00       	mov    $0x0,%eax
  80f249:	83 c4 2c             	add    $0x2c,%esp
  80f24c:	5b                   	pop    %ebx
  80f24d:	5e                   	pop    %esi
  80f24e:	5f                   	pop    %edi
  80f24f:	5d                   	pop    %ebp
  80f250:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80f251:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80f255:	eb 96                	jmp    80f1ed <do_writemore+0x100>

0080f257 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80f257:	55                   	push   %ebp
  80f258:	89 e5                	mov    %esp,%ebp
  80f25a:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80f25d:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f260:	85 c0                	test   %eax,%eax
  80f262:	75 1c                	jne    80f280 <poll_tcp+0x29>
  80f264:	c7 44 24 08 8d 4a 81 	movl   $0x814a8d,0x8(%esp)
  80f26b:	00 
  80f26c:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80f273:	00 
  80f274:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f27b:	e8 fc 16 ff ff       	call   80097c <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f280:	8b 50 04             	mov    0x4(%eax),%edx
  80f283:	83 fa 01             	cmp    $0x1,%edx
  80f286:	75 0a                	jne    80f292 <poll_tcp+0x3b>
    do_writemore(conn);
  80f288:	e8 60 fe ff ff       	call   80f0ed <do_writemore>
  80f28d:	8d 76 00             	lea    0x0(%esi),%esi
  80f290:	eb 13                	jmp    80f2a5 <poll_tcp+0x4e>
  } else if (conn->state == NETCONN_CLOSE) {
  80f292:	83 fa 04             	cmp    $0x4,%edx
  80f295:	75 0e                	jne    80f2a5 <poll_tcp+0x4e>
    do_close_internal(conn);
  80f297:	89 f6                	mov    %esi,%esi
  80f299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  80f2a0:	e8 2e fb ff ff       	call   80edd3 <do_close_internal>
  }

  return ERR_OK;
}
  80f2a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2aa:	c9                   	leave  
  80f2ab:	c3                   	ret    

0080f2ac <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80f2ac:	55                   	push   %ebp
  80f2ad:	89 e5                	mov    %esp,%ebp
  80f2af:	83 ec 18             	sub    $0x18,%esp
  80f2b2:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f2b5:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f2b8:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80f2bc:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f2bf:	85 db                	test   %ebx,%ebx
  80f2c1:	75 1c                	jne    80f2df <sent_tcp+0x33>
  80f2c3:	c7 44 24 08 8d 4a 81 	movl   $0x814a8d,0x8(%esp)
  80f2ca:	00 
  80f2cb:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80f2d2:	00 
  80f2d3:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f2da:	e8 9d 16 ff ff       	call   80097c <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f2df:	8b 43 04             	mov    0x4(%ebx),%eax
  80f2e2:	83 f8 01             	cmp    $0x1,%eax
  80f2e5:	75 2b                	jne    80f312 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80f2e7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f2eb:	75 1c                	jne    80f309 <sent_tcp+0x5d>
  80f2ed:	c7 44 24 08 d5 4a 81 	movl   $0x814ad5,0x8(%esp)
  80f2f4:	00 
  80f2f5:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80f2fc:	00 
  80f2fd:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f304:	e8 73 16 ff ff       	call   80097c <_panic>
    do_writemore(conn);
  80f309:	89 d8                	mov    %ebx,%eax
  80f30b:	e8 dd fd ff ff       	call   80f0ed <do_writemore>
  80f310:	eb 13                	jmp    80f325 <sent_tcp+0x79>
  } else if (conn->state == NETCONN_CLOSE) {
  80f312:	83 f8 04             	cmp    $0x4,%eax
  80f315:	75 0e                	jne    80f325 <sent_tcp+0x79>
    do_close_internal(conn);
  80f317:	89 d8                	mov    %ebx,%eax
  80f319:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80f320:	e8 ae fa ff ff       	call   80edd3 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80f325:	8b 43 08             	mov    0x8(%ebx),%eax
  80f328:	85 c0                	test   %eax,%eax
  80f32a:	74 23                	je     80f34f <sent_tcp+0xa3>
  80f32c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f332:	76 1b                	jbe    80f34f <sent_tcp+0xa3>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80f334:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f337:	85 c0                	test   %eax,%eax
  80f339:	74 14                	je     80f34f <sent_tcp+0xa3>
  80f33b:	0f b7 f6             	movzwl %si,%esi
  80f33e:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f342:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f349:	00 
  80f34a:	89 1c 24             	mov    %ebx,(%esp)
  80f34d:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80f34f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f354:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f357:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f35a:	89 ec                	mov    %ebp,%esp
  80f35c:	5d                   	pop    %ebp
  80f35d:	c3                   	ret    

0080f35e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80f35e:	55                   	push   %ebp
  80f35f:	89 e5                	mov    %esp,%ebp
  80f361:	83 ec 18             	sub    $0x18,%esp
  80f364:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f367:	8b 02                	mov    (%edx),%eax
  80f369:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f36d:	7c 2d                	jl     80f39c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f36f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f373:	74 23                	je     80f398 <do_write+0x3a>
  80f375:	83 38 10             	cmpl   $0x10,(%eax)
  80f378:	75 1e                	jne    80f398 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80f37a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80f381:	8b 02                	mov    (%edx),%eax
  80f383:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80f386:	8b 02                	mov    (%edx),%eax
  80f388:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80f38f:	8b 02                	mov    (%edx),%eax
  80f391:	e8 57 fd ff ff       	call   80f0ed <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80f396:	eb 11                	jmp    80f3a9 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80f398:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f39c:	8b 02                	mov    (%edx),%eax
  80f39e:	8b 40 10             	mov    0x10(%eax),%eax
  80f3a1:	89 04 24             	mov    %eax,(%esp)
  80f3a4:	e8 fe e7 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f3a9:	c9                   	leave  
  80f3aa:	c3                   	ret    

0080f3ab <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80f3ab:	55                   	push   %ebp
  80f3ac:	89 e5                	mov    %esp,%ebp
  80f3ae:	53                   	push   %ebx
  80f3af:	83 ec 14             	sub    $0x14,%esp
  80f3b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f3b5:	8b 03                	mov    (%ebx),%eax
  80f3b7:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f3bb:	7c 1c                	jl     80f3d9 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80f3bd:	8b 50 08             	mov    0x8(%eax),%edx
  80f3c0:	85 d2                	test   %edx,%edx
  80f3c2:	74 15                	je     80f3d9 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80f3c4:	83 38 10             	cmpl   $0x10,(%eax)
  80f3c7:	75 10                	jne    80f3d9 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80f3c9:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80f3cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f3d1:	89 14 24             	mov    %edx,(%esp)
  80f3d4:	e8 1d 95 ff ff       	call   8088f6 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f3d9:	8b 03                	mov    (%ebx),%eax
  80f3db:	8b 40 10             	mov    0x10(%eax),%eax
  80f3de:	89 04 24             	mov    %eax,(%esp)
  80f3e1:	e8 c1 e7 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f3e6:	83 c4 14             	add    $0x14,%esp
  80f3e9:	5b                   	pop    %ebx
  80f3ea:	5d                   	pop    %ebp
  80f3eb:	c3                   	ret    

0080f3ec <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80f3ec:	55                   	push   %ebp
  80f3ed:	89 e5                	mov    %esp,%ebp
  80f3ef:	83 ec 28             	sub    $0x28,%esp
  80f3f2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f3f5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f3f8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f3fb:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f3fe:	8b 1e                	mov    (%esi),%ebx
  80f400:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f404:	0f 8c 8b 00 00 00    	jl     80f495 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80f40a:	8b 43 08             	mov    0x8(%ebx),%eax
  80f40d:	85 c0                	test   %eax,%eax
  80f40f:	0f 84 80 00 00 00    	je     80f495 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f415:	8b 13                	mov    (%ebx),%edx
  80f417:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f41d:	83 fa 20             	cmp    $0x20,%edx
  80f420:	74 39                	je     80f45b <do_send+0x6f>
  80f422:	83 fa 40             	cmp    $0x40,%edx
  80f425:	75 6e                	jne    80f495 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80f427:	8b 56 04             	mov    0x4(%esi),%edx
  80f42a:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f42d:	85 c9                	test   %ecx,%ecx
  80f42f:	75 13                	jne    80f444 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80f431:	8b 12                	mov    (%edx),%edx
  80f433:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f437:	89 04 24             	mov    %eax,(%esp)
  80f43a:	e8 43 27 00 00       	call   811b82 <raw_send>
  80f43f:	88 43 0c             	mov    %al,0xc(%ebx)
  80f442:	eb 51                	jmp    80f495 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80f444:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f448:	8b 12                	mov    (%edx),%edx
  80f44a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f44e:	89 04 24             	mov    %eax,(%esp)
  80f451:	e8 22 26 00 00       	call   811a78 <raw_sendto>
  80f456:	88 43 0c             	mov    %al,0xc(%ebx)
  80f459:	eb 3a                	jmp    80f495 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80f45b:	8b 56 04             	mov    0x4(%esi),%edx
  80f45e:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f461:	85 c9                	test   %ecx,%ecx
  80f463:	75 13                	jne    80f478 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80f465:	8b 12                	mov    (%edx),%edx
  80f467:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f46b:	89 04 24             	mov    %eax,(%esp)
  80f46e:	e8 eb cf ff ff       	call   80c45e <udp_send>
  80f473:	88 43 0c             	mov    %al,0xc(%ebx)
  80f476:	eb 1d                	jmp    80f495 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80f478:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80f47c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80f480:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f484:	8b 12                	mov    (%edx),%edx
  80f486:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f48a:	89 04 24             	mov    %eax,(%esp)
  80f48d:	e8 7b cf ff ff       	call   80c40d <udp_sendto>
  80f492:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f495:	8b 06                	mov    (%esi),%eax
  80f497:	8b 40 10             	mov    0x10(%eax),%eax
  80f49a:	89 04 24             	mov    %eax,(%esp)
  80f49d:	e8 05 e7 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f4a2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f4a5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f4a8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f4ab:	89 ec                	mov    %ebp,%esp
  80f4ad:	5d                   	pop    %ebp
  80f4ae:	c3                   	ret    

0080f4af <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80f4af:	55                   	push   %ebp
  80f4b0:	89 e5                	mov    %esp,%ebp
  80f4b2:	83 ec 28             	sub    $0x28,%esp
  80f4b5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f4b8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f4bb:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f4be:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f4c1:	8b 03                	mov    (%ebx),%eax
  80f4c3:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f4c7:	0f 8c b9 00 00 00    	jl     80f586 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80f4cd:	8b 50 08             	mov    0x8(%eax),%edx
  80f4d0:	85 d2                	test   %edx,%edx
  80f4d2:	0f 84 ae 00 00 00    	je     80f586 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80f4d8:	83 38 10             	cmpl   $0x10,(%eax)
  80f4db:	0f 85 a5 00 00 00    	jne    80f586 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80f4e1:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80f4e5:	0f 85 97 00 00 00    	jne    80f582 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80f4eb:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f4f2:	00 
  80f4f3:	89 14 24             	mov    %edx,(%esp)
  80f4f6:	e8 3e 97 ff ff       	call   808c39 <tcp_listen_with_backlog>
  80f4fb:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80f4fd:	85 c0                	test   %eax,%eax
  80f4ff:	75 08                	jne    80f509 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80f501:	8b 03                	mov    (%ebx),%eax
  80f503:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f507:	eb 7d                	jmp    80f586 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80f509:	8b 03                	mov    (%ebx),%eax
  80f50b:	8b 40 14             	mov    0x14(%eax),%eax
  80f50e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f511:	74 11                	je     80f524 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80f513:	89 04 24             	mov    %eax,(%esp)
  80f516:	e8 bc e0 ff ff       	call   80d5d7 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80f51b:	8b 03                	mov    (%ebx),%eax
  80f51d:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80f524:	8b 3b                	mov    (%ebx),%edi
  80f526:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80f52a:	75 1a                	jne    80f546 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80f52c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f533:	e8 57 e5 ff ff       	call   80da8f <sys_mbox_new>
  80f538:	89 47 18             	mov    %eax,0x18(%edi)
  80f53b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f53e:	75 06                	jne    80f546 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80f540:	8b 03                	mov    (%ebx),%eax
  80f542:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f546:	8b 03                	mov    (%ebx),%eax
  80f548:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f54c:	75 38                	jne    80f586 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80f54e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f555:	8b 03                	mov    (%ebx),%eax
  80f557:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f55a:	8b 03                	mov    (%ebx),%eax
  80f55c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f560:	8b 40 08             	mov    0x8(%eax),%eax
  80f563:	89 04 24             	mov    %eax,(%esp)
  80f566:	e8 db 92 ff ff       	call   808846 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f56b:	c7 44 24 04 84 fb 80 	movl   $0x80fb84,0x4(%esp)
  80f572:	00 
  80f573:	8b 03                	mov    (%ebx),%eax
  80f575:	8b 40 08             	mov    0x8(%eax),%eax
  80f578:	89 04 24             	mov    %eax,(%esp)
  80f57b:	e8 07 93 ff ff       	call   808887 <tcp_accept>
  80f580:	eb 04                	jmp    80f586 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f582:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f586:	8b 03                	mov    (%ebx),%eax
  80f588:	8b 40 10             	mov    0x10(%eax),%eax
  80f58b:	89 04 24             	mov    %eax,(%esp)
  80f58e:	e8 14 e6 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f593:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f596:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f599:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f59c:	89 ec                	mov    %ebp,%esp
  80f59e:	5d                   	pop    %ebp
  80f59f:	c3                   	ret    

0080f5a0 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f5a0:	55                   	push   %ebp
  80f5a1:	89 e5                	mov    %esp,%ebp
  80f5a3:	83 ec 18             	sub    $0x18,%esp
  80f5a6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f5a9:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f5ac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f5af:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f5b2:	8b 75 10             	mov    0x10(%ebp),%esi
  80f5b5:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f5b9:	85 c0                	test   %eax,%eax
  80f5bb:	75 1c                	jne    80f5d9 <recv_tcp+0x39>
  80f5bd:	c7 44 24 08 70 4b 81 	movl   $0x814b70,0x8(%esp)
  80f5c4:	00 
  80f5c5:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f5cc:	00 
  80f5cd:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f5d4:	e8 a3 13 ff ff       	call   80097c <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f5d9:	85 db                	test   %ebx,%ebx
  80f5db:	75 1c                	jne    80f5f9 <recv_tcp+0x59>
  80f5dd:	c7 44 24 08 94 4b 81 	movl   $0x814b94,0x8(%esp)
  80f5e4:	00 
  80f5e5:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f5ec:	00 
  80f5ed:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f5f4:	e8 83 13 ff ff       	call   80097c <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f5f9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f5fc:	74 1c                	je     80f61a <recv_tcp+0x7a>
  80f5fe:	c7 44 24 08 eb 4a 81 	movl   $0x814aeb,0x8(%esp)
  80f605:	00 
  80f606:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f60d:	00 
  80f60e:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f615:	e8 62 13 ff ff       	call   80097c <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f61a:	85 db                	test   %ebx,%ebx
  80f61c:	74 4c                	je     80f66a <recv_tcp+0xca>
  80f61e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f622:	74 46                	je     80f66a <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80f624:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80f627:	b8 00 00 00 00       	mov    $0x0,%eax
  80f62c:	85 f6                	test   %esi,%esi
  80f62e:	74 08                	je     80f638 <recv_tcp+0x98>
    len = p->tot_len;
  80f630:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f634:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f638:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f63b:	85 d2                	test   %edx,%edx
  80f63d:	74 14                	je     80f653 <recv_tcp+0xb3>
  80f63f:	0f b7 c0             	movzwl %ax,%eax
  80f642:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f646:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f64d:	00 
  80f64e:	89 1c 24             	mov    %ebx,(%esp)
  80f651:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f653:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f657:	8b 43 14             	mov    0x14(%ebx),%eax
  80f65a:	89 04 24             	mov    %eax,(%esp)
  80f65d:	e8 d6 e6 ff ff       	call   80dd38 <sys_mbox_trypost>
  80f662:	3c 01                	cmp    $0x1,%al
  80f664:	19 c0                	sbb    %eax,%eax
  80f666:	f7 d0                	not    %eax
  80f668:	eb 05                	jmp    80f66f <recv_tcp+0xcf>
  80f66a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f66f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f672:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f675:	89 ec                	mov    %ebp,%esp
  80f677:	5d                   	pop    %ebp
  80f678:	c3                   	ret    

0080f679 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f679:	55                   	push   %ebp
  80f67a:	89 e5                	mov    %esp,%ebp
  80f67c:	53                   	push   %ebx
  80f67d:	83 ec 14             	sub    $0x14,%esp
  80f680:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f683:	8b 03                	mov    (%ebx),%eax
  80f685:	8b 10                	mov    (%eax),%edx
  80f687:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f68d:	83 fa 20             	cmp    $0x20,%edx
  80f690:	75 0b                	jne    80f69d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80f692:	8b 40 08             	mov    0x8(%eax),%eax
  80f695:	89 04 24             	mov    %eax,(%esp)
  80f698:	e8 c3 c9 ff ff       	call   80c060 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f69d:	8b 03                	mov    (%ebx),%eax
  80f69f:	8b 40 10             	mov    0x10(%eax),%eax
  80f6a2:	89 04 24             	mov    %eax,(%esp)
  80f6a5:	e8 fd e4 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f6aa:	83 c4 14             	add    $0x14,%esp
  80f6ad:	5b                   	pop    %ebx
  80f6ae:	5d                   	pop    %ebp
  80f6af:	c3                   	ret    

0080f6b0 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f6b0:	55                   	push   %ebp
  80f6b1:	89 e5                	mov    %esp,%ebp
  80f6b3:	56                   	push   %esi
  80f6b4:	53                   	push   %ebx
  80f6b5:	83 ec 10             	sub    $0x10,%esp
  80f6b8:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f6bb:	8b 1e                	mov    (%esi),%ebx
  80f6bd:	8b 53 08             	mov    0x8(%ebx),%edx
  80f6c0:	85 d2                	test   %edx,%edx
  80f6c2:	75 10                	jne    80f6d4 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80f6c4:	8b 43 10             	mov    0x10(%ebx),%eax
  80f6c7:	89 04 24             	mov    %eax,(%esp)
  80f6ca:	e8 d8 e4 ff ff       	call   80dba7 <sys_sem_signal>
    return;
  80f6cf:	e9 9d 00 00 00       	jmp    80f771 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f6d4:	8b 03                	mov    (%ebx),%eax
  80f6d6:	25 f0 00 00 00       	and    $0xf0,%eax
  80f6db:	83 f8 20             	cmp    $0x20,%eax
  80f6de:	74 33                	je     80f713 <do_connect+0x63>
  80f6e0:	83 f8 40             	cmp    $0x40,%eax
  80f6e3:	74 0d                	je     80f6f2 <do_connect+0x42>
  80f6e5:	83 f8 10             	cmp    $0x10,%eax
  80f6e8:	0f 85 83 00 00 00    	jne    80f771 <do_connect+0xc1>
  80f6ee:	66 90                	xchg   %ax,%ax
  80f6f0:	eb 4a                	jmp    80f73c <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f6f2:	8b 46 04             	mov    0x4(%esi),%eax
  80f6f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f6f9:	89 14 24             	mov    %edx,(%esp)
  80f6fc:	e8 9c 22 00 00       	call   81199d <raw_connect>
  80f701:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f704:	8b 06                	mov    (%esi),%eax
  80f706:	8b 40 10             	mov    0x10(%eax),%eax
  80f709:	89 04 24             	mov    %eax,(%esp)
  80f70c:	e8 96 e4 ff ff       	call   80dba7 <sys_sem_signal>
    break;
  80f711:	eb 5e                	jmp    80f771 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f713:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f717:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f71b:	8b 46 04             	mov    0x4(%esi),%eax
  80f71e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f722:	89 14 24             	mov    %edx,(%esp)
  80f725:	e8 b4 ca ff ff       	call   80c1de <udp_connect>
  80f72a:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f72d:	8b 06                	mov    (%esi),%eax
  80f72f:	8b 40 10             	mov    0x10(%eax),%eax
  80f732:	89 04 24             	mov    %eax,(%esp)
  80f735:	e8 6d e4 ff ff       	call   80dba7 <sys_sem_signal>
    break;
  80f73a:	eb 35                	jmp    80f771 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f73c:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f743:	8b 06                	mov    (%esi),%eax
  80f745:	e8 de f5 ff ff       	call   80ed28 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f74a:	8b 1e                	mov    (%esi),%ebx
  80f74c:	c7 44 24 0c 8c ed 80 	movl   $0x80ed8c,0xc(%esp)
  80f753:	00 
  80f754:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f758:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f75c:	8b 46 04             	mov    0x4(%esi),%eax
  80f75f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f763:	8b 43 08             	mov    0x8(%ebx),%eax
  80f766:	89 04 24             	mov    %eax,(%esp)
  80f769:	e8 15 97 ff ff       	call   808e83 <tcp_connect>
  80f76e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f771:	83 c4 10             	add    $0x10,%esp
  80f774:	5b                   	pop    %ebx
  80f775:	5e                   	pop    %esi
  80f776:	5d                   	pop    %ebp
  80f777:	c3                   	ret    

0080f778 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f778:	55                   	push   %ebp
  80f779:	89 e5                	mov    %esp,%ebp
  80f77b:	83 ec 18             	sub    $0x18,%esp
  80f77e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f781:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f784:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f787:	8b 1e                	mov    (%esi),%ebx
  80f789:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f78d:	7c 73                	jl     80f802 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80f78f:	8b 53 08             	mov    0x8(%ebx),%edx
  80f792:	85 d2                	test   %edx,%edx
  80f794:	74 68                	je     80f7fe <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f796:	8b 03                	mov    (%ebx),%eax
  80f798:	25 f0 00 00 00       	and    $0xf0,%eax
  80f79d:	83 f8 20             	cmp    $0x20,%eax
  80f7a0:	74 24                	je     80f7c6 <do_bind+0x4e>
  80f7a2:	83 f8 40             	cmp    $0x40,%eax
  80f7a5:	74 0b                	je     80f7b2 <do_bind+0x3a>
  80f7a7:	83 f8 10             	cmp    $0x10,%eax
  80f7aa:	75 56                	jne    80f802 <do_bind+0x8a>
  80f7ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f7b0:	eb 30                	jmp    80f7e2 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f7b2:	8b 46 04             	mov    0x4(%esi),%eax
  80f7b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7b9:	89 14 24             	mov    %edx,(%esp)
  80f7bc:	e8 bf 21 00 00       	call   811980 <raw_bind>
  80f7c1:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f7c4:	eb 3c                	jmp    80f802 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f7c6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f7ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7ce:	8b 46 04             	mov    0x4(%esi),%eax
  80f7d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7d5:	89 14 24             	mov    %edx,(%esp)
  80f7d8:	e8 3b c9 ff ff       	call   80c118 <udp_bind>
  80f7dd:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f7e0:	eb 20                	jmp    80f802 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f7e2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f7e6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7ea:	8b 46 04             	mov    0x4(%esi),%eax
  80f7ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7f1:	89 14 24             	mov    %edx,(%esp)
  80f7f4:	e8 45 95 ff ff       	call   808d3e <tcp_bind>
  80f7f9:	88 43 0c             	mov    %al,0xc(%ebx)
  80f7fc:	eb 04                	jmp    80f802 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f7fe:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f802:	8b 06                	mov    (%esi),%eax
  80f804:	8b 40 10             	mov    0x10(%eax),%eax
  80f807:	89 04 24             	mov    %eax,(%esp)
  80f80a:	e8 98 e3 ff ff       	call   80dba7 <sys_sem_signal>
}
  80f80f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f812:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f815:	89 ec                	mov    %ebp,%esp
  80f817:	5d                   	pop    %ebp
  80f818:	c3                   	ret    

0080f819 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f819:	55                   	push   %ebp
  80f81a:	89 e5                	mov    %esp,%ebp
  80f81c:	53                   	push   %ebx
  80f81d:	83 ec 14             	sub    $0x14,%esp
  80f820:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f823:	8b 03                	mov    (%ebx),%eax
  80f825:	8b 48 08             	mov    0x8(%eax),%ecx
  80f828:	85 c9                	test   %ecx,%ecx
  80f82a:	74 51                	je     80f87d <do_delconn+0x64>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f82c:	8b 10                	mov    (%eax),%edx
  80f82e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f834:	83 fa 20             	cmp    $0x20,%edx
  80f837:	74 1e                	je     80f857 <do_delconn+0x3e>
  80f839:	83 fa 40             	cmp    $0x40,%edx
  80f83c:	74 0c                	je     80f84a <do_delconn+0x31>
  80f83e:	83 fa 10             	cmp    $0x10,%edx
  80f841:	75 3a                	jne    80f87d <do_delconn+0x64>
  80f843:	90                   	nop
  80f844:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f848:	eb 23                	jmp    80f86d <do_delconn+0x54>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f84a:	89 0c 24             	mov    %ecx,(%esp)
  80f84d:	8d 76 00             	lea    0x0(%esi),%esi
  80f850:	e8 d7 21 00 00       	call   811a2c <raw_remove>
      break;
  80f855:	eb 26                	jmp    80f87d <do_delconn+0x64>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f857:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80f85e:	8b 03                	mov    (%ebx),%eax
  80f860:	8b 40 08             	mov    0x8(%eax),%eax
  80f863:	89 04 24             	mov    %eax,(%esp)
  80f866:	e8 61 c8 ff ff       	call   80c0cc <udp_remove>
      break;
  80f86b:	eb 10                	jmp    80f87d <do_delconn+0x64>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f86d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f874:	8b 03                	mov    (%ebx),%eax
  80f876:	e8 58 f5 ff ff       	call   80edd3 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80f87b:	eb 4e                	jmp    80f8cb <do_delconn+0xb2>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f87d:	8b 13                	mov    (%ebx),%edx
  80f87f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f882:	85 c0                	test   %eax,%eax
  80f884:	74 33                	je     80f8b9 <do_delconn+0xa0>
  80f886:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f88d:	00 
  80f88e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f895:	00 
  80f896:	89 14 24             	mov    %edx,(%esp)
  80f899:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f89b:	8b 13                	mov    (%ebx),%edx
  80f89d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f8a0:	85 c0                	test   %eax,%eax
  80f8a2:	74 15                	je     80f8b9 <do_delconn+0xa0>
  80f8a4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f8ab:	00 
  80f8ac:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f8b3:	00 
  80f8b4:	89 14 24             	mov    %edx,(%esp)
  80f8b7:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f8b9:	8b 03                	mov    (%ebx),%eax
  80f8bb:	8b 40 10             	mov    0x10(%eax),%eax
  80f8be:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f8c1:	74 08                	je     80f8cb <do_delconn+0xb2>
    sys_sem_signal(msg->conn->op_completed);
  80f8c3:	89 04 24             	mov    %eax,(%esp)
  80f8c6:	e8 dc e2 ff ff       	call   80dba7 <sys_sem_signal>
  }
}
  80f8cb:	83 c4 14             	add    $0x14,%esp
  80f8ce:	5b                   	pop    %ebx
  80f8cf:	5d                   	pop    %ebp
  80f8d0:	c3                   	ret    

0080f8d1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f8d1:	55                   	push   %ebp
  80f8d2:	89 e5                	mov    %esp,%ebp
  80f8d4:	56                   	push   %esi
  80f8d5:	53                   	push   %ebx
  80f8d6:	83 ec 20             	sub    $0x20,%esp
  80f8d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f8dc:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f8e0:	74 1c                	je     80f8fe <netconn_free+0x2d>
  80f8e2:	c7 44 24 08 b4 4b 81 	movl   $0x814bb4,0x8(%esp)
  80f8e9:	00 
  80f8ea:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f8f1:	00 
  80f8f2:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f8f9:	e8 7e 10 ff ff       	call   80097c <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f8fe:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f901:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f905:	75 27                	jne    80f92e <netconn_free+0x5d>
  80f907:	eb 4b                	jmp    80f954 <netconn_free+0x83>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f909:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f90c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f910:	75 11                	jne    80f923 <netconn_free+0x52>
        if(mem != NULL) {
  80f912:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f915:	85 c0                	test   %eax,%eax
  80f917:	74 15                	je     80f92e <netconn_free+0x5d>
          pbuf_free((struct pbuf *)mem);
  80f919:	89 04 24             	mov    %eax,(%esp)
  80f91c:	e8 b7 85 ff ff       	call   807ed8 <pbuf_free>
  80f921:	eb 0b                	jmp    80f92e <netconn_free+0x5d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f923:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f926:	89 04 24             	mov    %eax,(%esp)
  80f929:	e8 d0 5c ff ff       	call   8055fe <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f92e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f932:	8b 43 14             	mov    0x14(%ebx),%eax
  80f935:	89 04 24             	mov    %eax,(%esp)
  80f938:	e8 d9 e3 ff ff       	call   80dd16 <sys_arch_mbox_tryfetch>
  80f93d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f940:	75 c7                	jne    80f909 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f942:	8b 43 14             	mov    0x14(%ebx),%eax
  80f945:	89 04 24             	mov    %eax,(%esp)
  80f948:	e8 8a dc ff ff       	call   80d5d7 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f94d:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f954:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f957:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f95b:	75 0d                	jne    80f96a <netconn_free+0x99>
  80f95d:	eb 31                	jmp    80f990 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f95f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f962:	89 04 24             	mov    %eax,(%esp)
  80f965:	e8 b1 f1 ff ff       	call   80eb1b <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f96a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f96e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f971:	89 04 24             	mov    %eax,(%esp)
  80f974:	e8 9d e3 ff ff       	call   80dd16 <sys_arch_mbox_tryfetch>
  80f979:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f97c:	75 e1                	jne    80f95f <netconn_free+0x8e>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f97e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f981:	89 04 24             	mov    %eax,(%esp)
  80f984:	e8 4e dc ff ff       	call   80d5d7 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80f989:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80f990:	8b 43 10             	mov    0x10(%ebx),%eax
  80f993:	89 04 24             	mov    %eax,(%esp)
  80f996:	e8 c8 db ff ff       	call   80d563 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80f99b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80f9a2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f9a6:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f9ad:	e8 8e 7d ff ff       	call   807740 <memp_free>
}
  80f9b2:	83 c4 20             	add    $0x20,%esp
  80f9b5:	5b                   	pop    %ebx
  80f9b6:	5e                   	pop    %esi
  80f9b7:	5d                   	pop    %ebp
  80f9b8:	c3                   	ret    

0080f9b9 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80f9b9:	55                   	push   %ebp
  80f9ba:	89 e5                	mov    %esp,%ebp
  80f9bc:	83 ec 38             	sub    $0x38,%esp
  80f9bf:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f9c2:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f9c5:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f9c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f9cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9ce:	8b 7d 10             	mov    0x10(%ebp),%edi
  80f9d1:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80f9d5:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80f9d9:	85 c0                	test   %eax,%eax
  80f9db:	75 1c                	jne    80f9f9 <recv_udp+0x40>
  80f9dd:	c7 44 24 08 e4 4b 81 	movl   $0x814be4,0x8(%esp)
  80f9e4:	00 
  80f9e5:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80f9ec:	00 
  80f9ed:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80f9f4:	e8 83 0f ff ff       	call   80097c <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80f9f9:	85 db                	test   %ebx,%ebx
  80f9fb:	75 1c                	jne    80fa19 <recv_udp+0x60>
  80f9fd:	c7 44 24 08 08 4c 81 	movl   $0x814c08,0x8(%esp)
  80fa04:	00 
  80fa05:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80fa0c:	00 
  80fa0d:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80fa14:	e8 63 0f ff ff       	call   80097c <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80fa19:	39 43 08             	cmp    %eax,0x8(%ebx)
  80fa1c:	74 1c                	je     80fa3a <recv_udp+0x81>
  80fa1e:	c7 44 24 08 09 4b 81 	movl   $0x814b09,0x8(%esp)
  80fa25:	00 
  80fa26:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80fa2d:	00 
  80fa2e:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80fa35:	e8 42 0f ff ff       	call   80097c <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80fa3a:	85 db                	test   %ebx,%ebx
  80fa3c:	74 06                	je     80fa44 <recv_udp+0x8b>
  80fa3e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80fa42:	75 0e                	jne    80fa52 <recv_udp+0x99>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80fa44:	89 3c 24             	mov    %edi,(%esp)
  80fa47:	e8 8c 84 ff ff       	call   807ed8 <pbuf_free>
    return;
  80fa4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80fa50:	eb 6e                	jmp    80fac0 <recv_udp+0x107>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80fa52:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fa59:	e8 26 7d ff ff       	call   807784 <memp_malloc>
  80fa5e:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80fa60:	85 c0                	test   %eax,%eax
  80fa62:	75 0a                	jne    80fa6e <recv_udp+0xb5>
    pbuf_free(p);
  80fa64:	89 3c 24             	mov    %edi,(%esp)
  80fa67:	e8 6c 84 ff ff       	call   807ed8 <pbuf_free>
    return;
  80fa6c:	eb 52                	jmp    80fac0 <recv_udp+0x107>
  } else {
    buf->p = p;
  80fa6e:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80fa70:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80fa73:	8b 45 14             	mov    0x14(%ebp),%eax
  80fa76:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80fa79:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80fa7d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80fa81:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fa85:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80fa89:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fa8c:	85 c0                	test   %eax,%eax
  80fa8e:	74 15                	je     80faa5 <recv_udp+0xec>
  80fa90:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80fa94:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fa98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fa9f:	00 
  80faa0:	89 1c 24             	mov    %ebx,(%esp)
  80faa3:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80faa5:	89 74 24 04          	mov    %esi,0x4(%esp)
  80faa9:	8b 43 14             	mov    0x14(%ebx),%eax
  80faac:	89 04 24             	mov    %eax,(%esp)
  80faaf:	e8 84 e2 ff ff       	call   80dd38 <sys_mbox_trypost>
  80fab4:	84 c0                	test   %al,%al
  80fab6:	74 08                	je     80fac0 <recv_udp+0x107>
    netbuf_delete(buf);
  80fab8:	89 34 24             	mov    %esi,(%esp)
  80fabb:	e8 3e 5b ff ff       	call   8055fe <netbuf_delete>
    return;
  }
}
  80fac0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fac3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fac6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fac9:	89 ec                	mov    %ebp,%esp
  80facb:	5d                   	pop    %ebp
  80facc:	c3                   	ret    

0080facd <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80facd:	55                   	push   %ebp
  80face:	89 e5                	mov    %esp,%ebp
  80fad0:	53                   	push   %ebx
  80fad1:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80fad4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fadb:	e8 a4 7c ff ff       	call   807784 <memp_malloc>
  80fae0:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80fae2:	85 c0                	test   %eax,%eax
  80fae4:	0f 84 92 00 00 00    	je     80fb7c <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80faea:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80faee:	8b 45 08             	mov    0x8(%ebp),%eax
  80faf1:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80faf3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80fafa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fb01:	e8 ff de ff ff       	call   80da05 <sys_sem_new>
  80fb06:	89 43 10             	mov    %eax,0x10(%ebx)
  80fb09:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fb0c:	75 17                	jne    80fb25 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80fb0e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fb12:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fb19:	e8 22 7c ff ff       	call   807740 <memp_free>
  80fb1e:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fb23:	eb 57                	jmp    80fb7c <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80fb25:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fb2c:	e8 5e df ff ff       	call   80da8f <sys_mbox_new>
  80fb31:	89 43 14             	mov    %eax,0x14(%ebx)
  80fb34:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fb37:	75 22                	jne    80fb5b <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80fb39:	8b 43 10             	mov    0x10(%ebx),%eax
  80fb3c:	89 04 24             	mov    %eax,(%esp)
  80fb3f:	e8 1f da ff ff       	call   80d563 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80fb44:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fb48:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fb4f:	e8 ec 7b ff ff       	call   807740 <memp_free>
  80fb54:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fb59:	eb 21                	jmp    80fb7c <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80fb5b:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80fb62:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80fb69:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80fb70:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb73:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80fb76:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80fb7c:	89 d8                	mov    %ebx,%eax
  80fb7e:	83 c4 14             	add    $0x14,%esp
  80fb81:	5b                   	pop    %ebx
  80fb82:	5d                   	pop    %ebp
  80fb83:	c3                   	ret    

0080fb84 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80fb84:	55                   	push   %ebp
  80fb85:	89 e5                	mov    %esp,%ebp
  80fb87:	83 ec 28             	sub    $0x28,%esp
  80fb8a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fb8d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fb90:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fb93:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80fb97:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80fb9a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80fb9e:	75 1c                	jne    80fbbc <accept_function+0x38>
  80fba0:	c7 44 24 08 28 4c 81 	movl   $0x814c28,0x8(%esp)
  80fba7:	00 
  80fba8:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80fbaf:	00 
  80fbb0:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80fbb7:	e8 c0 0d ff ff       	call   80097c <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80fbbc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fbbf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fbc3:	8b 03                	mov    (%ebx),%eax
  80fbc5:	89 04 24             	mov    %eax,(%esp)
  80fbc8:	e8 00 ff ff ff       	call   80facd <netconn_alloc>
  80fbcd:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80fbcf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80fbd4:	85 f6                	test   %esi,%esi
  80fbd6:	74 55                	je     80fc2d <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80fbd8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fbdb:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80fbde:	89 f0                	mov    %esi,%eax
  80fbe0:	e8 43 f1 ff ff       	call   80ed28 <setup_tcp>
  newconn->err = err;
  80fbe5:	89 f8                	mov    %edi,%eax
  80fbe7:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80fbea:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fbed:	85 c0                	test   %eax,%eax
  80fbef:	74 15                	je     80fc06 <accept_function+0x82>
  80fbf1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fbf8:	00 
  80fbf9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fc00:	00 
  80fc01:	89 1c 24             	mov    %ebx,(%esp)
  80fc04:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80fc06:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fc0a:	8b 43 18             	mov    0x18(%ebx),%eax
  80fc0d:	89 04 24             	mov    %eax,(%esp)
  80fc10:	e8 23 e1 ff ff       	call   80dd38 <sys_mbox_trypost>
  80fc15:	84 c0                	test   %al,%al
  80fc17:	74 14                	je     80fc2d <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80fc19:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80fc20:	89 34 24             	mov    %esi,(%esp)
  80fc23:	e8 a9 fc ff ff       	call   80f8d1 <netconn_free>
  80fc28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80fc2d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fc30:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fc33:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fc36:	89 ec                	mov    %ebp,%esp
  80fc38:	5d                   	pop    %ebp
  80fc39:	c3                   	ret    

0080fc3a <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80fc3a:	55                   	push   %ebp
  80fc3b:	89 e5                	mov    %esp,%ebp
  80fc3d:	83 ec 18             	sub    $0x18,%esp
  80fc40:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80fc43:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80fc46:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80fc49:	8b 03                	mov    (%ebx),%eax
  80fc4b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fc4f:	0f 85 d5 00 00 00    	jne    80fd2a <do_newconn+0xf0>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80fc55:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80fc59:	8b 33                	mov    (%ebx),%esi
  80fc5b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80fc5f:	74 1c                	je     80fc7d <do_newconn+0x43>
  80fc61:	c7 44 24 08 54 4c 81 	movl   $0x814c54,0x8(%esp)
  80fc68:	00 
  80fc69:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80fc70:	00 
  80fc71:	c7 04 24 45 4a 81 00 	movl   $0x814a45,(%esp)
  80fc78:	e8 ff 0c ff ff       	call   80097c <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80fc7d:	8b 06                	mov    (%esi),%eax
  80fc7f:	25 f0 00 00 00       	and    $0xf0,%eax
  80fc84:	83 f8 20             	cmp    $0x20,%eax
  80fc87:	74 45                	je     80fcce <do_newconn+0x94>
  80fc89:	83 f8 40             	cmp    $0x40,%eax
  80fc8c:	74 0c                	je     80fc9a <do_newconn+0x60>
  80fc8e:	83 f8 10             	cmp    $0x10,%eax
  80fc91:	0f 85 8f 00 00 00    	jne    80fd26 <do_newconn+0xec>
  80fc97:	90                   	nop
  80fc98:	eb 6f                	jmp    80fd09 <do_newconn+0xcf>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80fc9a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80fc9e:	89 04 24             	mov    %eax,(%esp)
  80fca1:	e8 29 1d 00 00       	call   8119cf <raw_new>
  80fca6:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80fca9:	8b 03                	mov    (%ebx),%eax
  80fcab:	8b 50 08             	mov    0x8(%eax),%edx
  80fcae:	85 d2                	test   %edx,%edx
  80fcb0:	75 06                	jne    80fcb8 <do_newconn+0x7e>
       msg->conn->err = ERR_MEM;
  80fcb2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fcb6:	eb 72                	jmp    80fd2a <do_newconn+0xf0>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80fcb8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fcbc:	c7 44 24 04 41 fd 80 	movl   $0x80fd41,0x4(%esp)
  80fcc3:	00 
  80fcc4:	89 14 24             	mov    %edx,(%esp)
  80fcc7:	e8 ef 1c 00 00       	call   8119bb <raw_recv>
  80fccc:	eb 5c                	jmp    80fd2a <do_newconn+0xf0>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80fcce:	e8 bc c3 ff ff       	call   80c08f <udp_new>
  80fcd3:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80fcd6:	8b 03                	mov    (%ebx),%eax
  80fcd8:	8b 50 08             	mov    0x8(%eax),%edx
  80fcdb:	85 d2                	test   %edx,%edx
  80fcdd:	75 06                	jne    80fce5 <do_newconn+0xab>
       msg->conn->err = ERR_MEM;
  80fcdf:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fce3:	eb 45                	jmp    80fd2a <do_newconn+0xf0>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80fce5:	83 38 22             	cmpl   $0x22,(%eax)
  80fce8:	75 04                	jne    80fcee <do_newconn+0xb4>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80fcea:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80fcee:	8b 03                	mov    (%ebx),%eax
  80fcf0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fcf4:	c7 44 24 04 b9 f9 80 	movl   $0x80f9b9,0x4(%esp)
  80fcfb:	00 
  80fcfc:	8b 40 08             	mov    0x8(%eax),%eax
  80fcff:	89 04 24             	mov    %eax,(%esp)
  80fd02:	e8 74 c3 ff ff       	call   80c07b <udp_recv>
  80fd07:	eb 21                	jmp    80fd2a <do_newconn+0xf0>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80fd09:	e8 9c 95 ff ff       	call   8092aa <tcp_new>
  80fd0e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80fd11:	8b 03                	mov    (%ebx),%eax
  80fd13:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fd17:	75 06                	jne    80fd1f <do_newconn+0xe5>
       msg->conn->err = ERR_MEM;
  80fd19:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fd1d:	eb 0b                	jmp    80fd2a <do_newconn+0xf0>
       break;
     }
     setup_tcp(msg->conn);
  80fd1f:	e8 04 f0 ff ff       	call   80ed28 <setup_tcp>
  80fd24:	eb 04                	jmp    80fd2a <do_newconn+0xf0>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80fd26:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80fd2a:	8b 03                	mov    (%ebx),%eax
  80fd2c:	8b 40 10             	mov    0x10(%eax),%eax
  80fd2f:	89 04 24             	mov    %eax,(%esp)
  80fd32:	e8 70 de ff ff       	call   80dba7 <sys_sem_signal>
}
  80fd37:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80fd3a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80fd3d:	89 ec                	mov    %ebp,%esp
  80fd3f:	5d                   	pop    %ebp
  80fd40:	c3                   	ret    

0080fd41 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80fd41:	55                   	push   %ebp
  80fd42:	89 e5                	mov    %esp,%ebp
  80fd44:	83 ec 28             	sub    $0x28,%esp
  80fd47:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fd4a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fd4d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fd50:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80fd53:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80fd56:	85 db                	test   %ebx,%ebx
  80fd58:	0f 84 b0 00 00 00    	je     80fe0e <recv_raw+0xcd>
  80fd5e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80fd62:	0f 84 a6 00 00 00    	je     80fe0e <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80fd68:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fd6f:	00 
  80fd70:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fd74:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fd78:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80fd7f:	e8 0f 84 ff ff       	call   808193 <pbuf_alloc>
  80fd84:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80fd86:	85 c0                	test   %eax,%eax
  80fd88:	0f 84 80 00 00 00    	je     80fe0e <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80fd8e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fd92:	89 04 24             	mov    %eax,(%esp)
  80fd95:	e8 8b 7f ff ff       	call   807d25 <pbuf_copy>
  80fd9a:	84 c0                	test   %al,%al
  80fd9c:	0f 84 7e 00 00 00    	je     80fe20 <recv_raw+0xdf>
        pbuf_free(q);
  80fda2:	89 34 24             	mov    %esi,(%esp)
  80fda5:	e8 2e 81 ff ff       	call   807ed8 <pbuf_free>
  80fdaa:	eb 62                	jmp    80fe0e <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80fdac:	89 34 24             	mov    %esi,(%esp)
  80fdaf:	e8 24 81 ff ff       	call   807ed8 <pbuf_free>
        return 0;
  80fdb4:	eb 58                	jmp    80fe0e <recv_raw+0xcd>
      }

      buf->p = q;
  80fdb6:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80fdb8:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80fdbb:	8b 46 04             	mov    0x4(%esi),%eax
  80fdbe:	83 c0 0c             	add    $0xc,%eax
  80fdc1:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80fdc4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fdc7:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80fdcb:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80fdcf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80fdd3:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80fdd7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fdda:	85 c0                	test   %eax,%eax
  80fddc:	74 15                	je     80fdf3 <recv_raw+0xb2>
  80fdde:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80fde2:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fde6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fded:	00 
  80fdee:	89 1c 24             	mov    %ebx,(%esp)
  80fdf1:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fdf3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fdf7:	8b 43 14             	mov    0x14(%ebx),%eax
  80fdfa:	89 04 24             	mov    %eax,(%esp)
  80fdfd:	e8 36 df ff ff       	call   80dd38 <sys_mbox_trypost>
  80fe02:	84 c0                	test   %al,%al
  80fe04:	74 08                	je     80fe0e <recv_raw+0xcd>
        netbuf_delete(buf);
  80fe06:	89 3c 24             	mov    %edi,(%esp)
  80fe09:	e8 f0 57 ff ff       	call   8055fe <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80fe0e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe13:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fe16:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fe19:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fe1c:	89 ec                	mov    %ebp,%esp
  80fe1e:	5d                   	pop    %ebp
  80fe1f:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80fe20:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fe27:	e8 58 79 ff ff       	call   807784 <memp_malloc>
  80fe2c:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80fe2e:	85 c0                	test   %eax,%eax
  80fe30:	75 84                	jne    80fdb6 <recv_raw+0x75>
  80fe32:	e9 75 ff ff ff       	jmp    80fdac <recv_raw+0x6b>
	...

0080fe40 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80fe40:	55                   	push   %ebp
  80fe41:	89 e5                	mov    %esp,%ebp
  80fe43:	57                   	push   %edi
  80fe44:	56                   	push   %esi
  80fe45:	53                   	push   %ebx
  80fe46:	83 ec 1c             	sub    $0x1c,%esp
  80fe49:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80fe4b:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  80fe50:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80fe53:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fe57:	89 04 24             	mov    %eax,(%esp)
  80fe5a:	e8 82 ae ff ff       	call   80ace1 <ntohs>
  80fe5f:	66 c1 e8 0c          	shr    $0xc,%ax
  80fe63:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe68:	66 83 f8 05          	cmp    $0x5,%ax
  80fe6c:	77 53                	ja     80fec1 <tcp_parseopt+0x81>
  80fe6e:	eb 77                	jmp    80fee7 <tcp_parseopt+0xa7>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80fe70:	0f b6 d3             	movzbl %bl,%edx
  80fe73:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80fe77:	84 c0                	test   %al,%al
  80fe79:	74 6c                	je     80fee7 <tcp_parseopt+0xa7>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80fe7b:	3c 01                	cmp    $0x1,%al
  80fe7d:	8d 76 00             	lea    0x0(%esi),%esi
  80fe80:	75 05                	jne    80fe87 <tcp_parseopt+0x47>
        ++c;
  80fe82:	83 c3 01             	add    $0x1,%ebx
  80fe85:	eb 3a                	jmp    80fec1 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80fe87:	3c 02                	cmp    $0x2,%al
  80fe89:	75 2b                	jne    80feb6 <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
  80fe8b:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80fe90:	75 24                	jne    80feb6 <tcp_parseopt+0x76>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80fe92:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80fe97:	c1 e0 08             	shl    $0x8,%eax
  80fe9a:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80fe9f:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80fea1:	8d 50 ff             	lea    -0x1(%eax),%edx
  80fea4:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80fea9:	76 05                	jbe    80feb0 <tcp_parseopt+0x70>
  80feab:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80feb0:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80feb4:	eb 31                	jmp    80fee7 <tcp_parseopt+0xa7>
      } else {
        if (opts[c + 1] == 0) {
  80feb6:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80febb:	84 c0                	test   %al,%al
  80febd:	74 28                	je     80fee7 <tcp_parseopt+0xa7>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80febf:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80fec1:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  80fec6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80feca:	89 04 24             	mov    %eax,(%esp)
  80fecd:	e8 0f ae ff ff       	call   80ace1 <ntohs>
  80fed2:	0f b6 d3             	movzbl %bl,%edx
  80fed5:	66 c1 e8 0c          	shr    $0xc,%ax
  80fed9:	0f b7 c0             	movzwl %ax,%eax
  80fedc:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80fee3:	39 c2                	cmp    %eax,%edx
  80fee5:	7c 89                	jl     80fe70 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80fee7:	83 c4 1c             	add    $0x1c,%esp
  80feea:	5b                   	pop    %ebx
  80feeb:	5e                   	pop    %esi
  80feec:	5f                   	pop    %edi
  80feed:	5d                   	pop    %ebp
  80feee:	c3                   	ret    

0080feef <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80feef:	55                   	push   %ebp
  80fef0:	89 e5                	mov    %esp,%ebp
  80fef2:	57                   	push   %edi
  80fef3:	56                   	push   %esi
  80fef4:	53                   	push   %ebx
  80fef5:	83 ec 2c             	sub    $0x2c,%esp
  80fef8:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80fefa:	f6 05 80 e5 b3 00 10 	testb  $0x10,0xb3e580
  80ff01:	0f 84 6d 04 00 00    	je     810374 <tcp_receive+0x485>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ff07:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80ff0b:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ff0e:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  80ff13:	39 c2                	cmp    %eax,%edx
  80ff15:	78 24                	js     80ff3b <tcp_receive+0x4c>
  80ff17:	39 c2                	cmp    %eax,%edx
  80ff19:	75 0a                	jne    80ff25 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ff1b:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  80ff20:	39 43 64             	cmp    %eax,0x64(%ebx)
  80ff23:	78 16                	js     80ff3b <tcp_receive+0x4c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ff25:	8b 43 64             	mov    0x64(%ebx),%eax
  80ff28:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  80ff2e:	75 3f                	jne    80ff6f <tcp_receive+0x80>
  80ff30:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  80ff35:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80ff39:	73 34                	jae    80ff6f <tcp_receive+0x80>
      pcb->snd_wnd = tcphdr->wnd;
  80ff3b:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  80ff40:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80ff44:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80ff48:	8b 0d 78 e5 b3 00    	mov    0xb3e578,%ecx
  80ff4e:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80ff51:	8b 0d 7c e5 b3 00    	mov    0xb3e57c,%ecx
  80ff57:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ff5a:	66 85 c0             	test   %ax,%ax
  80ff5d:	74 10                	je     80ff6f <tcp_receive+0x80>
  80ff5f:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80ff66:	74 07                	je     80ff6f <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80ff68:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80ff6f:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80ff72:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  80ff77:	39 c1                	cmp    %eax,%ecx
  80ff79:	0f 85 ac 00 00 00    	jne    81002b <tcp_receive+0x13c>
      pcb->acked = 0;
  80ff7f:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80ff85:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80ff89:	03 43 60             	add    0x60(%ebx),%eax
  80ff8c:	0f b7 f6             	movzwl %si,%esi
  80ff8f:	8d 14 16             	lea    (%esi,%edx,1),%edx
  80ff92:	39 d0                	cmp    %edx,%eax
  80ff94:	0f 85 ff 02 00 00    	jne    810299 <tcp_receive+0x3aa>
        ++pcb->dupacks;
  80ff9a:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  80ff9e:	83 c0 01             	add    $0x1,%eax
  80ffa1:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80ffa4:	3c 02                	cmp    $0x2,%al
  80ffa6:	0f 86 ed 02 00 00    	jbe    810299 <tcp_receive+0x3aa>
  80ffac:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80ffb0:	0f 84 e3 02 00 00    	je     810299 <tcp_receive+0x3aa>
          if (!(pcb->flags & TF_INFR)) {
  80ffb6:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80ffba:	75 53                	jne    81000f <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80ffbc:	89 1c 24             	mov    %ebx,(%esp)
  80ffbf:	90                   	nop
  80ffc0:	e8 43 b8 ff ff       	call   80b808 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80ffc5:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80ffc9:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  80ffcd:	66 39 d0             	cmp    %dx,%ax
  80ffd0:	76 09                	jbe    80ffdb <tcp_receive+0xec>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80ffd2:	66 d1 ea             	shr    %dx
  80ffd5:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80ffd9:	eb 07                	jmp    80ffe2 <tcp_receive+0xf3>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80ffdb:	66 d1 e8             	shr    %ax
  80ffde:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80ffe2:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80ffe6:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80ffea:	0f b7 d0             	movzwl %ax,%edx
  80ffed:	01 d2                	add    %edx,%edx
  80ffef:	39 d1                	cmp    %edx,%ecx
  80fff1:	7d 06                	jge    80fff9 <tcp_receive+0x10a>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80fff3:	01 c0                	add    %eax,%eax
  80fff5:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80fff9:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  80fffe:	66 03 43 50          	add    0x50(%ebx),%ax
  810002:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  810006:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  81000a:	e9 8a 02 00 00       	jmp    810299 <tcp_receive+0x3aa>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81000f:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  810013:	89 d0                	mov    %edx,%eax
  810015:	66 03 43 34          	add    0x34(%ebx),%ax
  810019:	66 39 c2             	cmp    %ax,%dx
  81001c:	0f 83 77 02 00 00    	jae    810299 <tcp_receive+0x3aa>
              pcb->cwnd += pcb->mss;
  810022:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  810026:	e9 6e 02 00 00       	jmp    810299 <tcp_receive+0x3aa>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81002b:	f7 d1                	not    %ecx
  81002d:	01 c1                	add    %eax,%ecx
  81002f:	0f 88 b2 01 00 00    	js     8101e7 <tcp_receive+0x2f8>
  810035:	2b 43 58             	sub    0x58(%ebx),%eax
  810038:	85 c0                	test   %eax,%eax
  81003a:	0f 8f a7 01 00 00    	jg     8101e7 <tcp_receive+0x2f8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  810040:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  810044:	a8 04                	test   $0x4,%al
  810046:	74 0e                	je     810056 <tcp_receive+0x167>
        pcb->flags &= ~TF_INFR;
  810048:	83 e0 fb             	and    $0xfffffffb,%eax
  81004b:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  81004e:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  810052:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  810056:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81005a:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  81005e:	66 c1 f8 03          	sar    $0x3,%ax
  810062:	66 03 43 42          	add    0x42(%ebx),%ax
  810066:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81006a:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  81006f:	66 2b 43 48          	sub    0x48(%ebx),%ax
  810073:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  810077:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81007b:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  81007f:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  810084:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  810087:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  81008b:	0f 86 d3 00 00 00    	jbe    810164 <tcp_receive+0x275>
        if (pcb->cwnd < pcb->ssthresh) {
  810091:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  810095:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  810099:	73 18                	jae    8100b3 <tcp_receive+0x1c4>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81009b:	89 c8                	mov    %ecx,%eax
  81009d:	66 03 43 34          	add    0x34(%ebx),%ax
  8100a1:	66 39 c1             	cmp    %ax,%cx
  8100a4:	0f 83 ba 00 00 00    	jae    810164 <tcp_receive+0x275>
            pcb->cwnd += pcb->mss;
  8100aa:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  8100ae:	e9 b1 00 00 00       	jmp    810164 <tcp_receive+0x275>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  8100b3:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  8100b7:	0f af d2             	imul   %edx,%edx
  8100ba:	0f b7 f1             	movzwl %cx,%esi
  8100bd:	89 d0                	mov    %edx,%eax
  8100bf:	c1 fa 1f             	sar    $0x1f,%edx
  8100c2:	f7 fe                	idiv   %esi
  8100c4:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  8100c7:	66 39 c1             	cmp    %ax,%cx
  8100ca:	0f 83 94 00 00 00    	jae    810164 <tcp_receive+0x275>
            pcb->cwnd = new_cwnd;
  8100d0:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  8100d4:	e9 8b 00 00 00       	jmp    810164 <tcp_receive+0x275>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  8100d9:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  8100dc:	8b 06                	mov    (%esi),%eax
  8100de:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  8100e1:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  8100e5:	8b 46 04             	mov    0x4(%esi),%eax
  8100e8:	89 04 24             	mov    %eax,(%esp)
  8100eb:	e8 80 79 ff ff       	call   807a70 <pbuf_clen>
  8100f0:	0f b6 c0             	movzbl %al,%eax
  8100f3:	66 39 c7             	cmp    %ax,%di
  8100f6:	73 1c                	jae    810114 <tcp_receive+0x225>
  8100f8:	c7 44 24 08 74 4c 81 	movl   $0x814c74,0x8(%esp)
  8100ff:	00 
  810100:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  810107:	00 
  810108:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81010f:	e8 68 08 ff ff       	call   80097c <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  810114:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810118:	8b 46 04             	mov    0x4(%esi),%eax
  81011b:	89 04 24             	mov    %eax,(%esp)
  81011e:	e8 4d 79 ff ff       	call   807a70 <pbuf_clen>
  810123:	0f b6 c0             	movzbl %al,%eax
  810126:	66 29 c7             	sub    %ax,%di
  810129:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  81012d:	89 34 24             	mov    %esi,(%esp)
  810130:	e8 1c 89 ff ff       	call   808a51 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  810135:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  81013a:	74 28                	je     810164 <tcp_receive+0x275>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81013c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  810140:	75 22                	jne    810164 <tcp_receive+0x275>
  810142:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  810146:	75 1c                	jne    810164 <tcp_receive+0x275>
  810148:	c7 44 24 08 9c 4c 81 	movl   $0x814c9c,0x8(%esp)
  81014f:	00 
  810150:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  810157:	00 
  810158:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81015f:	e8 18 08 ff ff       	call   80097c <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  810164:	8b 43 78             	mov    0x78(%ebx),%eax
  810167:	85 c0                	test   %eax,%eax
  810169:	74 65                	je     8101d0 <tcp_receive+0x2e1>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81016b:	8b 40 10             	mov    0x10(%eax),%eax
  81016e:	8b 40 04             	mov    0x4(%eax),%eax
  810171:	89 04 24             	mov    %eax,(%esp)
  810174:	e8 a1 ad ff ff       	call   80af1a <ntohl>
  810179:	89 c6                	mov    %eax,%esi
  81017b:	8b 43 78             	mov    0x78(%ebx),%eax
  81017e:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  810182:	8b 40 10             	mov    0x10(%eax),%eax
  810185:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810189:	89 04 24             	mov    %eax,(%esp)
  81018c:	e8 50 ab ff ff       	call   80ace1 <ntohs>
  810191:	a8 01                	test   $0x1,%al
  810193:	75 1b                	jne    8101b0 <tcp_receive+0x2c1>
  810195:	8b 43 78             	mov    0x78(%ebx),%eax
  810198:	8b 40 10             	mov    0x10(%eax),%eax
  81019b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81019f:	89 04 24             	mov    %eax,(%esp)
  8101a2:	e8 3a ab ff ff       	call   80ace1 <ntohs>
  8101a7:	ba 00 00 00 00       	mov    $0x0,%edx
  8101ac:	a8 02                	test   $0x2,%al
  8101ae:	74 05                	je     8101b5 <tcp_receive+0x2c6>
  8101b0:	ba 01 00 00 00       	mov    $0x1,%edx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  8101b5:	2b 35 7c e5 b3 00    	sub    0xb3e57c,%esi
  8101bb:	0f b7 ff             	movzwl %di,%edi
  8101be:	01 fa                	add    %edi,%edx
  8101c0:	01 d6                	add    %edx,%esi
  8101c2:	85 f6                	test   %esi,%esi
  8101c4:	0f 8e 0f ff ff ff    	jle    8100d9 <tcp_receive+0x1ea>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  8101ca:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8101ce:	75 08                	jne    8101d8 <tcp_receive+0x2e9>
        pcb->rtime = -1;
  8101d0:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  8101d6:	eb 06                	jmp    8101de <tcp_receive+0x2ef>
      else
        pcb->rtime = 0;
  8101d8:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  8101de:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  8101e2:	e9 b2 00 00 00       	jmp    810299 <tcp_receive+0x3aa>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  8101e7:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  8101ed:	8d 76 00             	lea    0x0(%esi),%esi
  8101f0:	e9 a4 00 00 00       	jmp    810299 <tcp_receive+0x3aa>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  8101f5:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  8101f8:	8b 06                	mov    (%esi),%eax
  8101fa:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  8101fd:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810201:	8b 46 04             	mov    0x4(%esi),%eax
  810204:	89 04 24             	mov    %eax,(%esp)
  810207:	e8 64 78 ff ff       	call   807a70 <pbuf_clen>
  81020c:	0f b6 c0             	movzbl %al,%eax
  81020f:	66 39 c7             	cmp    %ax,%di
  810212:	73 1c                	jae    810230 <tcp_receive+0x341>
  810214:	c7 44 24 08 74 4c 81 	movl   $0x814c74,0x8(%esp)
  81021b:	00 
  81021c:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  810223:	00 
  810224:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81022b:	e8 4c 07 ff ff       	call   80097c <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  810230:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810234:	8b 46 04             	mov    0x4(%esi),%eax
  810237:	89 04 24             	mov    %eax,(%esp)
  81023a:	e8 31 78 ff ff       	call   807a70 <pbuf_clen>
  81023f:	0f b6 c0             	movzbl %al,%eax
  810242:	66 29 c7             	sub    %ax,%di
  810245:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  810249:	89 34 24             	mov    %esi,(%esp)
  81024c:	e8 00 88 ff ff       	call   808a51 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  810251:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  810256:	74 29                	je     810281 <tcp_receive+0x392>
        LWIP_ASSERT("tcp_receive: valid queue length",
  810258:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  81025c:	75 23                	jne    810281 <tcp_receive+0x392>
  81025e:	8b 43 74             	mov    0x74(%ebx),%eax
  810261:	85 c0                	test   %eax,%eax
  810263:	75 23                	jne    810288 <tcp_receive+0x399>
  810265:	c7 44 24 08 9c 4c 81 	movl   $0x814c9c,0x8(%esp)
  81026c:	00 
  81026d:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  810274:	00 
  810275:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81027c:	e8 fb 06 ff ff       	call   80097c <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  810281:	8b 43 74             	mov    0x74(%ebx),%eax
  810284:	85 c0                	test   %eax,%eax
  810286:	74 11                	je     810299 <tcp_receive+0x3aa>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  810288:	8b 40 10             	mov    0x10(%eax),%eax
  81028b:	8b 40 04             	mov    0x4(%eax),%eax
  81028e:	89 04 24             	mov    %eax,(%esp)
  810291:	e8 5f aa ff ff       	call   80acf5 <htonl>
  810296:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  810299:	8b 43 74             	mov    0x74(%ebx),%eax
  81029c:	85 c0                	test   %eax,%eax
  81029e:	74 70                	je     810310 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  8102a0:	8b 35 7c e5 b3 00    	mov    0xb3e57c,%esi
  8102a6:	8b 40 10             	mov    0x10(%eax),%eax
  8102a9:	8b 40 04             	mov    0x4(%eax),%eax
  8102ac:	89 04 24             	mov    %eax,(%esp)
  8102af:	e8 66 ac ff ff       	call   80af1a <ntohl>
  8102b4:	89 c7                	mov    %eax,%edi
  8102b6:	8b 43 74             	mov    0x74(%ebx),%eax
  8102b9:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  8102bd:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  8102c1:	8b 40 10             	mov    0x10(%eax),%eax
  8102c4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102c8:	89 04 24             	mov    %eax,(%esp)
  8102cb:	e8 11 aa ff ff       	call   80ace1 <ntohs>
  8102d0:	a8 01                	test   $0x1,%al
  8102d2:	75 1b                	jne    8102ef <tcp_receive+0x400>
  8102d4:	8b 43 74             	mov    0x74(%ebx),%eax
  8102d7:	8b 40 10             	mov    0x10(%eax),%eax
  8102da:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102de:	89 04 24             	mov    %eax,(%esp)
  8102e1:	e8 fb a9 ff ff       	call   80ace1 <ntohs>
  8102e6:	ba 00 00 00 00       	mov    $0x0,%edx
  8102eb:	a8 02                	test   $0x2,%al
  8102ed:	74 05                	je     8102f4 <tcp_receive+0x405>
  8102ef:	ba 01 00 00 00       	mov    $0x1,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  8102f4:	29 fe                	sub    %edi,%esi
  8102f6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8102fa:	01 c2                	add    %eax,%edx
  8102fc:	39 d6                	cmp    %edx,%esi
  8102fe:	78 10                	js     810310 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  810300:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  810305:	2b 43 58             	sub    0x58(%ebx),%eax
  810308:	85 c0                	test   %eax,%eax
  81030a:	0f 8e e5 fe ff ff    	jle    8101f5 <tcp_receive+0x306>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  810310:	8b 43 38             	mov    0x38(%ebx),%eax
  810313:	85 c0                	test   %eax,%eax
  810315:	74 5d                	je     810374 <tcp_receive+0x485>
  810317:	8b 35 7c e5 b3 00    	mov    0xb3e57c,%esi
  81031d:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  810320:	79 52                	jns    810374 <tcp_receive+0x485>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  810322:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  810326:	8b 0d 0c e6 b3 00    	mov    0xb3e60c,%ecx
  81032c:	66 29 c1             	sub    %ax,%cx
  81032f:	89 c8                	mov    %ecx,%eax
  810331:	89 d1                	mov    %edx,%ecx
  810333:	66 c1 f9 03          	sar    $0x3,%cx
  810337:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  81033a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  81033d:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  810341:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  810345:	89 ce                	mov    %ecx,%esi
  810347:	66 c1 fe 02          	sar    $0x2,%si
  81034b:	66 29 f1             	sub    %si,%cx
  81034e:	89 ce                	mov    %ecx,%esi
  810350:	89 c1                	mov    %eax,%ecx
  810352:	66 c1 f9 0f          	sar    $0xf,%cx
  810356:	31 c8                	xor    %ecx,%eax
  810358:	66 29 c8             	sub    %cx,%ax
  81035b:	8d 04 06             	lea    (%esi,%eax,1),%eax
  81035e:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  810362:	66 c1 fa 03          	sar    $0x3,%dx
  810366:	8d 04 02             	lea    (%edx,%eax,1),%eax
  810369:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81036d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  810374:	0f b7 0d 82 e5 b3 00 	movzwl 0xb3e582,%ecx
  81037b:	66 85 c9             	test   %cx,%cx
  81037e:	0f 84 a5 07 00 00    	je     810b29 <tcp_receive+0xc3a>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  810384:	8b 53 24             	mov    0x24(%ebx),%edx
  810387:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  81038c:	89 c6                	mov    %eax,%esi
  81038e:	f7 d6                	not    %esi
  810390:	01 d6                	add    %edx,%esi
  810392:	0f 88 3a 01 00 00    	js     8104d2 <tcp_receive+0x5e3>
  810398:	8d 7a 01             	lea    0x1(%edx),%edi
  81039b:	29 c7                	sub    %eax,%edi
  81039d:	0f b7 f1             	movzwl %cx,%esi
  8103a0:	89 f9                	mov    %edi,%ecx
  8103a2:	29 f1                	sub    %esi,%ecx
  8103a4:	85 c9                	test   %ecx,%ecx
  8103a6:	0f 8f 26 01 00 00    	jg     8104d2 <tcp_receive+0x5e3>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  8103ac:	8b 35 60 e5 b3 00    	mov    0xb3e560,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  8103b2:	85 f6                	test   %esi,%esi
  8103b4:	75 1c                	jne    8103d2 <tcp_receive+0x4e3>
  8103b6:	c7 44 24 08 f7 4d 81 	movl   $0x814df7,0x8(%esp)
  8103bd:	00 
  8103be:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  8103c5:	00 
  8103c6:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  8103cd:	e8 aa 05 ff ff       	call   80097c <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  8103d2:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  8103d4:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  8103da:	7e 1c                	jle    8103f8 <tcp_receive+0x509>
  8103dc:	c7 44 24 08 07 4e 81 	movl   $0x814e07,0x8(%esp)
  8103e3:	00 
  8103e4:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  8103eb:	00 
  8103ec:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  8103f3:	e8 84 05 ff ff       	call   80097c <_panic>
      if (inseg.p->len < off) {
  8103f8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8103fc:	39 c2                	cmp    %eax,%edx
  8103fe:	7e 71                	jle    810471 <tcp_receive+0x582>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  810400:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  810404:	0f b7 f9             	movzwl %cx,%edi
  810407:	39 fa                	cmp    %edi,%edx
  810409:	7e 1c                	jle    810427 <tcp_receive+0x538>
  81040b:	c7 44 24 08 16 4e 81 	movl   $0x814e16,0x8(%esp)
  810412:	00 
  810413:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  81041a:	00 
  81041b:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810422:	e8 55 05 ff ff       	call   80097c <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  810427:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  81042a:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81042c:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  810430:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  810436:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  810438:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  81043c:	39 d0                	cmp    %edx,%eax
  81043e:	7c ea                	jl     81042a <tcp_receive+0x53b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  810440:	f7 da                	neg    %edx
  810442:	0f bf c2             	movswl %dx,%eax
  810445:	89 44 24 04          	mov    %eax,0x4(%esp)
  810449:	89 34 24             	mov    %esi,(%esp)
  81044c:	e8 12 77 ff ff       	call   807b63 <pbuf_header>
  810451:	84 c0                	test   %al,%al
  810453:	74 4d                	je     8104a2 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810455:	c7 44 24 08 26 4e 81 	movl   $0x814e26,0x8(%esp)
  81045c:	00 
  81045d:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  810464:	00 
  810465:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81046c:	e8 0b 05 ff ff       	call   80097c <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  810471:	f7 da                	neg    %edx
  810473:	0f bf c2             	movswl %dx,%eax
  810476:	89 44 24 04          	mov    %eax,0x4(%esp)
  81047a:	89 34 24             	mov    %esi,(%esp)
  81047d:	e8 e1 76 ff ff       	call   807b63 <pbuf_header>
  810482:	84 c0                	test   %al,%al
  810484:	74 1c                	je     8104a2 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810486:	c7 44 24 08 26 4e 81 	movl   $0x814e26,0x8(%esp)
  81048d:	00 
  81048e:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  810495:	00 
  810496:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81049d:	e8 da 04 ff ff       	call   80097c <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  8104a2:	8b 46 04             	mov    0x4(%esi),%eax
  8104a5:	a3 64 e5 b3 00       	mov    %eax,0xb3e564
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  8104aa:	b8 68 e5 b3 00       	mov    $0xb3e568,%eax
  8104af:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  8104b5:	66 03 10             	add    (%eax),%dx
  8104b8:	66 2b 53 24          	sub    0x24(%ebx),%dx
  8104bc:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  8104bf:	8b 43 24             	mov    0x24(%ebx),%eax
  8104c2:	a3 78 e5 b3 00       	mov    %eax,0xb3e578
  8104c7:	8b 15 6c e5 b3 00    	mov    0xb3e56c,%edx
  8104cd:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  8104d0:	eb 10                	jmp    8104e2 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  8104d2:	39 d0                	cmp    %edx,%eax
  8104d4:	79 1c                	jns    8104f2 <tcp_receive+0x603>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  8104d6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8104da:	89 1c 24             	mov    %ebx,(%esp)
  8104dd:	e8 79 ae ff ff       	call   80b35b <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  8104e2:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  8104e7:	8b 53 24             	mov    0x24(%ebx),%edx
  8104ea:	39 d0                	cmp    %edx,%eax
  8104ec:	0f 88 24 06 00 00    	js     810b16 <tcp_receive+0xc27>
  8104f2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  8104f6:	89 c7                	mov    %eax,%edi
  8104f8:	29 cf                	sub    %ecx,%edi
  8104fa:	8d 4f 01             	lea    0x1(%edi),%ecx
  8104fd:	29 d1                	sub    %edx,%ecx
  8104ff:	85 c9                	test   %ecx,%ecx
  810501:	0f 8f 0f 06 00 00    	jg     810b16 <tcp_receive+0xc27>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  810507:	39 d0                	cmp    %edx,%eax
  810509:	0f 85 95 03 00 00    	jne    8108a4 <tcp_receive+0x9b5>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81050f:	8b 53 7c             	mov    0x7c(%ebx),%edx
  810512:	85 d2                	test   %edx,%edx
  810514:	0f 84 86 00 00 00    	je     8105a0 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81051a:	8b 4a 10             	mov    0x10(%edx),%ecx
  81051d:	8b 49 04             	mov    0x4(%ecx),%ecx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  810520:	0f b7 35 68 e5 b3 00 	movzwl 0xb3e568,%esi
  810527:	89 cf                	mov    %ecx,%edi
  810529:	29 f7                	sub    %esi,%edi
  81052b:	89 fe                	mov    %edi,%esi
  81052d:	29 c6                	sub    %eax,%esi
  81052f:	85 f6                	test   %esi,%esi
  810531:	7f 6d                	jg     8105a0 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  810533:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  810538:	74 20                	je     81055a <tcp_receive+0x66b>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81053a:	66 29 c1             	sub    %ax,%cx
  81053d:	66 89 0d 68 e5 b3 00 	mov    %cx,0xb3e568
            pbuf_realloc(inseg.p, inseg.len);
  810544:	0f b7 c1             	movzwl %cx,%eax
  810547:	89 44 24 04          	mov    %eax,0x4(%esp)
  81054b:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  810550:	89 04 24             	mov    %eax,(%esp)
  810553:	e8 08 7b ff ff       	call   808060 <pbuf_realloc>
  810558:	eb 46                	jmp    8105a0 <tcp_receive+0x6b1>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81055a:	a1 6c e5 b3 00       	mov    0xb3e56c,%eax
  81055f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810563:	89 04 24             	mov    %eax,(%esp)
  810566:	e8 76 a7 ff ff       	call   80ace1 <ntohs>
  81056b:	89 c6                	mov    %eax,%esi
  81056d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  810570:	8b 40 10             	mov    0x10(%eax),%eax
  810573:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810577:	89 04 24             	mov    %eax,(%esp)
  81057a:	e8 62 a7 ff ff       	call   80ace1 <ntohs>
  81057f:	31 c6                	xor    %eax,%esi
  810581:	66 f7 c6 03 00       	test   $0x3,%si
  810586:	75 18                	jne    8105a0 <tcp_receive+0x6b1>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  810588:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  81058b:	8b 10                	mov    (%eax),%edx
  81058d:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810590:	89 44 24 04          	mov    %eax,0x4(%esp)
  810594:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  81059b:	e8 a0 71 ff ff       	call   807740 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  8105a0:	0f b7 35 68 e5 b3 00 	movzwl 0xb3e568,%esi
  8105a7:	a1 6c e5 b3 00       	mov    0xb3e56c,%eax
  8105ac:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8105b0:	89 04 24             	mov    %eax,(%esp)
  8105b3:	e8 29 a7 ff ff       	call   80ace1 <ntohs>
  8105b8:	a8 01                	test   $0x1,%al
  8105ba:	75 1a                	jne    8105d6 <tcp_receive+0x6e7>
  8105bc:	a1 6c e5 b3 00       	mov    0xb3e56c,%eax
  8105c1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8105c5:	89 04 24             	mov    %eax,(%esp)
  8105c8:	e8 14 a7 ff ff       	call   80ace1 <ntohs>
  8105cd:	ba 00 00 00 00       	mov    $0x0,%edx
  8105d2:	a8 02                	test   $0x2,%al
  8105d4:	74 05                	je     8105db <tcp_receive+0x6ec>
  8105d6:	ba 01 00 00 00       	mov    $0x1,%edx
  8105db:	01 d6                	add    %edx,%esi
  8105dd:	66 89 35 82 e5 b3 00 	mov    %si,0xb3e582

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  8105e4:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8105e8:	74 06                	je     8105f0 <tcp_receive+0x701>
          pcb->rcv_nxt += tcplen;
  8105ea:	0f b7 f6             	movzwl %si,%esi
  8105ed:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  8105f0:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  8105f4:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  8105fb:	66 39 c2             	cmp    %ax,%dx
  8105fe:	73 08                	jae    810608 <tcp_receive+0x719>
          pcb->rcv_wnd = 0;
  810600:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  810606:	eb 07                	jmp    81060f <tcp_receive+0x720>
        } else {
          pcb->rcv_wnd -= tcplen;
  810608:	66 29 c2             	sub    %ax,%dx
  81060b:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81060f:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  810613:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  81061a:	66 39 c2             	cmp    %ax,%dx
  81061d:	73 08                	jae    810627 <tcp_receive+0x738>
          pcb->rcv_ann_wnd = 0;
  81061f:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810625:	eb 07                	jmp    81062e <tcp_receive+0x73f>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  810627:	66 29 c2             	sub    %ax,%dx
  81062a:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81062e:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  810633:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810638:	74 0f                	je     810649 <tcp_receive+0x75a>
          recv_data = inseg.p;
  81063a:	a3 88 e5 b3 00       	mov    %eax,0xb3e588
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81063f:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  810646:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  810649:	a1 6c e5 b3 00       	mov    0xb3e56c,%eax
  81064e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810652:	89 04 24             	mov    %eax,(%esp)
  810655:	e8 87 a6 ff ff       	call   80ace1 <ntohs>
  81065a:	a8 01                	test   $0x1,%al
  81065c:	74 07                	je     810665 <tcp_receive+0x776>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81065e:	c6 05 84 e5 b3 00 20 	movb   $0x20,0xb3e584
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810665:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810668:	85 f6                	test   %esi,%esi
  81066a:	0f 84 01 02 00 00    	je     810871 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810670:	8b 46 10             	mov    0x10(%esi),%eax
  810673:	8b 40 04             	mov    0x4(%eax),%eax
  810676:	3b 43 24             	cmp    0x24(%ebx),%eax
  810679:	0f 85 f2 01 00 00    	jne    810871 <tcp_receive+0x982>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  81067f:	a3 78 e5 b3 00       	mov    %eax,0xb3e578

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  810684:	8b 43 24             	mov    0x24(%ebx),%eax
  810687:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  81068a:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81068e:	8b 46 10             	mov    0x10(%esi),%eax
  810691:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810695:	89 04 24             	mov    %eax,(%esp)
  810698:	e8 44 a6 ff ff       	call   80ace1 <ntohs>
  81069d:	a8 01                	test   $0x1,%al
  81069f:	75 18                	jne    8106b9 <tcp_receive+0x7ca>
  8106a1:	8b 46 10             	mov    0x10(%esi),%eax
  8106a4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106a8:	89 04 24             	mov    %eax,(%esp)
  8106ab:	e8 31 a6 ff ff       	call   80ace1 <ntohs>
  8106b0:	ba 00 00 00 00       	mov    $0x0,%edx
  8106b5:	a8 02                	test   $0x2,%al
  8106b7:	74 05                	je     8106be <tcp_receive+0x7cf>
  8106b9:	ba 01 00 00 00       	mov    $0x1,%edx
  8106be:	0f b7 ff             	movzwl %di,%edi
  8106c1:	01 fa                	add    %edi,%edx
  8106c3:	03 55 e4             	add    -0x1c(%ebp),%edx
  8106c6:	89 53 24             	mov    %edx,0x24(%ebx)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  8106c9:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  8106cd:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8106d1:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  8106d5:	8b 46 10             	mov    0x10(%esi),%eax
  8106d8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106dc:	89 04 24             	mov    %eax,(%esp)
  8106df:	e8 fd a5 ff ff       	call   80ace1 <ntohs>
  8106e4:	a8 01                	test   $0x1,%al
  8106e6:	75 18                	jne    810700 <tcp_receive+0x811>
  8106e8:	8b 46 10             	mov    0x10(%esi),%eax
  8106eb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106ef:	89 04 24             	mov    %eax,(%esp)
  8106f2:	e8 ea a5 ff ff       	call   80ace1 <ntohs>
  8106f7:	ba 00 00 00 00       	mov    $0x0,%edx
  8106fc:	a8 02                	test   $0x2,%al
  8106fe:	74 05                	je     810705 <tcp_receive+0x816>
  810700:	ba 01 00 00 00       	mov    $0x1,%edx
  810705:	0f b7 ff             	movzwl %di,%edi
  810708:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  81070c:	01 c2                	add    %eax,%edx
  81070e:	39 d7                	cmp    %edx,%edi
  810710:	7d 08                	jge    81071a <tcp_receive+0x82b>
            pcb->rcv_wnd = 0;
  810712:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  810718:	eb 47                	jmp    810761 <tcp_receive+0x872>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81071a:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  81071e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  810722:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  810726:	8b 46 10             	mov    0x10(%esi),%eax
  810729:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81072d:	89 04 24             	mov    %eax,(%esp)
  810730:	e8 ac a5 ff ff       	call   80ace1 <ntohs>
  810735:	a8 01                	test   $0x1,%al
  810737:	75 18                	jne    810751 <tcp_receive+0x862>
  810739:	8b 46 10             	mov    0x10(%esi),%eax
  81073c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810740:	89 04 24             	mov    %eax,(%esp)
  810743:	e8 99 a5 ff ff       	call   80ace1 <ntohs>
  810748:	ba 00 00 00 00       	mov    $0x0,%edx
  81074d:	a8 02                	test   $0x2,%al
  81074f:	74 05                	je     810756 <tcp_receive+0x867>
  810751:	ba 01 00 00 00       	mov    $0x1,%edx
  810756:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  81075a:	66 29 d7             	sub    %dx,%di
  81075d:	66 89 7b 28          	mov    %di,0x28(%ebx)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  810761:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810765:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810769:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  81076d:	8b 46 10             	mov    0x10(%esi),%eax
  810770:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810774:	89 04 24             	mov    %eax,(%esp)
  810777:	e8 65 a5 ff ff       	call   80ace1 <ntohs>
  81077c:	a8 01                	test   $0x1,%al
  81077e:	75 18                	jne    810798 <tcp_receive+0x8a9>
  810780:	8b 46 10             	mov    0x10(%esi),%eax
  810783:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810787:	89 04 24             	mov    %eax,(%esp)
  81078a:	e8 52 a5 ff ff       	call   80ace1 <ntohs>
  81078f:	ba 00 00 00 00       	mov    $0x0,%edx
  810794:	a8 02                	test   $0x2,%al
  810796:	74 05                	je     81079d <tcp_receive+0x8ae>
  810798:	ba 01 00 00 00       	mov    $0x1,%edx
  81079d:	0f b7 ff             	movzwl %di,%edi
  8107a0:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8107a4:	01 c2                	add    %eax,%edx
  8107a6:	39 d7                	cmp    %edx,%edi
  8107a8:	7d 08                	jge    8107b2 <tcp_receive+0x8c3>
            pcb->rcv_ann_wnd = 0;
  8107aa:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  8107b0:	eb 47                	jmp    8107f9 <tcp_receive+0x90a>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  8107b2:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  8107b6:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8107ba:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  8107be:	8b 46 10             	mov    0x10(%esi),%eax
  8107c1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107c5:	89 04 24             	mov    %eax,(%esp)
  8107c8:	e8 14 a5 ff ff       	call   80ace1 <ntohs>
  8107cd:	a8 01                	test   $0x1,%al
  8107cf:	75 18                	jne    8107e9 <tcp_receive+0x8fa>
  8107d1:	8b 46 10             	mov    0x10(%esi),%eax
  8107d4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107d8:	89 04 24             	mov    %eax,(%esp)
  8107db:	e8 01 a5 ff ff       	call   80ace1 <ntohs>
  8107e0:	ba 00 00 00 00       	mov    $0x0,%edx
  8107e5:	a8 02                	test   $0x2,%al
  8107e7:	74 05                	je     8107ee <tcp_receive+0x8ff>
  8107e9:	ba 01 00 00 00       	mov    $0x1,%edx
  8107ee:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8107f2:	66 29 d7             	sub    %dx,%di
  8107f5:	66 89 7b 2a          	mov    %di,0x2a(%ebx)
          }

          if (cseg->p->tot_len > 0) {
  8107f9:	8b 46 04             	mov    0x4(%esi),%eax
  8107fc:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810801:	74 24                	je     810827 <tcp_receive+0x938>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  810803:	8b 15 88 e5 b3 00    	mov    0xb3e588,%edx
  810809:	85 d2                	test   %edx,%edx
  81080b:	74 0e                	je     81081b <tcp_receive+0x92c>
              pbuf_cat(recv_data, cseg->p);
  81080d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810811:	89 14 24             	mov    %edx,(%esp)
  810814:	e8 82 72 ff ff       	call   807a9b <pbuf_cat>
  810819:	eb 05                	jmp    810820 <tcp_receive+0x931>
            } else {
              recv_data = cseg->p;
  81081b:	a3 88 e5 b3 00       	mov    %eax,0xb3e588
            }
            cseg->p = NULL;
  810820:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  810827:	8b 46 10             	mov    0x10(%esi),%eax
  81082a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81082e:	89 04 24             	mov    %eax,(%esp)
  810831:	e8 ab a4 ff ff       	call   80ace1 <ntohs>
  810836:	a8 01                	test   $0x1,%al
  810838:	74 14                	je     81084e <tcp_receive+0x95f>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81083a:	c6 05 84 e5 b3 00 20 	movb   $0x20,0xb3e584
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  810841:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  810845:	75 07                	jne    81084e <tcp_receive+0x95f>
              pcb->state = CLOSE_WAIT;
  810847:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
            } 
          }


          pcb->ooseq = cseg->next;
  81084e:	8b 06                	mov    (%esi),%eax
  810850:	89 43 7c             	mov    %eax,0x7c(%ebx)
          tcp_seg_free(cseg);
  810853:	89 34 24             	mov    %esi,(%esp)
  810856:	e8 f6 81 ff ff       	call   808a51 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81085b:	8b 73 7c             	mov    0x7c(%ebx),%esi
  81085e:	85 f6                	test   %esi,%esi
  810860:	74 0f                	je     810871 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810862:	8b 46 10             	mov    0x10(%esi),%eax
  810865:	8b 40 04             	mov    0x4(%eax),%eax
  810868:	3b 43 24             	cmp    0x24(%ebx),%eax
  81086b:	0f 84 0e fe ff ff    	je     81067f <tcp_receive+0x790>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810871:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  810875:	a8 01                	test   $0x1,%al
  810877:	74 1b                	je     810894 <tcp_receive+0x9a5>
  810879:	83 e0 fe             	and    $0xfffffffe,%eax
  81087c:	83 c8 02             	or     $0x2,%eax
  81087f:	88 43 20             	mov    %al,0x20(%ebx)
  810882:	89 1c 24             	mov    %ebx,(%esp)
  810885:	e8 d1 aa ff ff       	call   80b35b <tcp_output>
  81088a:	b8 01 00 00 00       	mov    $0x1,%eax
  81088f:	e9 cb 02 00 00       	jmp    810b5f <tcp_receive+0xc70>
  810894:	83 c8 01             	or     $0x1,%eax
  810897:	88 43 20             	mov    %al,0x20(%ebx)
  81089a:	b8 01 00 00 00       	mov    $0x1,%eax
  81089f:	e9 bb 02 00 00       	jmp    810b5f <tcp_receive+0xc70>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  8108a4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8108a8:	89 1c 24             	mov    %ebx,(%esp)
  8108ab:	e8 ab aa ff ff       	call   80b35b <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  8108b0:	8b 73 7c             	mov    0x7c(%ebx),%esi
  8108b3:	85 f6                	test   %esi,%esi
  8108b5:	74 31                	je     8108e8 <tcp_receive+0x9f9>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8108b7:	8b 46 10             	mov    0x10(%esi),%eax
  8108ba:	8b 40 04             	mov    0x4(%eax),%eax
  8108bd:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  8108c3:	39 d0                	cmp    %edx,%eax
  8108c5:	74 18                	je     8108df <tcp_receive+0x9f0>
  8108c7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8108ca:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8108cf:	8d 72 01             	lea    0x1(%edx),%esi
  8108d2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8108d5:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8108d8:	89 f3                	mov    %esi,%ebx
  8108da:	e9 b7 00 00 00       	jmp    810996 <tcp_receive+0xaa7>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8108df:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8108e6:	eb 1f                	jmp    810907 <tcp_receive+0xa18>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  8108e8:	c7 04 24 5c e5 b3 00 	movl   $0xb3e55c,(%esp)
  8108ef:	e8 1a 81 ff ff       	call   808a0e <tcp_seg_copy>
  8108f4:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8108f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8108fc:	e9 5e 02 00 00       	jmp    810b5f <tcp_receive+0xc70>
  810901:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810904:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  810907:	0f b7 05 68 e5 b3 00 	movzwl 0xb3e568,%eax
  81090e:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  810912:	0f 86 42 02 00 00    	jbe    810b5a <tcp_receive+0xc6b>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  810918:	c7 04 24 5c e5 b3 00 	movl   $0xb3e55c,(%esp)
  81091f:	e8 ea 80 ff ff       	call   808a0e <tcp_seg_copy>
  810924:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  810926:	85 c0                	test   %eax,%eax
  810928:	0f 84 2c 02 00 00    	je     810b5a <tcp_receive+0xc6b>
                  cseg->next = next->next;
  81092e:	8b 06                	mov    (%esi),%eax
  810930:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  810932:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  810936:	74 07                	je     81093f <tcp_receive+0xa50>
                    prev->next = cseg;
  810938:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  81093b:	89 3b                	mov    %edi,(%ebx)
  81093d:	eb 03                	jmp    810942 <tcp_receive+0xa53>
                  } else {
                    pcb->ooseq = cseg;
  81093f:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  810942:	89 34 24             	mov    %esi,(%esp)
  810945:	e8 07 81 ff ff       	call   808a51 <tcp_seg_free>
                  if (cseg->next != NULL) {
  81094a:	8b 17                	mov    (%edi),%edx
  81094c:	85 d2                	test   %edx,%edx
  81094e:	0f 84 06 02 00 00    	je     810b5a <tcp_receive+0xc6b>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  810954:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  810959:	8b 52 10             	mov    0x10(%edx),%edx
  81095c:	8b 52 04             	mov    0x4(%edx),%edx
  81095f:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810963:	29 d1                	sub    %edx,%ecx
  810965:	01 c1                	add    %eax,%ecx
  810967:	85 c9                	test   %ecx,%ecx
  810969:	0f 8e eb 01 00 00    	jle    810b5a <tcp_receive+0xc6b>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81096f:	66 29 c2             	sub    %ax,%dx
  810972:	66 89 57 0c          	mov    %dx,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  810976:	0f b7 c2             	movzwl %dx,%eax
  810979:	89 44 24 04          	mov    %eax,0x4(%esp)
  81097d:	8b 47 04             	mov    0x4(%edi),%eax
  810980:	89 04 24             	mov    %eax,(%esp)
  810983:	e8 d8 76 ff ff       	call   808060 <pbuf_realloc>
  810988:	b8 00 00 00 00       	mov    $0x0,%eax
  81098d:	e9 cd 01 00 00       	jmp    810b5f <tcp_receive+0xc70>
  810992:	89 cf                	mov    %ecx,%edi
  810994:	89 f1                	mov    %esi,%ecx
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810996:	85 ff                	test   %edi,%edi
  810998:	75 60                	jne    8109fa <tcp_receive+0xb0b>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81099a:	39 c2                	cmp    %eax,%edx
  81099c:	0f 89 fd 00 00 00    	jns    810a9f <tcp_receive+0xbb0>
  8109a2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8109a5:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8109a8:	0f b7 0d 68 e5 b3 00 	movzwl 0xb3e568,%ecx
  8109af:	01 d1                	add    %edx,%ecx
  8109b1:	29 c1                	sub    %eax,%ecx
  8109b3:	85 c9                	test   %ecx,%ecx
  8109b5:	7e 1d                	jle    8109d4 <tcp_receive+0xae5>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  8109b7:	66 29 d0             	sub    %dx,%ax
  8109ba:	66 a3 68 e5 b3 00    	mov    %ax,0xb3e568
                    pbuf_realloc(inseg.p, inseg.len);
  8109c0:	0f b7 c0             	movzwl %ax,%eax
  8109c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109c7:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  8109cc:	89 04 24             	mov    %eax,(%esp)
  8109cf:	e8 8c 76 ff ff       	call   808060 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  8109d4:	c7 04 24 5c e5 b3 00 	movl   $0xb3e55c,(%esp)
  8109db:	e8 2e 80 ff ff       	call   808a0e <tcp_seg_copy>
                  if (cseg != NULL) {
  8109e0:	85 c0                	test   %eax,%eax
  8109e2:	0f 84 72 01 00 00    	je     810b5a <tcp_receive+0xc6b>
                    cseg->next = next;
  8109e8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8109eb:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  8109ed:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8109f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8109f5:	e9 65 01 00 00       	jmp    810b5f <tcp_receive+0xc70>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8109fa:	8b 77 10             	mov    0x10(%edi),%esi
  8109fd:	8b 76 04             	mov    0x4(%esi),%esi
  810a00:	f7 d6                	not    %esi
  810a02:	01 d6                	add    %edx,%esi
  810a04:	0f 88 95 00 00 00    	js     810a9f <tcp_receive+0xbb0>
  810a0a:	89 de                	mov    %ebx,%esi
  810a0c:	29 c6                	sub    %eax,%esi
  810a0e:	85 f6                	test   %esi,%esi
  810a10:	0f 8f 89 00 00 00    	jg     810a9f <tcp_receive+0xbb0>
  810a16:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810a19:	0f b7 0d 68 e5 b3 00 	movzwl 0xb3e568,%ecx
  810a20:	01 d1                	add    %edx,%ecx
  810a22:	29 c1                	sub    %eax,%ecx
  810a24:	85 c9                	test   %ecx,%ecx
  810a26:	7e 1d                	jle    810a45 <tcp_receive+0xb56>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810a28:	66 29 d0             	sub    %dx,%ax
  810a2b:	66 a3 68 e5 b3 00    	mov    %ax,0xb3e568
                  pbuf_realloc(inseg.p, inseg.len);
  810a31:	0f b7 c0             	movzwl %ax,%eax
  810a34:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a38:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  810a3d:	89 04 24             	mov    %eax,(%esp)
  810a40:	e8 1b 76 ff ff       	call   808060 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  810a45:	c7 04 24 5c e5 b3 00 	movl   $0xb3e55c,(%esp)
  810a4c:	e8 bd 7f ff ff       	call   808a0e <tcp_seg_copy>
                if (cseg != NULL) {
  810a51:	85 c0                	test   %eax,%eax
  810a53:	0f 84 01 01 00 00    	je     810b5a <tcp_receive+0xc6b>
                  cseg->next = next;
  810a59:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  810a5c:	89 10                	mov    %edx,(%eax)
                  prev->next = cseg;
  810a5e:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810a60:	8b 47 10             	mov    0x10(%edi),%eax
  810a63:	8b 40 04             	mov    0x4(%eax),%eax
  810a66:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  810a6c:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810a70:	29 d1                	sub    %edx,%ecx
  810a72:	01 c1                	add    %eax,%ecx
  810a74:	85 c9                	test   %ecx,%ecx
  810a76:	0f 8e de 00 00 00    	jle    810b5a <tcp_receive+0xc6b>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  810a7c:	66 29 c2             	sub    %ax,%dx
  810a7f:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  810a83:	0f b7 c2             	movzwl %dx,%eax
  810a86:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a8a:	8b 47 04             	mov    0x4(%edi),%eax
  810a8d:	89 04 24             	mov    %eax,(%esp)
  810a90:	e8 cb 75 ff ff       	call   808060 <pbuf_realloc>
  810a95:	b8 00 00 00 00       	mov    $0x0,%eax
  810a9a:	e9 c0 00 00 00       	jmp    810b5f <tcp_receive+0xc70>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  810a9f:	8b 31                	mov    (%ecx),%esi
  810aa1:	85 f6                	test   %esi,%esi
  810aa3:	75 5e                	jne    810b03 <tcp_receive+0xc14>
  810aa5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810aa8:	29 c2                	sub    %eax,%edx
  810aaa:	85 d2                	test   %edx,%edx
  810aac:	0f 8e a8 00 00 00    	jle    810b5a <tcp_receive+0xc6b>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810ab2:	c7 04 24 5c e5 b3 00 	movl   $0xb3e55c,(%esp)
  810ab9:	e8 50 7f ff ff       	call   808a0e <tcp_seg_copy>
  810abe:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810ac1:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  810ac3:	85 c0                	test   %eax,%eax
  810ac5:	0f 84 8f 00 00 00    	je     810b5a <tcp_receive+0xc6b>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  810acb:	8b 43 10             	mov    0x10(%ebx),%eax
  810ace:	8b 40 04             	mov    0x4(%eax),%eax
  810ad1:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  810ad7:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  810adb:	29 d1                	sub    %edx,%ecx
  810add:	01 c1                	add    %eax,%ecx
  810adf:	85 c9                	test   %ecx,%ecx
  810ae1:	7e 77                	jle    810b5a <tcp_receive+0xc6b>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  810ae3:	66 29 c2             	sub    %ax,%dx
  810ae6:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  810aea:	0f b7 c2             	movzwl %dx,%eax
  810aed:	89 44 24 04          	mov    %eax,0x4(%esp)
  810af1:	8b 43 04             	mov    0x4(%ebx),%eax
  810af4:	89 04 24             	mov    %eax,(%esp)
  810af7:	e8 64 75 ff ff       	call   808060 <pbuf_realloc>
  810afc:	b8 00 00 00 00       	mov    $0x0,%eax
  810b01:	eb 5c                	jmp    810b5f <tcp_receive+0xc70>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810b03:	8b 46 10             	mov    0x10(%esi),%eax
  810b06:	8b 40 04             	mov    0x4(%eax),%eax
  810b09:	39 d0                	cmp    %edx,%eax
  810b0b:	0f 85 81 fe ff ff    	jne    810992 <tcp_receive+0xaa3>
  810b11:	e9 eb fd ff ff       	jmp    810901 <tcp_receive+0xa12>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  810b16:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810b1a:	89 1c 24             	mov    %ebx,(%esp)
  810b1d:	e8 39 a8 ff ff       	call   80b35b <tcp_output>
  810b22:	b8 00 00 00 00       	mov    $0x0,%eax
  810b27:	eb 36                	jmp    810b5f <tcp_receive+0xc70>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810b29:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  810b2f:	8b 43 24             	mov    0x24(%ebx),%eax
  810b32:	39 c2                	cmp    %eax,%edx
  810b34:	78 11                	js     810b47 <tcp_receive+0xc58>
  810b36:	83 c2 01             	add    $0x1,%edx
  810b39:	29 c2                	sub    %eax,%edx
  810b3b:	89 d0                	mov    %edx,%eax
  810b3d:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810b41:	29 c8                	sub    %ecx,%eax
  810b43:	85 c0                	test   %eax,%eax
  810b45:	7e 13                	jle    810b5a <tcp_receive+0xc6b>
      tcp_ack_now(pcb);
  810b47:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810b4b:	89 1c 24             	mov    %ebx,(%esp)
  810b4e:	e8 08 a8 ff ff       	call   80b35b <tcp_output>
  810b53:	b8 00 00 00 00       	mov    $0x0,%eax
  810b58:	eb 05                	jmp    810b5f <tcp_receive+0xc70>
  810b5a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  810b5f:	83 c4 2c             	add    $0x2c,%esp
  810b62:	5b                   	pop    %ebx
  810b63:	5e                   	pop    %esi
  810b64:	5f                   	pop    %edi
  810b65:	5d                   	pop    %ebp
  810b66:	c3                   	ret    

00810b67 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810b67:	55                   	push   %ebp
  810b68:	89 e5                	mov    %esp,%ebp
  810b6a:	57                   	push   %edi
  810b6b:	56                   	push   %esi
  810b6c:	53                   	push   %ebx
  810b6d:	83 ec 5c             	sub    $0x5c,%esp
  810b70:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  810b73:	8b 46 04             	mov    0x4(%esi),%eax
  810b76:	a3 74 e5 b3 00       	mov    %eax,0xb3e574
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  810b7b:	8b 5e 04             	mov    0x4(%esi),%ebx
  810b7e:	0f b7 00             	movzwl (%eax),%eax
  810b81:	89 04 24             	mov    %eax,(%esp)
  810b84:	e8 58 a1 ff ff       	call   80ace1 <ntohs>
  810b89:	c1 e8 06             	shr    $0x6,%eax
  810b8c:	83 e0 3c             	and    $0x3c,%eax
  810b8f:	01 c3                	add    %eax,%ebx
  810b91:	89 1d 70 e5 b3 00    	mov    %ebx,0xb3e570
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  810b97:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
  810b9c:	0f b7 00             	movzwl (%eax),%eax
  810b9f:	89 04 24             	mov    %eax,(%esp)
  810ba2:	e8 3a a1 ff ff       	call   80ace1 <ntohs>
  810ba7:	66 c1 e8 06          	shr    $0x6,%ax
  810bab:	83 e0 3c             	and    $0x3c,%eax
  810bae:	f7 d8                	neg    %eax
  810bb0:	98                   	cwtl   
  810bb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  810bb5:	89 34 24             	mov    %esi,(%esp)
  810bb8:	e8 a6 6f ff ff       	call   807b63 <pbuf_header>
  810bbd:	84 c0                	test   %al,%al
  810bbf:	75 07                	jne    810bc8 <tcp_input+0x61>
  810bc1:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  810bc6:	77 12                	ja     810bda <tcp_input+0x73>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810bc8:	89 34 24             	mov    %esi,(%esp)
  810bcb:	90                   	nop
  810bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810bd0:	e8 03 73 ff ff       	call   807ed8 <pbuf_free>
    return;
  810bd5:	e9 9a 0d 00 00       	jmp    811974 <tcp_input+0xe0d>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810bda:	8b 45 0c             	mov    0xc(%ebp),%eax
  810bdd:	89 44 24 04          	mov    %eax,0x4(%esp)
  810be1:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
  810be6:	83 c0 10             	add    $0x10,%eax
  810be9:	89 04 24             	mov    %eax,(%esp)
  810bec:	e8 d7 8c ff ff       	call   8098c8 <ip_addr_isbroadcast>
  810bf1:	84 c0                	test   %al,%al
  810bf3:	75 28                	jne    810c1d <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  810bf5:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
  810bfa:	8b 78 10             	mov    0x10(%eax),%edi
  810bfd:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  810c04:	e8 11 a3 ff ff       	call   80af1a <ntohl>
  810c09:	89 c3                	mov    %eax,%ebx
  810c0b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  810c12:	e8 03 a3 ff ff       	call   80af1a <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810c17:	21 fb                	and    %edi,%ebx
  810c19:	39 c3                	cmp    %eax,%ebx
  810c1b:	75 0d                	jne    810c2a <tcp_input+0xc3>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c1d:	89 34 24             	mov    %esi,(%esp)
  810c20:	e8 b3 72 ff ff       	call   807ed8 <pbuf_free>
    return;
  810c25:	e9 4a 0d 00 00       	jmp    811974 <tcp_input+0xe0d>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  810c2a:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  810c2f:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  810c33:	89 54 24 10          	mov    %edx,0x10(%esp)
  810c37:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  810c3e:	00 
  810c3f:	8d 50 10             	lea    0x10(%eax),%edx
  810c42:	89 54 24 08          	mov    %edx,0x8(%esp)
  810c46:	83 c0 0c             	add    $0xc,%eax
  810c49:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c4d:	89 34 24             	mov    %esi,(%esp)
  810c50:	e8 7b 9d ff ff       	call   80a9d0 <inet_chksum_pseudo>
  810c55:	66 85 c0             	test   %ax,%ax
  810c58:	74 0d                	je     810c67 <tcp_input+0x100>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c5a:	89 34 24             	mov    %esi,(%esp)
  810c5d:	e8 76 72 ff ff       	call   807ed8 <pbuf_free>
    return;
  810c62:	e9 0d 0d 00 00       	jmp    811974 <tcp_input+0xe0d>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  810c67:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  810c6c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810c70:	89 04 24             	mov    %eax,(%esp)
  810c73:	e8 69 a0 ff ff       	call   80ace1 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  810c78:	66 c1 e8 0c          	shr    $0xc,%ax
  810c7c:	c1 e0 02             	shl    $0x2,%eax
  810c7f:	f7 d8                	neg    %eax
  810c81:	98                   	cwtl   
  810c82:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c86:	89 34 24             	mov    %esi,(%esp)
  810c89:	e8 d5 6e ff ff       	call   807b63 <pbuf_header>
  810c8e:	84 c0                	test   %al,%al
  810c90:	74 0d                	je     810c9f <tcp_input+0x138>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c92:	89 34 24             	mov    %esi,(%esp)
  810c95:	e8 3e 72 ff ff       	call   807ed8 <pbuf_free>
    return;
  810c9a:	e9 d5 0c 00 00       	jmp    811974 <tcp_input+0xe0d>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  810c9f:	8b 1d 70 e5 b3 00    	mov    0xb3e570,%ebx
  810ca5:	0f b7 03             	movzwl (%ebx),%eax
  810ca8:	89 04 24             	mov    %eax,(%esp)
  810cab:	e8 31 a0 ff ff       	call   80ace1 <ntohs>
  810cb0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  810cb3:	8b 1d 70 e5 b3 00    	mov    0xb3e570,%ebx
  810cb9:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  810cbd:	89 04 24             	mov    %eax,(%esp)
  810cc0:	e8 1c a0 ff ff       	call   80ace1 <ntohs>
  810cc5:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  810cc9:	8b 1d 70 e5 b3 00    	mov    0xb3e570,%ebx
  810ccf:	8b 43 04             	mov    0x4(%ebx),%eax
  810cd2:	89 04 24             	mov    %eax,(%esp)
  810cd5:	e8 40 a2 ff ff       	call   80af1a <ntohl>
  810cda:	89 43 04             	mov    %eax,0x4(%ebx)
  810cdd:	a3 78 e5 b3 00       	mov    %eax,0xb3e578
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  810ce2:	8b 1d 70 e5 b3 00    	mov    0xb3e570,%ebx
  810ce8:	8b 43 08             	mov    0x8(%ebx),%eax
  810ceb:	89 04 24             	mov    %eax,(%esp)
  810cee:	e8 27 a2 ff ff       	call   80af1a <ntohl>
  810cf3:	89 43 08             	mov    %eax,0x8(%ebx)
  810cf6:	a3 7c e5 b3 00       	mov    %eax,0xb3e57c
  tcphdr->wnd = ntohs(tcphdr->wnd);
  810cfb:	8b 1d 70 e5 b3 00    	mov    0xb3e570,%ebx
  810d01:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  810d05:	89 04 24             	mov    %eax,(%esp)
  810d08:	e8 d4 9f ff ff       	call   80ace1 <ntohs>
  810d0d:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  810d11:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  810d16:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810d1a:	89 04 24             	mov    %eax,(%esp)
  810d1d:	e8 bf 9f ff ff       	call   80ace1 <ntohs>
  810d22:	83 e0 3f             	and    $0x3f,%eax
  810d25:	a2 80 e5 b3 00       	mov    %al,0xb3e580
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  810d2a:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  810d2e:	ba 01 00 00 00       	mov    $0x1,%edx
  810d33:	a8 01                	test   $0x1,%al
  810d35:	75 07                	jne    810d3e <tcp_input+0x1d7>
  810d37:	d1 e8                	shr    %eax
  810d39:	89 c2                	mov    %eax,%edx
  810d3b:	83 e2 01             	and    $0x1,%edx
  810d3e:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  810d41:	66 89 15 82 e5 b3 00 	mov    %dx,0xb3e582
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810d48:	8b 1d 08 e6 b3 00    	mov    0xb3e608,%ebx
  810d4e:	85 db                	test   %ebx,%ebx
  810d50:	0f 84 32 01 00 00    	je     810e88 <tcp_input+0x321>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810d56:	8b 43 10             	mov    0x10(%ebx),%eax
  810d59:	85 c0                	test   %eax,%eax
  810d5b:	74 15                	je     810d72 <tcp_input+0x20b>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810d5d:	83 f8 0a             	cmp    $0xa,%eax
  810d60:	74 31                	je     810d93 <tcp_input+0x22c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810d62:	83 f8 01             	cmp    $0x1,%eax
  810d65:	75 6f                	jne    810dd6 <tcp_input+0x26f>
  810d67:	90                   	nop
  810d68:	eb 50                	jmp    810dba <tcp_input+0x253>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810d6a:	8b 50 10             	mov    0x10(%eax),%edx
  810d6d:	85 d2                	test   %edx,%edx
  810d6f:	90                   	nop
  810d70:	75 1c                	jne    810d8e <tcp_input+0x227>
  810d72:	c7 44 24 08 bc 4c 81 	movl   $0x814cbc,0x8(%esp)
  810d79:	00 
  810d7a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810d81:	00 
  810d82:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810d89:	e8 ee fb fe ff       	call   80097c <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810d8e:	83 fa 0a             	cmp    $0xa,%edx
  810d91:	75 1c                	jne    810daf <tcp_input+0x248>
  810d93:	c7 44 24 08 e4 4c 81 	movl   $0x814ce4,0x8(%esp)
  810d9a:	00 
  810d9b:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  810da2:	00 
  810da3:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810daa:	e8 cd fb fe ff       	call   80097c <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810daf:	83 fa 01             	cmp    $0x1,%edx
  810db2:	74 06                	je     810dba <tcp_input+0x253>
  810db4:	89 da                	mov    %ebx,%edx
  810db6:	89 c3                	mov    %eax,%ebx
  810db8:	eb 35                	jmp    810def <tcp_input+0x288>
  810dba:	c7 44 24 08 10 4d 81 	movl   $0x814d10,0x8(%esp)
  810dc1:	00 
  810dc2:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  810dc9:	00 
  810dca:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810dd1:	e8 a6 fb fe ff       	call   80097c <_panic>
    if (pcb->remote_port == tcphdr->src &&
  810dd6:	8b 3d 70 e5 b3 00    	mov    0xb3e570,%edi
  810ddc:	0f b7 0f             	movzwl (%edi),%ecx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810ddf:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
  810de4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  810de7:	ba 00 00 00 00       	mov    $0x0,%edx
  810dec:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  810def:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  810df3:	75 7b                	jne    810e70 <tcp_input+0x309>
       pcb->local_port == tcphdr->dest &&
  810df5:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810df9:	66 3b 47 02          	cmp    0x2(%edi),%ax
  810dfd:	75 71                	jne    810e70 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810dff:	8b 43 04             	mov    0x4(%ebx),%eax
  810e02:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  810e05:	3b 46 0c             	cmp    0xc(%esi),%eax
  810e08:	75 66                	jne    810e70 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810e0a:	8b 03                	mov    (%ebx),%eax
  810e0c:	3b 46 10             	cmp    0x10(%esi),%eax
  810e0f:	75 5f                	jne    810e70 <tcp_input+0x309>
  810e11:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810e14:	89 d8                	mov    %ebx,%eax

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  810e16:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  810e19:	39 d9                	cmp    %ebx,%ecx
  810e1b:	75 1c                	jne    810e39 <tcp_input+0x2d2>
  810e1d:	c7 44 24 08 38 4d 81 	movl   $0x814d38,0x8(%esp)
  810e24:	00 
  810e25:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  810e2c:	00 
  810e2d:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810e34:	e8 43 fb fe ff       	call   80097c <_panic>
      if (prev != NULL) {
  810e39:	85 d2                	test   %edx,%edx
  810e3b:	74 43                	je     810e80 <tcp_input+0x319>
        prev->next = pcb->next;
  810e3d:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  810e40:	8b 15 08 e6 b3 00    	mov    0xb3e608,%edx
  810e46:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  810e49:	89 1d 08 e6 b3 00    	mov    %ebx,0xb3e608
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  810e4f:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  810e52:	75 2c                	jne    810e80 <tcp_input+0x319>
  810e54:	c7 44 24 08 64 4d 81 	movl   $0x814d64,0x8(%esp)
  810e5b:	00 
  810e5c:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810e63:	00 
  810e64:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810e6b:	e8 0c fb fe ff       	call   80097c <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810e70:	8b 43 0c             	mov    0xc(%ebx),%eax
  810e73:	85 c0                	test   %eax,%eax
  810e75:	0f 85 ef fe ff ff    	jne    810d6a <tcp_input+0x203>
  810e7b:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810e7e:	eb 08                	jmp    810e88 <tcp_input+0x321>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  810e80:	85 c0                	test   %eax,%eax
  810e82:	0f 85 be 02 00 00    	jne    811146 <tcp_input+0x5df>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810e88:	8b 1d 1c e6 b3 00    	mov    0xb3e61c,%ebx
  810e8e:	85 db                	test   %ebx,%ebx
  810e90:	0f 84 ad 00 00 00    	je     810f43 <tcp_input+0x3dc>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810e96:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810e9a:	74 2a                	je     810ec6 <tcp_input+0x35f>
  810e9c:	eb 0c                	jmp    810eaa <tcp_input+0x343>
  810e9e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810ea2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810ea8:	74 2b                	je     810ed5 <tcp_input+0x36e>
  810eaa:	c7 44 24 08 90 4d 81 	movl   $0x814d90,0x8(%esp)
  810eb1:	00 
  810eb2:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810eb9:	00 
  810eba:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  810ec1:	e8 b6 fa fe ff       	call   80097c <_panic>
      if (pcb->remote_port == tcphdr->src &&
  810ec6:	8b 0d 70 e5 b3 00    	mov    0xb3e570,%ecx
  810ecc:	0f b7 01             	movzwl (%ecx),%eax
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810ecf:	8b 3d 74 e5 b3 00    	mov    0xb3e574,%edi
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  810ed5:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  810ed9:	75 5d                	jne    810f38 <tcp_input+0x3d1>
         pcb->local_port == tcphdr->dest &&
  810edb:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  810edf:	66 3b 51 02          	cmp    0x2(%ecx),%dx
  810ee3:	75 53                	jne    810f38 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810ee5:	8b 53 04             	mov    0x4(%ebx),%edx
  810ee8:	3b 57 0c             	cmp    0xc(%edi),%edx
  810eeb:	75 4b                	jne    810f38 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810eed:	8b 13                	mov    (%ebx),%edx
  810eef:	3b 57 10             	cmp    0x10(%edi),%edx
  810ef2:	75 44                	jne    810f38 <tcp_input+0x3d1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  810ef4:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  810efb:	03 05 78 e5 b3 00    	add    0xb3e578,%eax
  810f01:	89 c2                	mov    %eax,%edx
  810f03:	2b 53 24             	sub    0x24(%ebx),%edx
  810f06:	85 d2                	test   %edx,%edx
  810f08:	7e 03                	jle    810f0d <tcp_input+0x3a6>
    pcb->rcv_nxt = seqno + tcplen;
  810f0a:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  810f0d:	66 83 3d 82 e5 b3 00 	cmpw   $0x0,0xb3e582
  810f14:	00 
  810f15:	74 0c                	je     810f23 <tcp_input+0x3bc>
    tcp_ack_now(pcb);
  810f17:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810f1b:	89 1c 24             	mov    %ebx,(%esp)
  810f1e:	e8 38 a4 ff ff       	call   80b35b <tcp_output>
  }
  return tcp_output(pcb);
  810f23:	89 1c 24             	mov    %ebx,(%esp)
  810f26:	e8 30 a4 ff ff       	call   80b35b <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  810f2b:	89 34 24             	mov    %esi,(%esp)
  810f2e:	e8 a5 6f ff ff       	call   807ed8 <pbuf_free>
        return;
  810f33:	e9 3c 0a 00 00       	jmp    811974 <tcp_input+0xe0d>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810f38:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810f3b:	85 db                	test   %ebx,%ebx
  810f3d:	0f 85 5b ff ff ff    	jne    810e9e <tcp_input+0x337>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810f43:	8b 3d 10 e6 b3 00    	mov    0xb3e610,%edi
  810f49:	85 ff                	test   %edi,%edi
  810f4b:	0f 84 ed 01 00 00    	je     81113e <tcp_input+0x5d7>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810f51:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
        lpcb->local_port == tcphdr->dest) {
  810f56:	8b 0d 70 e5 b3 00    	mov    0xb3e570,%ecx
  810f5c:	ba 00 00 00 00       	mov    $0x0,%edx
  810f61:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  810f64:	89 c3                	mov    %eax,%ebx

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810f66:	85 ff                	test   %edi,%edi
  810f68:	74 0f                	je     810f79 <tcp_input+0x412>
  810f6a:	8b 07                	mov    (%edi),%eax
  810f6c:	85 c0                	test   %eax,%eax
  810f6e:	74 09                	je     810f79 <tcp_input+0x412>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810f70:	3b 43 10             	cmp    0x10(%ebx),%eax
  810f73:	0f 85 b1 01 00 00    	jne    81112a <tcp_input+0x5c3>
        lpcb->local_port == tcphdr->dest) {
  810f79:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810f7d:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810f81:	0f 85 a3 01 00 00    	jne    81112a <tcp_input+0x5c3>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  810f87:	85 d2                	test   %edx,%edx
  810f89:	74 14                	je     810f9f <tcp_input+0x438>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  810f8b:	8b 47 0c             	mov    0xc(%edi),%eax
  810f8e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  810f91:	a1 10 e6 b3 00       	mov    0xb3e610,%eax
  810f96:	89 47 0c             	mov    %eax,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  810f99:	89 3d 10 e6 b3 00    	mov    %edi,0xb3e610
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  810f9f:	0f b6 05 80 e5 b3 00 	movzbl 0xb3e580,%eax
  810fa6:	a8 10                	test   $0x10,%al
  810fa8:	74 4e                	je     810ff8 <tcp_input+0x491>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  810faa:	8b 15 70 e5 b3 00    	mov    0xb3e570,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  810fb0:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  810fb5:	0f b7 0a             	movzwl (%edx),%ecx
  810fb8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810fbc:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810fc0:	89 54 24 10          	mov    %edx,0x10(%esp)
  810fc4:	8d 50 0c             	lea    0xc(%eax),%edx
  810fc7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810fcb:	83 c0 10             	add    $0x10,%eax
  810fce:	89 44 24 08          	mov    %eax,0x8(%esp)
  810fd2:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  810fd9:	03 05 78 e5 b3 00    	add    0xb3e578,%eax
  810fdf:	89 44 24 04          	mov    %eax,0x4(%esp)
  810fe3:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  810fe8:	83 c0 01             	add    $0x1,%eax
  810feb:	89 04 24             	mov    %eax,(%esp)
  810fee:	e8 09 a2 ff ff       	call   80b1fc <tcp_rst>
  810ff3:	e9 25 01 00 00       	jmp    81111d <tcp_input+0x5b6>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  810ff8:	a8 02                	test   $0x2,%al
  810ffa:	0f 84 1d 01 00 00    	je     81111d <tcp_input+0x5b6>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  811000:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  811004:	89 04 24             	mov    %eax,(%esp)
  811007:	e8 02 81 ff ff       	call   80910e <tcp_alloc>
  81100c:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81100e:	85 c0                	test   %eax,%eax
  811010:	0f 84 07 01 00 00    	je     81111d <tcp_input+0x5b6>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  811016:	8b 15 74 e5 b3 00    	mov    0xb3e574,%edx
  81101c:	b8 00 00 00 00       	mov    $0x0,%eax
  811021:	83 fa f0             	cmp    $0xfffffff0,%edx
  811024:	74 03                	je     811029 <tcp_input+0x4c2>
  811026:	8b 42 10             	mov    0x10(%edx),%eax
  811029:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  81102b:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  81102f:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  811033:	8b 15 74 e5 b3 00    	mov    0xb3e574,%edx
  811039:	b8 00 00 00 00       	mov    $0x0,%eax
  81103e:	83 fa f4             	cmp    $0xfffffff4,%edx
  811041:	74 03                	je     811046 <tcp_input+0x4df>
  811043:	8b 42 0c             	mov    0xc(%edx),%eax
  811046:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  811049:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  81104e:	0f b7 00             	movzwl (%eax),%eax
  811051:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  811055:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  81105c:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  811061:	83 c0 01             	add    $0x1,%eax
  811064:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  811067:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  81106c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  811070:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  811074:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  811078:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  81107d:	83 e8 01             	sub    $0x1,%eax
  811080:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  811083:	8b 47 18             	mov    0x18(%edi),%eax
  811086:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  811089:	8b 47 20             	mov    0x20(%edi),%eax
  81108c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  811092:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811096:	66 25 99 01          	and    $0x199,%ax
  81109a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81109e:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  8110a3:	89 43 0c             	mov    %eax,0xc(%ebx)
  8110a6:	89 1d 08 e6 b3 00    	mov    %ebx,0xb3e608
  8110ac:	e8 cc 3e ff ff       	call   804f7d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  8110b1:	89 d8                	mov    %ebx,%eax
  8110b3:	e8 88 ed ff ff       	call   80fe40 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  8110b8:	8d 43 04             	lea    0x4(%ebx),%eax
  8110bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110bf:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  8110c3:	89 04 24             	mov    %eax,(%esp)
  8110c6:	e8 f6 77 ff ff       	call   8088c1 <tcp_eff_send_mss>
  8110cb:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  8110cf:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  8110d6:	e8 1a 9c ff ff       	call   80acf5 <htonl>
  8110db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  8110de:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  8110e5:	00 
  8110e6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8110e9:	89 44 24 14          	mov    %eax,0x14(%esp)
  8110ed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8110f4:	00 
  8110f5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  8110fc:	00 
  8110fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811104:	00 
  811105:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81110c:	00 
  81110d:	89 1c 24             	mov    %ebx,(%esp)
  811110:	e8 93 a7 ff ff       	call   80b8a8 <tcp_enqueue>
    return tcp_output(npcb);
  811115:	89 1c 24             	mov    %ebx,(%esp)
  811118:	e8 3e a2 ff ff       	call   80b35b <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  81111d:	89 34 24             	mov    %esi,(%esp)
  811120:	e8 b3 6d ff ff       	call   807ed8 <pbuf_free>
        return;
  811125:	e9 4a 08 00 00       	jmp    811974 <tcp_input+0xe0d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81112a:	8b 47 0c             	mov    0xc(%edi),%eax
  81112d:	85 c0                	test   %eax,%eax
  81112f:	90                   	nop
  811130:	74 09                	je     81113b <tcp_input+0x5d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  811132:	89 fa                	mov    %edi,%edx
  811134:	89 c7                	mov    %eax,%edi
  811136:	e9 2b fe ff ff       	jmp    810f66 <tcp_input+0x3ff>
  81113b:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81113e:	85 db                	test   %ebx,%ebx
  811140:	0f 84 9b 07 00 00    	je     8118e1 <tcp_input+0xd7a>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  811146:	c7 05 5c e5 b3 00 00 	movl   $0x0,0xb3e55c
  81114d:	00 00 00 
    inseg.len = p->tot_len;
  811150:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811154:	66 a3 68 e5 b3 00    	mov    %ax,0xb3e568
    inseg.dataptr = p->payload;
  81115a:	8b 46 04             	mov    0x4(%esi),%eax
  81115d:	a3 64 e5 b3 00       	mov    %eax,0xb3e564
    inseg.p = p;
  811162:	89 35 60 e5 b3 00    	mov    %esi,0xb3e560
    inseg.tcphdr = tcphdr;
  811168:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  81116d:	a3 6c e5 b3 00       	mov    %eax,0xb3e56c

    recv_data = NULL;
  811172:	c7 05 88 e5 b3 00 00 	movl   $0x0,0xb3e588
  811179:	00 00 00 
    recv_flags = 0;
  81117c:	c6 05 84 e5 b3 00 00 	movb   $0x0,0xb3e584

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  811183:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  811189:	85 c0                	test   %eax,%eax
  81118b:	74 49                	je     8111d6 <tcp_input+0x66f>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81118d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  811193:	85 d2                	test   %edx,%edx
  811195:	74 1e                	je     8111b5 <tcp_input+0x64e>
  811197:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81119e:	00 
  81119f:	89 44 24 08          	mov    %eax,0x8(%esp)
  8111a3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8111a7:	8b 43 18             	mov    0x18(%ebx),%eax
  8111aa:	89 04 24             	mov    %eax,(%esp)
  8111ad:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8111af:	84 c0                	test   %al,%al
  8111b1:	74 0a                	je     8111bd <tcp_input+0x656>
  8111b3:	eb 14                	jmp    8111c9 <tcp_input+0x662>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8111b5:	89 04 24             	mov    %eax,(%esp)
  8111b8:	e8 1b 6d ff ff       	call   807ed8 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8111bd:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8111c4:	00 00 00 
  8111c7:	eb 0d                	jmp    8111d6 <tcp_input+0x66f>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  8111c9:	89 34 24             	mov    %esi,(%esp)
  8111cc:	e8 07 6d ff ff       	call   807ed8 <pbuf_free>
        return;
  8111d1:	e9 9e 07 00 00       	jmp    811974 <tcp_input+0xe0d>
      }
    }

    tcp_input_pcb = pcb;
  8111d6:	89 1d 24 e6 b3 00    	mov    %ebx,0xb3e624
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  8111dc:	f6 05 80 e5 b3 00 04 	testb  $0x4,0xb3e580
  8111e3:	74 68                	je     81124d <tcp_input+0x6e6>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  8111e5:	8b 43 10             	mov    0x10(%ebx),%eax
  8111e8:	83 f8 02             	cmp    $0x2,%eax
  8111eb:	75 0e                	jne    8111fb <tcp_input+0x694>
  8111ed:	8b 53 54             	mov    0x54(%ebx),%edx
  8111f0:	3b 15 7c e5 b3 00    	cmp    0xb3e57c,%edx
  8111f6:	0f 94 c2             	sete   %dl
  8111f9:	eb 1a                	jmp    811215 <tcp_input+0x6ae>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  8111fb:	8b 15 78 e5 b3 00    	mov    0xb3e578,%edx
  811201:	2b 53 24             	sub    0x24(%ebx),%edx
  811204:	0f 88 51 07 00 00    	js     81195b <tcp_input+0xdf4>
  81120a:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  81120e:	29 ca                	sub    %ecx,%edx
  811210:	85 d2                	test   %edx,%edx
  811212:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  811215:	84 d2                	test   %dl,%dl
  811217:	0f 84 3e 07 00 00    	je     81195b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81121d:	85 c0                	test   %eax,%eax
  81121f:	75 1c                	jne    81123d <tcp_input+0x6d6>
  811221:	c7 44 24 08 c0 4d 81 	movl   $0x814dc0,0x8(%esp)
  811228:	00 
  811229:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  811230:	00 
  811231:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  811238:	e8 3f f7 fe ff       	call   80097c <_panic>
      recv_flags = TF_RESET;
  81123d:	c6 05 84 e5 b3 00 08 	movb   $0x8,0xb3e584
      pcb->flags &= ~TF_ACK_DELAY;
  811244:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  811248:	e9 0e 07 00 00       	jmp    81195b <tcp_input+0xdf4>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81124d:	a1 0c e6 b3 00       	mov    0xb3e60c,%eax
  811252:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  811255:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81125c:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  811260:	0f 87 07 05 00 00    	ja     81176d <tcp_input+0xc06>
  811266:	8b 43 10             	mov    0x10(%ebx),%eax
  811269:	ff 24 85 64 4e 81 00 	jmp    *0x814e64(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  811270:	0f b6 05 80 e5 b3 00 	movzbl 0xb3e580,%eax
  811277:	83 e0 12             	and    $0x12,%eax
  81127a:	83 f8 12             	cmp    $0x12,%eax
  81127d:	0f 85 0a 01 00 00    	jne    81138d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  811283:	8b 43 78             	mov    0x78(%ebx),%eax
  811286:	8b 40 10             	mov    0x10(%eax),%eax
  811289:	8b 40 04             	mov    0x4(%eax),%eax
  81128c:	89 04 24             	mov    %eax,(%esp)
  81128f:	e8 86 9c ff ff       	call   80af1a <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  811294:	83 c0 01             	add    $0x1,%eax
  811297:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  81129d:	0f 85 ea 00 00 00    	jne    81138d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  8112a3:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  8112a8:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  8112ad:	83 c0 01             	add    $0x1,%eax
  8112b0:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  8112b3:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  8112b8:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  8112bb:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  8112c0:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  8112c4:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  8112c8:	a1 78 e5 b3 00       	mov    0xb3e578,%eax
  8112cd:	83 e8 01             	sub    $0x1,%eax
  8112d0:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  8112d3:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  8112da:	89 d8                	mov    %ebx,%eax
  8112dc:	e8 5f eb ff ff       	call   80fe40 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  8112e1:	8d 43 04             	lea    0x4(%ebx),%eax
  8112e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8112e8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  8112ec:	89 04 24             	mov    %eax,(%esp)
  8112ef:	e8 cd 75 ff ff       	call   8088c1 <tcp_eff_send_mss>
  8112f4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  8112f8:	6b d0 0a             	imul   $0xa,%eax,%edx
  8112fb:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  8112ff:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  811304:	75 02                	jne    811308 <tcp_input+0x7a1>
  811306:	01 c0                	add    %eax,%eax
  811308:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81130c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  811310:	66 85 c0             	test   %ax,%ax
  811313:	75 1c                	jne    811331 <tcp_input+0x7ca>
  811315:	c7 44 24 08 39 4e 81 	movl   $0x814e39,0x8(%esp)
  81131c:	00 
  81131d:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  811324:	00 
  811325:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81132c:	e8 4b f6 fe ff       	call   80097c <_panic>
      --pcb->snd_queuelen;
  811331:	83 e8 01             	sub    $0x1,%eax
  811334:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  811338:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  81133b:	8b 10                	mov    (%eax),%edx
  81133d:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  811340:	85 d2                	test   %edx,%edx
  811342:	75 08                	jne    81134c <tcp_input+0x7e5>
        pcb->rtime = -1;
  811344:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  81134a:	eb 0a                	jmp    811356 <tcp_input+0x7ef>
      else {
        pcb->rtime = 0;
  81134c:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  811352:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  811356:	89 04 24             	mov    %eax,(%esp)
  811359:	e8 f3 76 ff ff       	call   808a51 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81135e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  811364:	85 c0                	test   %eax,%eax
  811366:	74 14                	je     81137c <tcp_input+0x815>
  811368:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81136f:	00 
  811370:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811374:	8b 53 18             	mov    0x18(%ebx),%edx
  811377:	89 14 24             	mov    %edx,(%esp)
  81137a:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  81137c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811380:	89 1c 24             	mov    %ebx,(%esp)
  811383:	e8 d3 9f ff ff       	call   80b35b <tcp_output>
  811388:	e9 ce 05 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81138d:	f6 05 80 e5 b3 00 10 	testb  $0x10,0xb3e580
  811394:	0f 84 c1 05 00 00    	je     81195b <tcp_input+0xdf4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81139a:	8b 15 70 e5 b3 00    	mov    0xb3e570,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  8113a0:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
  8113a5:	0f b7 0a             	movzwl (%edx),%ecx
  8113a8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8113ac:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  8113b0:	89 54 24 10          	mov    %edx,0x10(%esp)
  8113b4:	8d 50 0c             	lea    0xc(%eax),%edx
  8113b7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8113bb:	83 c0 10             	add    $0x10,%eax
  8113be:	89 44 24 08          	mov    %eax,0x8(%esp)
  8113c2:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  8113c9:	03 05 78 e5 b3 00    	add    0xb3e578,%eax
  8113cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8113d3:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  8113d8:	89 04 24             	mov    %eax,(%esp)
  8113db:	e8 1c 9e ff ff       	call   80b1fc <tcp_rst>
  8113e0:	e9 76 05 00 00       	jmp    81195b <tcp_input+0xdf4>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  8113e5:	0f b6 05 80 e5 b3 00 	movzbl 0xb3e580,%eax
  8113ec:	83 e0 14             	and    $0x14,%eax
  8113ef:	83 f8 10             	cmp    $0x10,%eax
  8113f2:	0f 85 63 05 00 00    	jne    81195b <tcp_input+0xdf4>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  8113f8:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  8113fd:	8b 53 48             	mov    0x48(%ebx),%edx
  811400:	f7 d2                	not    %edx
  811402:	01 c2                	add    %eax,%edx
  811404:	0f 88 b7 00 00 00    	js     8114c1 <tcp_input+0x95a>
  81140a:	89 c2                	mov    %eax,%edx
  81140c:	2b 53 54             	sub    0x54(%ebx),%edx
  81140f:	85 d2                	test   %edx,%edx
  811411:	0f 8f aa 00 00 00    	jg     8114c1 <tcp_input+0x95a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  811417:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81141e:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  811424:	85 c0                	test   %eax,%eax
  811426:	75 1c                	jne    811444 <tcp_input+0x8dd>
  811428:	c7 44 24 08 4f 4e 81 	movl   $0x814e4f,0x8(%esp)
  81142f:	00 
  811430:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  811437:	00 
  811438:	c7 04 24 e0 4d 81 00 	movl   $0x814de0,(%esp)
  81143f:	e8 38 f5 fe ff       	call   80097c <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  811444:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81144b:	00 
  81144c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811450:	8b 53 18             	mov    0x18(%ebx),%edx
  811453:	89 14 24             	mov    %edx,(%esp)
  811456:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  811458:	84 c0                	test   %al,%al
  81145a:	74 17                	je     811473 <tcp_input+0x90c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81145c:	89 1c 24             	mov    %ebx,(%esp)
  81145f:	e8 9a 7b ff ff       	call   808ffe <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  811464:	c7 05 24 e6 b3 00 00 	movl   $0x0,0xb3e624
  81146b:	00 00 00 
  81146e:	e9 4a 04 00 00       	jmp    8118bd <tcp_input+0xd56>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  811473:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  811477:	89 d8                	mov    %ebx,%eax
  811479:	e8 71 ea ff ff       	call   80feef <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81147e:	66 83 fe 01          	cmp    $0x1,%si
  811482:	75 08                	jne    81148c <tcp_input+0x925>
  811484:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811488:	01 d2                	add    %edx,%edx
  81148a:	eb 04                	jmp    811490 <tcp_input+0x929>
  81148c:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811490:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  811494:	f6 05 80 e5 b3 00 01 	testb  $0x1,0xb3e580
  81149b:	0f 84 ba 04 00 00    	je     81195b <tcp_input+0xdf4>
  8114a1:	84 c0                	test   %al,%al
  8114a3:	0f 84 b2 04 00 00    	je     81195b <tcp_input+0xdf4>
          tcp_ack_now(pcb);
  8114a9:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8114ad:	89 1c 24             	mov    %ebx,(%esp)
  8114b0:	e8 a6 9e ff ff       	call   80b35b <tcp_output>
          pcb->state = CLOSE_WAIT;
  8114b5:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  8114bc:	e9 9a 04 00 00       	jmp    81195b <tcp_input+0xdf4>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  8114c1:	8b 0d 70 e5 b3 00    	mov    0xb3e570,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  8114c7:	8b 15 74 e5 b3 00    	mov    0xb3e574,%edx
  8114cd:	0f b7 31             	movzwl (%ecx),%esi
  8114d0:	89 74 24 14          	mov    %esi,0x14(%esp)
  8114d4:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  8114d8:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  8114dc:	8d 4a 0c             	lea    0xc(%edx),%ecx
  8114df:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  8114e3:	83 c2 10             	add    $0x10,%edx
  8114e6:	89 54 24 08          	mov    %edx,0x8(%esp)
  8114ea:	0f b7 15 82 e5 b3 00 	movzwl 0xb3e582,%edx
  8114f1:	03 15 78 e5 b3 00    	add    0xb3e578,%edx
  8114f7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8114fb:	89 04 24             	mov    %eax,(%esp)
  8114fe:	e8 f9 9c ff ff       	call   80b1fc <tcp_rst>
  811503:	e9 53 04 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  811508:	89 d8                	mov    %ebx,%eax
  81150a:	e8 e0 e9 ff ff       	call   80feef <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81150f:	f6 05 80 e5 b3 00 01 	testb  $0x1,0xb3e580
  811516:	0f 84 3f 04 00 00    	je     81195b <tcp_input+0xdf4>
  81151c:	84 c0                	test   %al,%al
  81151e:	0f 84 37 04 00 00    	je     81195b <tcp_input+0xdf4>
      tcp_ack_now(pcb);
  811524:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811528:	89 1c 24             	mov    %ebx,(%esp)
  81152b:	e8 2b 9e ff ff       	call   80b35b <tcp_output>
      pcb->state = CLOSE_WAIT;
  811530:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  811537:	e9 1f 04 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81153c:	89 d8                	mov    %ebx,%eax
  81153e:	e8 ac e9 ff ff       	call   80feef <tcp_receive>
    if (flags & TCP_FIN) {
  811543:	0f b6 05 80 e5 b3 00 	movzbl 0xb3e580,%eax
  81154a:	a8 01                	test   $0x1,%al
  81154c:	0f 84 a3 00 00 00    	je     8115f5 <tcp_input+0xa8e>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811552:	a8 10                	test   $0x10,%al
  811554:	0f 84 81 00 00 00    	je     8115db <tcp_input+0xa74>
  81155a:	8b 43 54             	mov    0x54(%ebx),%eax
  81155d:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  811563:	75 76                	jne    8115db <tcp_input+0xa74>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  811565:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811569:	89 1c 24             	mov    %ebx,(%esp)
  81156c:	e8 ea 9d ff ff       	call   80b35b <tcp_output>
        tcp_pcb_purge(pcb);
  811571:	89 1c 24             	mov    %ebx,(%esp)
  811574:	e8 4e 75 ff ff       	call   808ac7 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  811579:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  81157e:	39 c3                	cmp    %eax,%ebx
  811580:	75 0a                	jne    81158c <tcp_input+0xa25>
  811582:	8b 43 0c             	mov    0xc(%ebx),%eax
  811585:	a3 08 e6 b3 00       	mov    %eax,0xb3e608
  81158a:	eb 29                	jmp    8115b5 <tcp_input+0xa4e>
  81158c:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  811591:	eb 19                	jmp    8115ac <tcp_input+0xa45>
  811593:	8b 50 0c             	mov    0xc(%eax),%edx
  811596:	85 d2                	test   %edx,%edx
  811598:	74 0c                	je     8115a6 <tcp_input+0xa3f>
  81159a:	39 d3                	cmp    %edx,%ebx
  81159c:	75 08                	jne    8115a6 <tcp_input+0xa3f>
  81159e:	8b 53 0c             	mov    0xc(%ebx),%edx
  8115a1:	89 50 0c             	mov    %edx,0xc(%eax)
  8115a4:	eb 0f                	jmp    8115b5 <tcp_input+0xa4e>
  8115a6:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  8115ac:	a1 14 e6 b3 00       	mov    0xb3e614,%eax
  8115b1:	85 c0                	test   %eax,%eax
  8115b3:	75 de                	jne    811593 <tcp_input+0xa2c>
  8115b5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  8115bc:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  8115c3:	a1 1c e6 b3 00       	mov    0xb3e61c,%eax
  8115c8:	89 43 0c             	mov    %eax,0xc(%ebx)
  8115cb:	89 1d 1c e6 b3 00    	mov    %ebx,0xb3e61c
  8115d1:	e8 a7 39 ff ff       	call   804f7d <tcp_timer_needed>
  8115d6:	e9 80 03 00 00       	jmp    81195b <tcp_input+0xdf4>
      } else {
        tcp_ack_now(pcb);
  8115db:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8115df:	89 1c 24             	mov    %ebx,(%esp)
  8115e2:	e8 74 9d ff ff       	call   80b35b <tcp_output>
        pcb->state = CLOSING;
  8115e7:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  8115ee:	66 90                	xchg   %ax,%ax
  8115f0:	e9 66 03 00 00       	jmp    81195b <tcp_input+0xdf4>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8115f5:	a8 10                	test   $0x10,%al
  8115f7:	0f 84 5e 03 00 00    	je     81195b <tcp_input+0xdf4>
  8115fd:	8b 43 54             	mov    0x54(%ebx),%eax
  811600:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  811606:	0f 85 4f 03 00 00    	jne    81195b <tcp_input+0xdf4>
      pcb->state = FIN_WAIT_2;
  81160c:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  811613:	e9 43 03 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  811618:	89 d8                	mov    %ebx,%eax
  81161a:	e8 d0 e8 ff ff       	call   80feef <tcp_receive>
    if (flags & TCP_FIN) {
  81161f:	f6 05 80 e5 b3 00 01 	testb  $0x1,0xb3e580
  811626:	0f 84 2f 03 00 00    	je     81195b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81162c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811630:	89 1c 24             	mov    %ebx,(%esp)
  811633:	e8 23 9d ff ff       	call   80b35b <tcp_output>
      tcp_pcb_purge(pcb);
  811638:	89 1c 24             	mov    %ebx,(%esp)
  81163b:	e8 87 74 ff ff       	call   808ac7 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  811640:	8b 15 08 e6 b3 00    	mov    0xb3e608,%edx
  811646:	39 d3                	cmp    %edx,%ebx
  811648:	75 0a                	jne    811654 <tcp_input+0xaed>
  81164a:	8b 43 0c             	mov    0xc(%ebx),%eax
  81164d:	a3 08 e6 b3 00       	mov    %eax,0xb3e608
  811652:	eb 2a                	jmp    81167e <tcp_input+0xb17>
  811654:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  81165a:	85 d2                	test   %edx,%edx
  81165c:	74 20                	je     81167e <tcp_input+0xb17>
  81165e:	8b 42 0c             	mov    0xc(%edx),%eax
  811661:	85 c0                	test   %eax,%eax
  811663:	0f 84 dd 02 00 00    	je     811946 <tcp_input+0xddf>
  811669:	39 c3                	cmp    %eax,%ebx
  81166b:	75 08                	jne    811675 <tcp_input+0xb0e>
  81166d:	8b 43 0c             	mov    0xc(%ebx),%eax
  811670:	89 42 0c             	mov    %eax,0xc(%edx)
  811673:	eb 09                	jmp    81167e <tcp_input+0xb17>
  811675:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  81167a:	89 c2                	mov    %eax,%edx
  81167c:	eb e0                	jmp    81165e <tcp_input+0xaf7>
  81167e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  811685:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81168c:	a1 1c e6 b3 00       	mov    0xb3e61c,%eax
  811691:	89 43 0c             	mov    %eax,0xc(%ebx)
  811694:	89 1d 1c e6 b3 00    	mov    %ebx,0xb3e61c
  81169a:	e8 de 38 ff ff       	call   804f7d <tcp_timer_needed>
  81169f:	e9 b7 02 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  8116a4:	89 d8                	mov    %ebx,%eax
  8116a6:	e8 44 e8 ff ff       	call   80feef <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8116ab:	f6 05 80 e5 b3 00 10 	testb  $0x10,0xb3e580
  8116b2:	0f 84 a3 02 00 00    	je     81195b <tcp_input+0xdf4>
  8116b8:	8b 43 54             	mov    0x54(%ebx),%eax
  8116bb:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  8116c1:	0f 85 94 02 00 00    	jne    81195b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8116c7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8116cb:	89 1c 24             	mov    %ebx,(%esp)
  8116ce:	e8 88 9c ff ff       	call   80b35b <tcp_output>
      tcp_pcb_purge(pcb);
  8116d3:	89 1c 24             	mov    %ebx,(%esp)
  8116d6:	e8 ec 73 ff ff       	call   808ac7 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8116db:	a1 08 e6 b3 00       	mov    0xb3e608,%eax
  8116e0:	39 c3                	cmp    %eax,%ebx
  8116e2:	75 0a                	jne    8116ee <tcp_input+0xb87>
  8116e4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8116e7:	a3 08 e6 b3 00       	mov    %eax,0xb3e608
  8116ec:	eb 2a                	jmp    811718 <tcp_input+0xbb1>
  8116ee:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  8116f3:	85 c0                	test   %eax,%eax
  8116f5:	74 21                	je     811718 <tcp_input+0xbb1>
  8116f7:	8b 50 0c             	mov    0xc(%eax),%edx
  8116fa:	85 d2                	test   %edx,%edx
  8116fc:	0f 84 4e 02 00 00    	je     811950 <tcp_input+0xde9>
  811702:	39 d3                	cmp    %edx,%ebx
  811704:	75 08                	jne    81170e <tcp_input+0xba7>
  811706:	8b 53 0c             	mov    0xc(%ebx),%edx
  811709:	89 50 0c             	mov    %edx,0xc(%eax)
  81170c:	eb 0a                	jmp    811718 <tcp_input+0xbb1>
  81170e:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  811714:	89 d0                	mov    %edx,%eax
  811716:	eb df                	jmp    8116f7 <tcp_input+0xb90>
  811718:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  81171f:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  811726:	a1 1c e6 b3 00       	mov    0xb3e61c,%eax
  81172b:	89 43 0c             	mov    %eax,0xc(%ebx)
  81172e:	89 1d 1c e6 b3 00    	mov    %ebx,0xb3e61c
  811734:	e8 44 38 ff ff       	call   804f7d <tcp_timer_needed>
  811739:	e9 1d 02 00 00       	jmp    81195b <tcp_input+0xdf4>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  81173e:	89 d8                	mov    %ebx,%eax
  811740:	e8 aa e7 ff ff       	call   80feef <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811745:	f6 05 80 e5 b3 00 10 	testb  $0x10,0xb3e580
  81174c:	0f 84 09 02 00 00    	je     81195b <tcp_input+0xdf4>
  811752:	8b 43 54             	mov    0x54(%ebx),%eax
  811755:	3b 05 7c e5 b3 00    	cmp    0xb3e57c,%eax
  81175b:	0f 85 fa 01 00 00    	jne    81195b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  811761:	c6 05 84 e5 b3 00 10 	movb   $0x10,0xb3e584
  811768:	e9 ee 01 00 00       	jmp    81195b <tcp_input+0xdf4>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81176d:	c7 05 24 e6 b3 00 00 	movl   $0x0,0xb3e624
  811774:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  811777:	0f b6 05 84 e5 b3 00 	movzbl 0xb3e584,%eax
  81177e:	a8 08                	test   $0x8,%al
  811780:	74 3f                	je     8117c1 <tcp_input+0xc5a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  811782:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  811788:	85 c0                	test   %eax,%eax
  81178a:	74 10                	je     81179c <tcp_input+0xc35>
  81178c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  811793:	ff 
  811794:	8b 53 18             	mov    0x18(%ebx),%edx
  811797:	89 14 24             	mov    %edx,(%esp)
  81179a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81179c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117a0:	c7 04 24 08 e6 b3 00 	movl   $0xb3e608,(%esp)
  8117a7:	e8 94 73 ff ff       	call   808b40 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  8117ac:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117b0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8117b7:	e8 84 5f ff ff       	call   807740 <memp_free>
  8117bc:	e9 fc 00 00 00       	jmp    8118bd <tcp_input+0xd56>
      } else if (recv_flags & TF_CLOSED) {
  8117c1:	a8 10                	test   $0x10,%al
  8117c3:	74 25                	je     8117ea <tcp_input+0xc83>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8117c5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117c9:	c7 04 24 08 e6 b3 00 	movl   $0xb3e608,(%esp)
  8117d0:	e8 6b 73 ff ff       	call   808b40 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  8117d5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117d9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8117e0:	e8 5b 5f ff ff       	call   807740 <memp_free>
  8117e5:	e9 d3 00 00 00       	jmp    8118bd <tcp_input+0xd56>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8117ea:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  8117ee:	66 85 c0             	test   %ax,%ax
  8117f1:	74 1f                	je     811812 <tcp_input+0xcab>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8117f3:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  8117f9:	85 d2                	test   %edx,%edx
  8117fb:	74 15                	je     811812 <tcp_input+0xcab>
  8117fd:	0f b7 c0             	movzwl %ax,%eax
  811800:	89 44 24 08          	mov    %eax,0x8(%esp)
  811804:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811808:	8b 43 18             	mov    0x18(%ebx),%eax
  81180b:	89 04 24             	mov    %eax,(%esp)
  81180e:	ff d2                	call   *%edx
  811810:	eb 05                	jmp    811817 <tcp_input+0xcb0>
  811812:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  811817:	8b 15 88 e5 b3 00    	mov    0xb3e588,%edx
  81181d:	85 d2                	test   %edx,%edx
  81181f:	74 61                	je     811882 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
  811821:	f6 05 80 e5 b3 00 08 	testb  $0x8,0xb3e580
  811828:	74 04                	je     81182e <tcp_input+0xcc7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81182a:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81182e:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811834:	85 c0                	test   %eax,%eax
  811836:	74 24                	je     81185c <tcp_input+0xcf5>
  811838:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81183f:	00 
  811840:	8b 15 88 e5 b3 00    	mov    0xb3e588,%edx
  811846:	89 54 24 08          	mov    %edx,0x8(%esp)
  81184a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81184e:	8b 53 18             	mov    0x18(%ebx),%edx
  811851:	89 14 24             	mov    %edx,(%esp)
  811854:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  811856:	84 c0                	test   %al,%al
  811858:	75 1c                	jne    811876 <tcp_input+0xd0f>
  81185a:	eb 26                	jmp    811882 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81185c:	a1 88 e5 b3 00       	mov    0xb3e588,%eax
  811861:	85 c0                	test   %eax,%eax
  811863:	0f 84 01 01 00 00    	je     81196a <tcp_input+0xe03>
  811869:	89 04 24             	mov    %eax,(%esp)
  81186c:	e8 67 66 ff ff       	call   807ed8 <pbuf_free>
  811871:	e9 f4 00 00 00       	jmp    81196a <tcp_input+0xe03>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  811876:	8b 15 88 e5 b3 00    	mov    0xb3e588,%edx
  81187c:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  811882:	f6 05 84 e5 b3 00 20 	testb  $0x20,0xb3e584
  811889:	74 26                	je     8118b1 <tcp_input+0xd4a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81188b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811891:	85 c0                	test   %eax,%eax
  811893:	74 20                	je     8118b5 <tcp_input+0xd4e>
  811895:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81189c:	00 
  81189d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8118a4:	00 
  8118a5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8118a9:	8b 53 18             	mov    0x18(%ebx),%edx
  8118ac:	89 14 24             	mov    %edx,(%esp)
  8118af:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  8118b1:	84 c0                	test   %al,%al
  8118b3:	75 08                	jne    8118bd <tcp_input+0xd56>
          tcp_output(pcb);
  8118b5:	89 1c 24             	mov    %ebx,(%esp)
  8118b8:	e8 9e 9a ff ff       	call   80b35b <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  8118bd:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  8118c2:	85 c0                	test   %eax,%eax
  8118c4:	0f 84 aa 00 00 00    	je     811974 <tcp_input+0xe0d>
    {
      pbuf_free(inseg.p);
  8118ca:	89 04 24             	mov    %eax,(%esp)
  8118cd:	e8 06 66 ff ff       	call   807ed8 <pbuf_free>
      inseg.p = NULL;
  8118d2:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  8118d9:	00 00 00 
  8118dc:	e9 93 00 00 00       	jmp    811974 <tcp_input+0xe0d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  8118e1:	a1 70 e5 b3 00       	mov    0xb3e570,%eax
  8118e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8118ea:	89 04 24             	mov    %eax,(%esp)
  8118ed:	e8 ef 93 ff ff       	call   80ace1 <ntohs>
  8118f2:	a8 04                	test   $0x4,%al
  8118f4:	75 46                	jne    81193c <tcp_input+0xdd5>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  8118f6:	8b 15 70 e5 b3 00    	mov    0xb3e570,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  8118fc:	a1 74 e5 b3 00       	mov    0xb3e574,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  811901:	0f b7 0a             	movzwl (%edx),%ecx
  811904:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  811908:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  81190c:	89 54 24 10          	mov    %edx,0x10(%esp)
  811910:	8d 50 0c             	lea    0xc(%eax),%edx
  811913:	89 54 24 0c          	mov    %edx,0xc(%esp)
  811917:	83 c0 10             	add    $0x10,%eax
  81191a:	89 44 24 08          	mov    %eax,0x8(%esp)
  81191e:	0f b7 05 82 e5 b3 00 	movzwl 0xb3e582,%eax
  811925:	03 05 78 e5 b3 00    	add    0xb3e578,%eax
  81192b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81192f:	a1 7c e5 b3 00       	mov    0xb3e57c,%eax
  811934:	89 04 24             	mov    %eax,(%esp)
  811937:	e8 c0 98 ff ff       	call   80b1fc <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81193c:	89 34 24             	mov    %esi,(%esp)
  81193f:	e8 94 65 ff ff       	call   807ed8 <pbuf_free>
  811944:	eb 2e                	jmp    811974 <tcp_input+0xe0d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811946:	a3 14 e6 b3 00       	mov    %eax,0xb3e614
  81194b:	e9 2e fd ff ff       	jmp    81167e <tcp_input+0xb17>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811950:	89 15 14 e6 b3 00    	mov    %edx,0xb3e614
  811956:	e9 bd fd ff ff       	jmp    811718 <tcp_input+0xbb1>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81195b:	c7 05 24 e6 b3 00 00 	movl   $0x0,0xb3e624
  811962:	00 00 00 
  811965:	e9 0d fe ff ff       	jmp    811777 <tcp_input+0xc10>
  81196a:	b8 00 00 00 00       	mov    $0x0,%eax
  81196f:	e9 0e ff ff ff       	jmp    811882 <tcp_input+0xd1b>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  811974:	83 c4 5c             	add    $0x5c,%esp
  811977:	5b                   	pop    %ebx
  811978:	5e                   	pop    %esi
  811979:	5f                   	pop    %edi
  81197a:	5d                   	pop    %ebp
  81197b:	c3                   	ret    
  81197c:	00 00                	add    %al,(%eax)
	...

00811980 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811980:	55                   	push   %ebp
  811981:	89 e5                	mov    %esp,%ebp
  811983:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  811986:	b8 00 00 00 00       	mov    $0x0,%eax
  81198b:	85 d2                	test   %edx,%edx
  81198d:	74 02                	je     811991 <raw_bind+0x11>
  81198f:	8b 02                	mov    (%edx),%eax
  811991:	8b 55 08             	mov    0x8(%ebp),%edx
  811994:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  811996:	b8 00 00 00 00       	mov    $0x0,%eax
  81199b:	5d                   	pop    %ebp
  81199c:	c3                   	ret    

0081199d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81199d:	55                   	push   %ebp
  81199e:	89 e5                	mov    %esp,%ebp
  8119a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  8119a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8119a8:	85 d2                	test   %edx,%edx
  8119aa:	74 02                	je     8119ae <raw_connect+0x11>
  8119ac:	8b 02                	mov    (%edx),%eax
  8119ae:	8b 55 08             	mov    0x8(%ebp),%edx
  8119b1:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  8119b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8119b9:	5d                   	pop    %ebp
  8119ba:	c3                   	ret    

008119bb <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  8119bb:	55                   	push   %ebp
  8119bc:	89 e5                	mov    %esp,%ebp
  8119be:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8119c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8119c4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  8119c7:	8b 55 10             	mov    0x10(%ebp),%edx
  8119ca:	89 50 18             	mov    %edx,0x18(%eax)
}
  8119cd:	5d                   	pop    %ebp
  8119ce:	c3                   	ret    

008119cf <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  8119cf:	55                   	push   %ebp
  8119d0:	89 e5                	mov    %esp,%ebp
  8119d2:	83 ec 18             	sub    $0x18,%esp
  8119d5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8119d8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8119db:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  8119df:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119e6:	e8 99 5d ff ff       	call   807784 <memp_malloc>
  8119eb:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  8119ed:	85 c0                	test   %eax,%eax
  8119ef:	74 2f                	je     811a20 <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8119f1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8119f8:	00 
  8119f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811a00:	00 
  811a01:	89 04 24             	mov    %eax,(%esp)
  811a04:	e8 6d f8 fe ff       	call   801276 <memset>
    pcb->protocol = proto;
  811a09:	89 f0                	mov    %esi,%eax
  811a0b:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  811a0e:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  811a12:	a1 8c e5 b3 00       	mov    0xb3e58c,%eax
  811a17:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  811a1a:	89 1d 8c e5 b3 00    	mov    %ebx,0xb3e58c
  }
  return pcb;
}
  811a20:	89 d8                	mov    %ebx,%eax
  811a22:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  811a25:	8b 75 fc             	mov    -0x4(%ebp),%esi
  811a28:	89 ec                	mov    %ebp,%esp
  811a2a:	5d                   	pop    %ebp
  811a2b:	c3                   	ret    

00811a2c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  811a2c:	55                   	push   %ebp
  811a2d:	89 e5                	mov    %esp,%ebp
  811a2f:	83 ec 18             	sub    $0x18,%esp
  811a32:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811a35:	8b 15 8c e5 b3 00    	mov    0xb3e58c,%edx
  811a3b:	39 ca                	cmp    %ecx,%edx
  811a3d:	74 06                	je     811a45 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811a3f:	85 d2                	test   %edx,%edx
  811a41:	75 0e                	jne    811a51 <raw_remove+0x25>
  811a43:	eb 21                	jmp    811a66 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  811a45:	8b 42 0c             	mov    0xc(%edx),%eax
  811a48:	a3 8c e5 b3 00       	mov    %eax,0xb3e58c
  811a4d:	eb 17                	jmp    811a66 <raw_remove+0x3a>
  811a4f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811a51:	8b 42 0c             	mov    0xc(%edx),%eax
  811a54:	85 c0                	test   %eax,%eax
  811a56:	74 0e                	je     811a66 <raw_remove+0x3a>
  811a58:	39 c1                	cmp    %eax,%ecx
  811a5a:	75 f3                	jne    811a4f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  811a5c:	8b 41 0c             	mov    0xc(%ecx),%eax
  811a5f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811a62:	85 c0                	test   %eax,%eax
  811a64:	75 e9                	jne    811a4f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811a66:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  811a6a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811a71:	e8 ca 5c ff ff       	call   807740 <memp_free>
}
  811a76:	c9                   	leave  
  811a77:	c3                   	ret    

00811a78 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811a78:	55                   	push   %ebp
  811a79:	89 e5                	mov    %esp,%ebp
  811a7b:	57                   	push   %edi
  811a7c:	56                   	push   %esi
  811a7d:	53                   	push   %ebx
  811a7e:	83 ec 3c             	sub    $0x3c,%esp
  811a81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811a84:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811a87:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811a8e:	00 
  811a8f:	89 3c 24             	mov    %edi,(%esp)
  811a92:	e8 cc 60 ff ff       	call   807b63 <pbuf_header>
  811a97:	84 c0                	test   %al,%al
  811a99:	74 38                	je     811ad3 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  811a9b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811aa2:	00 
  811aa3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811aaa:	00 
  811aab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811ab2:	e8 dc 66 ff ff       	call   808193 <pbuf_alloc>
  811ab7:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  811ab9:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  811abd:	85 c0                	test   %eax,%eax
  811abf:	0f 84 b1 00 00 00    	je     811b76 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  811ac5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811ac9:	89 04 24             	mov    %eax,(%esp)
  811acc:	e8 6b 60 ff ff       	call   807b3c <pbuf_chain>
  811ad1:	eb 32                	jmp    811b05 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  811ad3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  811ada:	ff 
  811adb:	89 3c 24             	mov    %edi,(%esp)
  811ade:	e8 80 60 ff ff       	call   807b63 <pbuf_header>
  811ae3:	84 c0                	test   %al,%al
  811ae5:	74 1c                	je     811b03 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  811ae7:	c7 44 24 08 8c 4e 81 	movl   $0x814e8c,0x8(%esp)
  811aee:	00 
  811aef:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  811af6:	00 
  811af7:	c7 04 24 b2 4e 81 00 	movl   $0x814eb2,(%esp)
  811afe:	e8 79 ee fe ff       	call   80097c <_panic>
  811b03:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  811b05:	8b 45 10             	mov    0x10(%ebp),%eax
  811b08:	89 04 24             	mov    %eax,(%esp)
  811b0b:	e8 b1 7f ff ff       	call   809ac1 <ip_route>
  811b10:	85 c0                	test   %eax,%eax
  811b12:	75 16                	jne    811b2a <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  811b14:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811b18:	39 fe                	cmp    %edi,%esi
  811b1a:	74 5a                	je     811b76 <raw_sendto+0xfe>
      pbuf_free(q);
  811b1c:	89 34 24             	mov    %esi,(%esp)
  811b1f:	e8 b4 63 ff ff       	call   807ed8 <pbuf_free>
  811b24:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811b28:	eb 4c                	jmp    811b76 <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  811b2a:	89 da                	mov    %ebx,%edx
  811b2c:	85 db                	test   %ebx,%ebx
  811b2e:	74 05                	je     811b35 <raw_sendto+0xbd>
  811b30:	83 3b 00             	cmpl   $0x0,(%ebx)
  811b33:	75 03                	jne    811b38 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811b35:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  811b38:	89 44 24 18          	mov    %eax,0x18(%esp)
  811b3c:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811b40:	89 44 24 14          	mov    %eax,0x14(%esp)
  811b44:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  811b48:	89 44 24 10          	mov    %eax,0x10(%esp)
  811b4c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811b50:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811b54:	8b 45 10             	mov    0x10(%ebp),%eax
  811b57:	89 44 24 08          	mov    %eax,0x8(%esp)
  811b5b:	89 54 24 04          	mov    %edx,0x4(%esp)
  811b5f:	89 34 24             	mov    %esi,(%esp)
  811b62:	e8 a9 7d ff ff       	call   809910 <ip_output_if>
  811b67:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  811b6a:	39 fe                	cmp    %edi,%esi
  811b6c:	74 08                	je     811b76 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  811b6e:	89 34 24             	mov    %esi,(%esp)
  811b71:	e8 62 63 ff ff       	call   807ed8 <pbuf_free>
  }
  return err;
}
  811b76:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  811b7a:	83 c4 3c             	add    $0x3c,%esp
  811b7d:	5b                   	pop    %ebx
  811b7e:	5e                   	pop    %esi
  811b7f:	5f                   	pop    %edi
  811b80:	5d                   	pop    %ebp
  811b81:	c3                   	ret    

00811b82 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811b82:	55                   	push   %ebp
  811b83:	89 e5                	mov    %esp,%ebp
  811b85:	83 ec 18             	sub    $0x18,%esp
  811b88:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  811b8b:	8d 50 04             	lea    0x4(%eax),%edx
  811b8e:	89 54 24 08          	mov    %edx,0x8(%esp)
  811b92:	8b 55 0c             	mov    0xc(%ebp),%edx
  811b95:	89 54 24 04          	mov    %edx,0x4(%esp)
  811b99:	89 04 24             	mov    %eax,(%esp)
  811b9c:	e8 d7 fe ff ff       	call   811a78 <raw_sendto>
}
  811ba1:	c9                   	leave  
  811ba2:	c3                   	ret    

00811ba3 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  811ba3:	55                   	push   %ebp
  811ba4:	89 e5                	mov    %esp,%ebp
  811ba6:	57                   	push   %edi
  811ba7:	56                   	push   %esi
  811ba8:	53                   	push   %ebx
  811ba9:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  811bac:	8b 45 08             	mov    0x8(%ebp),%eax
  811baf:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  811bb2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811bb6:	89 04 24             	mov    %eax,(%esp)
  811bb9:	e8 23 91 ff ff       	call   80ace1 <ntohs>
  811bbe:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  811bc2:	8b 1d 8c e5 b3 00    	mov    0xb3e58c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811bc8:	85 db                	test   %ebx,%ebx
  811bca:	74 6c                	je     811c38 <raw_input+0x95>
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811bcc:	83 c6 0c             	add    $0xc,%esi
  811bcf:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  811bd2:	be 00 00 00 00       	mov    $0x0,%esi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  811bd7:	0f bf f8             	movswl %ax,%edi
  811bda:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811bde:	39 f8                	cmp    %edi,%eax
  811be0:	75 49                	jne    811c2b <raw_input+0x88>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  811be2:	8b 43 14             	mov    0x14(%ebx),%eax
  811be5:	85 c0                	test   %eax,%eax
  811be7:	74 42                	je     811c2b <raw_input+0x88>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811be9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811bec:	89 54 24 0c          	mov    %edx,0xc(%esp)
  811bf0:	8b 55 08             	mov    0x8(%ebp),%edx
  811bf3:	89 54 24 08          	mov    %edx,0x8(%esp)
  811bf7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811bfb:	8b 53 18             	mov    0x18(%ebx),%edx
  811bfe:	89 14 24             	mov    %edx,(%esp)
  811c01:	ff d0                	call   *%eax
  811c03:	84 c0                	test   %al,%al
  811c05:	74 24                	je     811c2b <raw_input+0x88>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  811c07:	b8 01 00 00 00       	mov    $0x1,%eax
  811c0c:	85 f6                	test   %esi,%esi
  811c0e:	74 2d                	je     811c3d <raw_input+0x9a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  811c10:	8b 43 0c             	mov    0xc(%ebx),%eax
  811c13:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  811c16:	a1 8c e5 b3 00       	mov    0xb3e58c,%eax
  811c1b:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  811c1e:	89 1d 8c e5 b3 00    	mov    %ebx,0xb3e58c
  811c24:	b8 01 00 00 00       	mov    $0x1,%eax
  811c29:	eb 12                	jmp    811c3d <raw_input+0x9a>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  811c2b:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811c2e:	85 c0                	test   %eax,%eax
  811c30:	74 06                	je     811c38 <raw_input+0x95>
  811c32:	89 de                	mov    %ebx,%esi
  811c34:	89 c3                	mov    %eax,%ebx
  811c36:	eb a2                	jmp    811bda <raw_input+0x37>
  811c38:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  811c3d:	83 c4 2c             	add    $0x2c,%esp
  811c40:	5b                   	pop    %ebx
  811c41:	5e                   	pop    %esi
  811c42:	5f                   	pop    %edi
  811c43:	5d                   	pop    %ebp
  811c44:	c3                   	ret    
	...

00811c50 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811c50:	55                   	push   %ebp
  811c51:	89 e5                	mov    %esp,%ebp
  811c53:	57                   	push   %edi
  811c54:	56                   	push   %esi
  811c55:	53                   	push   %ebx
  811c56:	83 ec 3c             	sub    $0x3c,%esp
  811c59:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811c5c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811c63:	00 
  811c64:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811c6b:	00 
  811c6c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811c73:	e8 1b 65 ff ff       	call   808193 <pbuf_alloc>
  811c78:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811c7a:	85 c0                	test   %eax,%eax
  811c7c:	0f 84 d8 00 00 00    	je     811d5a <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811c82:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811c87:	77 1c                	ja     811ca5 <icmp_time_exceeded+0x55>
  811c89:	c7 44 24 08 c8 4e 81 	movl   $0x814ec8,0x8(%esp)
  811c90:	00 
  811c91:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  811c98:	00 
  811c99:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  811ca0:	e8 d7 ec fe ff       	call   80097c <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811ca5:	8b 47 04             	mov    0x4(%edi),%eax
  811ca8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  811cab:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  811cae:	0f b7 06             	movzwl (%esi),%eax
  811cb1:	89 04 24             	mov    %eax,(%esp)
  811cb4:	e8 28 90 ff ff       	call   80ace1 <ntohs>
  811cb9:	0f b6 c0             	movzbl %al,%eax
  811cbc:	80 cc 0b             	or     $0xb,%ah
  811cbf:	89 04 24             	mov    %eax,(%esp)
  811cc2:	e8 0d 90 ff ff       	call   80acd4 <htons>
  811cc7:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  811cca:	0f b7 c0             	movzwl %ax,%eax
  811ccd:	89 04 24             	mov    %eax,(%esp)
  811cd0:	e8 0c 90 ff ff       	call   80ace1 <ntohs>
  811cd5:	b0 00                	mov    $0x0,%al
  811cd7:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811cdb:	0f b7 c0             	movzwl %ax,%eax
  811cde:	89 04 24             	mov    %eax,(%esp)
  811ce1:	e8 ee 8f ff ff       	call   80acd4 <htons>
  811ce6:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  811ce9:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811cf0:	00 
  811cf1:	8b 47 04             	mov    0x4(%edi),%eax
  811cf4:	89 44 24 04          	mov    %eax,0x4(%esp)
  811cf8:	8b 43 04             	mov    0x4(%ebx),%eax
  811cfb:	83 c0 08             	add    $0x8,%eax
  811cfe:	89 04 24             	mov    %eax,(%esp)
  811d01:	e8 4b f6 fe ff       	call   801351 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  811d06:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  811d0c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811d10:	89 44 24 04          	mov    %eax,0x4(%esp)
  811d14:	89 34 24             	mov    %esi,(%esp)
  811d17:	e8 9e 8c ff ff       	call   80a9ba <inet_chksum>
  811d1c:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811d20:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811d27:	00 
  811d28:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811d2f:	00 
  811d30:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811d37:	00 
  811d38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811d3b:	83 c0 0c             	add    $0xc,%eax
  811d3e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811d42:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811d49:	00 
  811d4a:	89 1c 24             	mov    %ebx,(%esp)
  811d4d:	e8 cb 7d ff ff       	call   809b1d <ip_output>
  pbuf_free(q);
  811d52:	89 1c 24             	mov    %ebx,(%esp)
  811d55:	e8 7e 61 ff ff       	call   807ed8 <pbuf_free>
}
  811d5a:	83 c4 3c             	add    $0x3c,%esp
  811d5d:	5b                   	pop    %ebx
  811d5e:	5e                   	pop    %esi
  811d5f:	5f                   	pop    %edi
  811d60:	5d                   	pop    %ebp
  811d61:	c3                   	ret    

00811d62 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  811d62:	55                   	push   %ebp
  811d63:	89 e5                	mov    %esp,%ebp
  811d65:	57                   	push   %edi
  811d66:	56                   	push   %esi
  811d67:	53                   	push   %ebx
  811d68:	83 ec 3c             	sub    $0x3c,%esp
  811d6b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811d6e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811d75:	00 
  811d76:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811d7d:	00 
  811d7e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811d85:	e8 09 64 ff ff       	call   808193 <pbuf_alloc>
  811d8a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811d8c:	85 c0                	test   %eax,%eax
  811d8e:	0f 84 d8 00 00 00    	je     811e6c <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811d94:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811d99:	77 1c                	ja     811db7 <icmp_dest_unreach+0x55>
  811d9b:	c7 44 24 08 c8 4e 81 	movl   $0x814ec8,0x8(%esp)
  811da2:	00 
  811da3:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  811daa:	00 
  811dab:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  811db2:	e8 c5 eb fe ff       	call   80097c <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811db7:	8b 47 04             	mov    0x4(%edi),%eax
  811dba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  811dbd:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  811dc0:	0f b7 06             	movzwl (%esi),%eax
  811dc3:	89 04 24             	mov    %eax,(%esp)
  811dc6:	e8 16 8f ff ff       	call   80ace1 <ntohs>
  811dcb:	0f b6 c0             	movzbl %al,%eax
  811dce:	80 cc 03             	or     $0x3,%ah
  811dd1:	89 04 24             	mov    %eax,(%esp)
  811dd4:	e8 fb 8e ff ff       	call   80acd4 <htons>
  811dd9:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  811ddc:	0f b7 c0             	movzwl %ax,%eax
  811ddf:	89 04 24             	mov    %eax,(%esp)
  811de2:	e8 fa 8e ff ff       	call   80ace1 <ntohs>
  811de7:	b0 00                	mov    $0x0,%al
  811de9:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811ded:	0f b7 c0             	movzwl %ax,%eax
  811df0:	89 04 24             	mov    %eax,(%esp)
  811df3:	e8 dc 8e ff ff       	call   80acd4 <htons>
  811df8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  811dfb:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811e02:	00 
  811e03:	8b 47 04             	mov    0x4(%edi),%eax
  811e06:	89 44 24 04          	mov    %eax,0x4(%esp)
  811e0a:	8b 43 04             	mov    0x4(%ebx),%eax
  811e0d:	83 c0 08             	add    $0x8,%eax
  811e10:	89 04 24             	mov    %eax,(%esp)
  811e13:	e8 39 f5 fe ff       	call   801351 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  811e18:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  811e1e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811e22:	89 44 24 04          	mov    %eax,0x4(%esp)
  811e26:	89 34 24             	mov    %esi,(%esp)
  811e29:	e8 8c 8b ff ff       	call   80a9ba <inet_chksum>
  811e2e:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811e32:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811e39:	00 
  811e3a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811e41:	00 
  811e42:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811e49:	00 
  811e4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811e4d:	83 c0 0c             	add    $0xc,%eax
  811e50:	89 44 24 08          	mov    %eax,0x8(%esp)
  811e54:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811e5b:	00 
  811e5c:	89 1c 24             	mov    %ebx,(%esp)
  811e5f:	e8 b9 7c ff ff       	call   809b1d <ip_output>
  pbuf_free(q);
  811e64:	89 1c 24             	mov    %ebx,(%esp)
  811e67:	e8 6c 60 ff ff       	call   807ed8 <pbuf_free>
}
  811e6c:	83 c4 3c             	add    $0x3c,%esp
  811e6f:	5b                   	pop    %ebx
  811e70:	5e                   	pop    %esi
  811e71:	5f                   	pop    %edi
  811e72:	5d                   	pop    %ebp
  811e73:	c3                   	ret    

00811e74 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811e74:	55                   	push   %ebp
  811e75:	89 e5                	mov    %esp,%ebp
  811e77:	83 ec 48             	sub    $0x48,%esp
  811e7a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811e7d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811e80:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811e83:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811e86:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  811e89:	0f b7 06             	movzwl (%esi),%eax
  811e8c:	89 04 24             	mov    %eax,(%esp)
  811e8f:	e8 4d 8e ff ff       	call   80ace1 <ntohs>
  811e94:	66 c1 e8 06          	shr    $0x6,%ax
  811e98:	83 e0 3c             	and    $0x3c,%eax
  811e9b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  811e9f:	89 c7                	mov    %eax,%edi
  811ea1:	f7 df                	neg    %edi
  811ea3:	0f bf ff             	movswl %di,%edi
  811ea6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811eaa:	89 1c 24             	mov    %ebx,(%esp)
  811ead:	e8 b1 5c ff ff       	call   807b63 <pbuf_header>
  811eb2:	84 c0                	test   %al,%al
  811eb4:	0f 85 ee 02 00 00    	jne    8121a8 <icmp_input+0x334>
  811eba:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  811ebf:	0f 86 e3 02 00 00    	jbe    8121a8 <icmp_input+0x334>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  811ec5:	8b 43 04             	mov    0x4(%ebx),%eax
  811ec8:	80 38 08             	cmpb   $0x8,(%eax)
  811ecb:	0f 85 cd 02 00 00    	jne    81219e <icmp_input+0x32a>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  811ed1:	8b 45 0c             	mov    0xc(%ebp),%eax
  811ed4:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ed8:	8d 46 10             	lea    0x10(%esi),%eax
  811edb:	89 04 24             	mov    %eax,(%esp)
  811ede:	e8 e5 79 ff ff       	call   8098c8 <ip_addr_isbroadcast>
  811ee3:	84 c0                	test   %al,%al
  811ee5:	75 2b                	jne    811f12 <icmp_input+0x9e>
  811ee7:	8b 56 10             	mov    0x10(%esi),%edx
  811eea:	89 55 dc             	mov    %edx,-0x24(%ebp)
  811eed:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  811ef4:	e8 21 90 ff ff       	call   80af1a <ntohl>
  811ef9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  811efc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  811f03:	e8 12 90 ff ff       	call   80af1a <ntohl>
  811f08:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811f0b:	23 55 dc             	and    -0x24(%ebp),%edx
  811f0e:	39 c2                	cmp    %eax,%edx
  811f10:	75 0d                	jne    811f1f <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  811f12:	89 1c 24             	mov    %ebx,(%esp)
  811f15:	e8 be 5f ff ff       	call   807ed8 <pbuf_free>
      return;
  811f1a:	e9 9b 02 00 00       	jmp    8121ba <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  811f1f:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  811f24:	0f 86 7e 02 00 00    	jbe    8121a8 <icmp_input+0x334>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811f2a:	89 1c 24             	mov    %ebx,(%esp)
  811f2d:	8d 76 00             	lea    0x0(%esi),%esi
  811f30:	e8 00 8a ff ff       	call   80a935 <inet_chksum_pbuf>
  811f35:	66 85 c0             	test   %ax,%ax
  811f38:	74 0d                	je     811f47 <icmp_input+0xd3>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811f3a:	89 1c 24             	mov    %ebx,(%esp)
  811f3d:	e8 96 5f ff ff       	call   807ed8 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811f42:	e9 73 02 00 00       	jmp    8121ba <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811f47:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811f4e:	00 
  811f4f:	89 1c 24             	mov    %ebx,(%esp)
  811f52:	e8 0c 5c ff ff       	call   807b63 <pbuf_header>
  811f57:	84 c0                	test   %al,%al
  811f59:	0f 84 f0 00 00 00    	je     81204f <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811f5f:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811f63:	89 44 24 04          	mov    %eax,0x4(%esp)
  811f67:	89 1c 24             	mov    %ebx,(%esp)
  811f6a:	e8 f4 5b ff ff       	call   807b63 <pbuf_header>
  811f6f:	84 c0                	test   %al,%al
  811f71:	74 1c                	je     811f8f <icmp_input+0x11b>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811f73:	c7 44 24 08 f4 4e 81 	movl   $0x814ef4,0x8(%esp)
  811f7a:	00 
  811f7b:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  811f82:	00 
  811f83:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  811f8a:	e8 ed e9 fe ff       	call   80097c <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  811f8f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811f96:	00 
  811f97:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  811f9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  811f9f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811fa6:	e8 e8 61 ff ff       	call   808193 <pbuf_alloc>
  811fab:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  811fae:	85 c0                	test   %eax,%eax
  811fb0:	0f 84 fc 01 00 00    	je     8121b2 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  811fb6:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  811fba:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811fbe:	83 c0 08             	add    $0x8,%eax
  811fc1:	39 c2                	cmp    %eax,%edx
  811fc3:	73 1c                	jae    811fe1 <icmp_input+0x16d>
  811fc5:	c7 44 24 08 28 4f 81 	movl   $0x814f28,0x8(%esp)
  811fcc:	00 
  811fcd:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  811fd4:	00 
  811fd5:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  811fdc:	e8 9b e9 fe ff       	call   80097c <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  811fe1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811fe5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811fe8:	89 04 24             	mov    %eax,(%esp)
  811feb:	e8 35 5d ff ff       	call   807d25 <pbuf_copy>
  811ff0:	84 c0                	test   %al,%al
  811ff2:	74 1c                	je     812010 <icmp_input+0x19c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  811ff4:	c7 44 24 08 60 4f 81 	movl   $0x814f60,0x8(%esp)
  811ffb:	00 
  811ffc:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  812003:	00 
  812004:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  81200b:	e8 6c e9 fe ff       	call   80097c <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  812010:	8b 55 e0             	mov    -0x20(%ebp),%edx
  812013:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  812016:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81201a:	89 14 24             	mov    %edx,(%esp)
  81201d:	e8 41 5b ff ff       	call   807b63 <pbuf_header>
  812022:	84 c0                	test   %al,%al
  812024:	74 1c                	je     812042 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  812026:	c7 44 24 08 88 4f 81 	movl   $0x814f88,0x8(%esp)
  81202d:	00 
  81202e:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  812035:	00 
  812036:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  81203d:	e8 3a e9 fe ff       	call   80097c <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  812042:	89 1c 24             	mov    %ebx,(%esp)
  812045:	e8 8e 5e ff ff       	call   807ed8 <pbuf_free>
  81204a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  81204d:	eb 30                	jmp    81207f <icmp_input+0x20b>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81204f:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  812056:	ff 
  812057:	89 1c 24             	mov    %ebx,(%esp)
  81205a:	e8 04 5b ff ff       	call   807b63 <pbuf_header>
  81205f:	84 c0                	test   %al,%al
  812061:	74 1c                	je     81207f <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  812063:	c7 44 24 08 88 4f 81 	movl   $0x814f88,0x8(%esp)
  81206a:	00 
  81206b:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  812072:	00 
  812073:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  81207a:	e8 fd e8 fe ff       	call   80097c <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  81207f:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  812082:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  812085:	8b 56 10             	mov    0x10(%esi),%edx
  812088:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  81208b:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  81208e:	0f b7 07             	movzwl (%edi),%eax
  812091:	89 04 24             	mov    %eax,(%esp)
  812094:	e8 48 8c ff ff       	call   80ace1 <ntohs>
  812099:	0f b6 c0             	movzbl %al,%eax
  81209c:	89 04 24             	mov    %eax,(%esp)
  81209f:	e8 30 8c ff ff       	call   80acd4 <htons>
  8120a4:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  8120a7:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8120ab:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  8120af:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  8120b6:	e8 19 8c ff ff       	call   80acd4 <htons>
  8120bb:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  8120bf:	72 22                	jb     8120e3 <icmp_input+0x26f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  8120c1:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  8120c5:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  8120c9:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  8120d0:	e8 ff 8b ff ff       	call   80acd4 <htons>
  8120d5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  8120d9:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  8120dd:	66 89 47 02          	mov    %ax,0x2(%edi)
  8120e1:	eb 1c                	jmp    8120ff <icmp_input+0x28b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  8120e3:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8120e7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  8120eb:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  8120f2:	e8 dd 8b ff ff       	call   80acd4 <htons>
  8120f7:	66 03 45 e0          	add    -0x20(%ebp),%ax
  8120fb:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8120ff:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  812103:	89 04 24             	mov    %eax,(%esp)
  812106:	e8 d6 8b ff ff       	call   80ace1 <ntohs>
  81210b:	66 0d 00 ff          	or     $0xff00,%ax
  81210f:	0f b7 c0             	movzwl %ax,%eax
  812112:	89 04 24             	mov    %eax,(%esp)
  812115:	e8 ba 8b ff ff       	call   80acd4 <htons>
  81211a:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  81211e:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  812124:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  81212b:	00 
  81212c:	89 34 24             	mov    %esi,(%esp)
  81212f:	e8 86 88 ff ff       	call   80a9ba <inet_chksum>
  812134:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  812138:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  81213c:	89 44 24 04          	mov    %eax,0x4(%esp)
  812140:	89 1c 24             	mov    %ebx,(%esp)
  812143:	e8 1b 5a ff ff       	call   807b63 <pbuf_header>
  812148:	84 c0                	test   %al,%al
  81214a:	74 1c                	je     812168 <icmp_input+0x2f4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  81214c:	c7 44 24 08 cc 3f 81 	movl   $0x813fcc,0x8(%esp)
  812153:	00 
  812154:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  81215b:	00 
  81215c:	c7 04 24 bc 4f 81 00 	movl   $0x814fbc,(%esp)
  812163:	e8 14 e8 fe ff       	call   80097c <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  812168:	8b 55 0c             	mov    0xc(%ebp),%edx
  81216b:	89 54 24 18          	mov    %edx,0x18(%esp)
  81216f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  812176:	00 
  812177:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  81217e:	00 
  81217f:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  812186:	00 
  812187:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81218e:	00 
  81218f:	83 c6 0c             	add    $0xc,%esi
  812192:	89 74 24 04          	mov    %esi,0x4(%esp)
  812196:	89 1c 24             	mov    %ebx,(%esp)
  812199:	e8 72 77 ff ff       	call   809910 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  81219e:	89 1c 24             	mov    %ebx,(%esp)
  8121a1:	e8 32 5d ff ff       	call   807ed8 <pbuf_free>
  return;
  8121a6:	eb 12                	jmp    8121ba <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  8121a8:	89 1c 24             	mov    %ebx,(%esp)
  8121ab:	e8 28 5d ff ff       	call   807ed8 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8121b0:	eb 08                	jmp    8121ba <icmp_input+0x346>
memerr:
  pbuf_free(p);
  8121b2:	89 1c 24             	mov    %ebx,(%esp)
  8121b5:	e8 1e 5d ff ff       	call   807ed8 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  8121ba:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8121bd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8121c0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8121c3:	89 ec                	mov    %ebp,%esp
  8121c5:	5d                   	pop    %ebp
  8121c6:	c3                   	ret    
	...

008121d0 <__udivdi3>:
  8121d0:	55                   	push   %ebp
  8121d1:	89 e5                	mov    %esp,%ebp
  8121d3:	57                   	push   %edi
  8121d4:	56                   	push   %esi
  8121d5:	83 ec 10             	sub    $0x10,%esp
  8121d8:	8b 45 14             	mov    0x14(%ebp),%eax
  8121db:	8b 55 08             	mov    0x8(%ebp),%edx
  8121de:	8b 75 10             	mov    0x10(%ebp),%esi
  8121e1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8121e4:	85 c0                	test   %eax,%eax
  8121e6:	89 55 f0             	mov    %edx,-0x10(%ebp)
  8121e9:	75 35                	jne    812220 <__udivdi3+0x50>
  8121eb:	39 fe                	cmp    %edi,%esi
  8121ed:	77 61                	ja     812250 <__udivdi3+0x80>
  8121ef:	85 f6                	test   %esi,%esi
  8121f1:	75 0b                	jne    8121fe <__udivdi3+0x2e>
  8121f3:	b8 01 00 00 00       	mov    $0x1,%eax
  8121f8:	31 d2                	xor    %edx,%edx
  8121fa:	f7 f6                	div    %esi
  8121fc:	89 c6                	mov    %eax,%esi
  8121fe:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  812201:	31 d2                	xor    %edx,%edx
  812203:	89 f8                	mov    %edi,%eax
  812205:	f7 f6                	div    %esi
  812207:	89 c7                	mov    %eax,%edi
  812209:	89 c8                	mov    %ecx,%eax
  81220b:	f7 f6                	div    %esi
  81220d:	89 c1                	mov    %eax,%ecx
  81220f:	89 fa                	mov    %edi,%edx
  812211:	89 c8                	mov    %ecx,%eax
  812213:	83 c4 10             	add    $0x10,%esp
  812216:	5e                   	pop    %esi
  812217:	5f                   	pop    %edi
  812218:	5d                   	pop    %ebp
  812219:	c3                   	ret    
  81221a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  812220:	39 f8                	cmp    %edi,%eax
  812222:	77 1c                	ja     812240 <__udivdi3+0x70>
  812224:	0f bd d0             	bsr    %eax,%edx
  812227:	83 f2 1f             	xor    $0x1f,%edx
  81222a:	89 55 f4             	mov    %edx,-0xc(%ebp)
  81222d:	75 39                	jne    812268 <__udivdi3+0x98>
  81222f:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  812232:	0f 86 a0 00 00 00    	jbe    8122d8 <__udivdi3+0x108>
  812238:	39 f8                	cmp    %edi,%eax
  81223a:	0f 82 98 00 00 00    	jb     8122d8 <__udivdi3+0x108>
  812240:	31 ff                	xor    %edi,%edi
  812242:	31 c9                	xor    %ecx,%ecx
  812244:	89 c8                	mov    %ecx,%eax
  812246:	89 fa                	mov    %edi,%edx
  812248:	83 c4 10             	add    $0x10,%esp
  81224b:	5e                   	pop    %esi
  81224c:	5f                   	pop    %edi
  81224d:	5d                   	pop    %ebp
  81224e:	c3                   	ret    
  81224f:	90                   	nop
  812250:	89 d1                	mov    %edx,%ecx
  812252:	89 fa                	mov    %edi,%edx
  812254:	89 c8                	mov    %ecx,%eax
  812256:	31 ff                	xor    %edi,%edi
  812258:	f7 f6                	div    %esi
  81225a:	89 c1                	mov    %eax,%ecx
  81225c:	89 fa                	mov    %edi,%edx
  81225e:	89 c8                	mov    %ecx,%eax
  812260:	83 c4 10             	add    $0x10,%esp
  812263:	5e                   	pop    %esi
  812264:	5f                   	pop    %edi
  812265:	5d                   	pop    %ebp
  812266:	c3                   	ret    
  812267:	90                   	nop
  812268:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  81226c:	89 f2                	mov    %esi,%edx
  81226e:	d3 e0                	shl    %cl,%eax
  812270:	89 45 ec             	mov    %eax,-0x14(%ebp)
  812273:	b8 20 00 00 00       	mov    $0x20,%eax
  812278:	2b 45 f4             	sub    -0xc(%ebp),%eax
  81227b:	89 c1                	mov    %eax,%ecx
  81227d:	d3 ea                	shr    %cl,%edx
  81227f:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812283:	0b 55 ec             	or     -0x14(%ebp),%edx
  812286:	d3 e6                	shl    %cl,%esi
  812288:	89 c1                	mov    %eax,%ecx
  81228a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  81228d:	89 fe                	mov    %edi,%esi
  81228f:	d3 ee                	shr    %cl,%esi
  812291:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812295:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812298:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81229b:	d3 e7                	shl    %cl,%edi
  81229d:	89 c1                	mov    %eax,%ecx
  81229f:	d3 ea                	shr    %cl,%edx
  8122a1:	09 d7                	or     %edx,%edi
  8122a3:	89 f2                	mov    %esi,%edx
  8122a5:	89 f8                	mov    %edi,%eax
  8122a7:	f7 75 ec             	divl   -0x14(%ebp)
  8122aa:	89 d6                	mov    %edx,%esi
  8122ac:	89 c7                	mov    %eax,%edi
  8122ae:	f7 65 e8             	mull   -0x18(%ebp)
  8122b1:	39 d6                	cmp    %edx,%esi
  8122b3:	89 55 ec             	mov    %edx,-0x14(%ebp)
  8122b6:	72 30                	jb     8122e8 <__udivdi3+0x118>
  8122b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8122bb:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  8122bf:	d3 e2                	shl    %cl,%edx
  8122c1:	39 c2                	cmp    %eax,%edx
  8122c3:	73 05                	jae    8122ca <__udivdi3+0xfa>
  8122c5:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  8122c8:	74 1e                	je     8122e8 <__udivdi3+0x118>
  8122ca:	89 f9                	mov    %edi,%ecx
  8122cc:	31 ff                	xor    %edi,%edi
  8122ce:	e9 71 ff ff ff       	jmp    812244 <__udivdi3+0x74>
  8122d3:	90                   	nop
  8122d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8122d8:	31 ff                	xor    %edi,%edi
  8122da:	b9 01 00 00 00       	mov    $0x1,%ecx
  8122df:	e9 60 ff ff ff       	jmp    812244 <__udivdi3+0x74>
  8122e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8122e8:	8d 4f ff             	lea    -0x1(%edi),%ecx
  8122eb:	31 ff                	xor    %edi,%edi
  8122ed:	89 c8                	mov    %ecx,%eax
  8122ef:	89 fa                	mov    %edi,%edx
  8122f1:	83 c4 10             	add    $0x10,%esp
  8122f4:	5e                   	pop    %esi
  8122f5:	5f                   	pop    %edi
  8122f6:	5d                   	pop    %ebp
  8122f7:	c3                   	ret    
	...

00812300 <__umoddi3>:
  812300:	55                   	push   %ebp
  812301:	89 e5                	mov    %esp,%ebp
  812303:	57                   	push   %edi
  812304:	56                   	push   %esi
  812305:	83 ec 20             	sub    $0x20,%esp
  812308:	8b 55 14             	mov    0x14(%ebp),%edx
  81230b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81230e:	8b 7d 10             	mov    0x10(%ebp),%edi
  812311:	8b 75 0c             	mov    0xc(%ebp),%esi
  812314:	85 d2                	test   %edx,%edx
  812316:	89 c8                	mov    %ecx,%eax
  812318:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  81231b:	75 13                	jne    812330 <__umoddi3+0x30>
  81231d:	39 f7                	cmp    %esi,%edi
  81231f:	76 3f                	jbe    812360 <__umoddi3+0x60>
  812321:	89 f2                	mov    %esi,%edx
  812323:	f7 f7                	div    %edi
  812325:	89 d0                	mov    %edx,%eax
  812327:	31 d2                	xor    %edx,%edx
  812329:	83 c4 20             	add    $0x20,%esp
  81232c:	5e                   	pop    %esi
  81232d:	5f                   	pop    %edi
  81232e:	5d                   	pop    %ebp
  81232f:	c3                   	ret    
  812330:	39 f2                	cmp    %esi,%edx
  812332:	77 4c                	ja     812380 <__umoddi3+0x80>
  812334:	0f bd ca             	bsr    %edx,%ecx
  812337:	83 f1 1f             	xor    $0x1f,%ecx
  81233a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  81233d:	75 51                	jne    812390 <__umoddi3+0x90>
  81233f:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  812342:	0f 87 e0 00 00 00    	ja     812428 <__umoddi3+0x128>
  812348:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81234b:	29 f8                	sub    %edi,%eax
  81234d:	19 d6                	sbb    %edx,%esi
  81234f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  812352:	8b 45 f4             	mov    -0xc(%ebp),%eax
  812355:	89 f2                	mov    %esi,%edx
  812357:	83 c4 20             	add    $0x20,%esp
  81235a:	5e                   	pop    %esi
  81235b:	5f                   	pop    %edi
  81235c:	5d                   	pop    %ebp
  81235d:	c3                   	ret    
  81235e:	66 90                	xchg   %ax,%ax
  812360:	85 ff                	test   %edi,%edi
  812362:	75 0b                	jne    81236f <__umoddi3+0x6f>
  812364:	b8 01 00 00 00       	mov    $0x1,%eax
  812369:	31 d2                	xor    %edx,%edx
  81236b:	f7 f7                	div    %edi
  81236d:	89 c7                	mov    %eax,%edi
  81236f:	89 f0                	mov    %esi,%eax
  812371:	31 d2                	xor    %edx,%edx
  812373:	f7 f7                	div    %edi
  812375:	8b 45 f4             	mov    -0xc(%ebp),%eax
  812378:	f7 f7                	div    %edi
  81237a:	eb a9                	jmp    812325 <__umoddi3+0x25>
  81237c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812380:	89 c8                	mov    %ecx,%eax
  812382:	89 f2                	mov    %esi,%edx
  812384:	83 c4 20             	add    $0x20,%esp
  812387:	5e                   	pop    %esi
  812388:	5f                   	pop    %edi
  812389:	5d                   	pop    %ebp
  81238a:	c3                   	ret    
  81238b:	90                   	nop
  81238c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812390:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812394:	d3 e2                	shl    %cl,%edx
  812396:	89 55 f4             	mov    %edx,-0xc(%ebp)
  812399:	ba 20 00 00 00       	mov    $0x20,%edx
  81239e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  8123a1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  8123a4:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8123a8:	89 fa                	mov    %edi,%edx
  8123aa:	d3 ea                	shr    %cl,%edx
  8123ac:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123b0:	0b 55 f4             	or     -0xc(%ebp),%edx
  8123b3:	d3 e7                	shl    %cl,%edi
  8123b5:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8123b9:	89 55 f4             	mov    %edx,-0xc(%ebp)
  8123bc:	89 f2                	mov    %esi,%edx
  8123be:	89 7d e8             	mov    %edi,-0x18(%ebp)
  8123c1:	89 c7                	mov    %eax,%edi
  8123c3:	d3 ea                	shr    %cl,%edx
  8123c5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123c9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8123cc:	89 c2                	mov    %eax,%edx
  8123ce:	d3 e6                	shl    %cl,%esi
  8123d0:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8123d4:	d3 ea                	shr    %cl,%edx
  8123d6:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123da:	09 d6                	or     %edx,%esi
  8123dc:	89 f0                	mov    %esi,%eax
  8123de:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8123e1:	d3 e7                	shl    %cl,%edi
  8123e3:	89 f2                	mov    %esi,%edx
  8123e5:	f7 75 f4             	divl   -0xc(%ebp)
  8123e8:	89 d6                	mov    %edx,%esi
  8123ea:	f7 65 e8             	mull   -0x18(%ebp)
  8123ed:	39 d6                	cmp    %edx,%esi
  8123ef:	72 2b                	jb     81241c <__umoddi3+0x11c>
  8123f1:	39 c7                	cmp    %eax,%edi
  8123f3:	72 23                	jb     812418 <__umoddi3+0x118>
  8123f5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123f9:	29 c7                	sub    %eax,%edi
  8123fb:	19 d6                	sbb    %edx,%esi
  8123fd:	89 f0                	mov    %esi,%eax
  8123ff:	89 f2                	mov    %esi,%edx
  812401:	d3 ef                	shr    %cl,%edi
  812403:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812407:	d3 e0                	shl    %cl,%eax
  812409:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  81240d:	09 f8                	or     %edi,%eax
  81240f:	d3 ea                	shr    %cl,%edx
  812411:	83 c4 20             	add    $0x20,%esp
  812414:	5e                   	pop    %esi
  812415:	5f                   	pop    %edi
  812416:	5d                   	pop    %ebp
  812417:	c3                   	ret    
  812418:	39 d6                	cmp    %edx,%esi
  81241a:	75 d9                	jne    8123f5 <__umoddi3+0xf5>
  81241c:	2b 45 e8             	sub    -0x18(%ebp),%eax
  81241f:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  812422:	eb d1                	jmp    8123f5 <__umoddi3+0xf5>
  812424:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812428:	39 f2                	cmp    %esi,%edx
  81242a:	0f 82 18 ff ff ff    	jb     812348 <__umoddi3+0x48>
  812430:	e9 1d ff ff ff       	jmp    812352 <__umoddi3+0x52>
